<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java虚拟机学习——类加载机制 | 守望的稻草人</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java虚拟机学习——类加载机制</h1><a id="logo" href="/.">守望的稻草人</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java虚拟机学习——类加载机制</h1><div class="post-meta"><a href="/2018/01/31/Java虚拟机学习——类加载机制/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2018/01/31/Java虚拟机学习——类加载机制/"></i>留言,<i id="changyan_parti_unit" data-xid="2018/01/31/Java虚拟机学习——类加载机制/"></i>参与</a><p><span class="date">Jan 31, 2018</span><span><a href="/categories/JVM/" class="category">JVM</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="一：类加载机制概述"><a href="#一：类加载机制概述" class="headerlink" title="一：类加载机制概述"></a>一：类加载机制概述</h1><p><strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</strong><br>在java中，<font color="red">类型的加载、连接和初始化过程都是在程序运行期间完成的</font>，这种策略虽然会带来一些性能开销，但是却为java应用程序提供了高度的灵活性，java动态扩展的语言特性就是依赖运行期动态加载和动态链接这个特点形成的，所谓java动态扩展，比如，如果编写了一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。</p>
<h1 id="二：类加载时机"><a href="#二：类加载时机" class="headerlink" title="二：类加载时机"></a>二：类加载时机</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，共七个阶段。其中，验证、准备、解析3个阶段称为连接（Linking），7个过程发生顺序如下：<br><img src="/2018/01/31/Java虚拟机学习——类加载机制/类加载过程.png" alt="类加载过程"><br>上面这七个过程，除了解析这个过程外，其余过程必须按部就班地执行，即顺序是确定的，而解析过程不一定，在某些情况下可以在初始化阶段之后再执行，这是为了支持java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<p>java虚拟机规范中，并没有规定类加载过程中的第一个阶段（即加载阶段）的执行时机，但是对于初始化阶段，虚拟机规范中严格规定了<font color="red">“有且只有”下面5种情况下必须立即对类进行初始化</font>（而这时，加载、验证、准备自然需要在此之前开始）：<br>（1）遇到new、getstatic、putstatic、invokestatic这四条指令时，必须触发其初始化。这四条指令最常见的场景是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已经在编译期把结果放入常量池的静态字段除外，即常量除外）、调用一个类的静态方法的时候；<br>（2）进行反射调用的时候；<br>（3）初始化一个类的时候，如果其父类还没有初始化，则需要先触发其父类的初始化；<br>（4）当虚拟机启动时，需要先初始化那个包含main方法的要执行的主类；<br>（5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic 、REF_putStatic、REF_invokeStatic的方法句柄，句柄对应的类会被初始化；</p>
<p>上面五种场景触发类进行初始化的行为称为对一个类进行“主动引用”，除此之外，所有其他引用类的方式都不会触发初始化步骤（注意，此时已经是引用了，只不过不会触发初始化，其他阶段是否触发要看具体虚拟机的实现），这些引用称为“被动引用”。<br><strong>被动引用的几个例子</strong>：<br>（1）对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要出发子类的加载、验证需要看具体虚拟机实现；如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class SuperClass&#123;  </div><div class="line">    static&#123;  </div><div class="line">        System.out.println(&quot;SuperClass init!&quot;);  </div><div class="line">    &#125;  </div><div class="line">    public static int value = 123;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">class SubClass extends SuperClass&#123;  </div><div class="line">    static&#123;  </div><div class="line">        System.out.println(&quot;SubClass init!&quot;);//子类中引用父类的静态字段，不会导致类初始化  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">public class Test &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        System.out.println(SubClass.value);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line">123</div></pre></td></tr></table></figure></p>
<p>可以看到，只会打印出父类的初始化语句。</p>
<p>（2）通过数组定义来引用类，不会触发此类的初始化。如 A[] ints = new A[10] ，  不会触发A 类的初始化。而是会触发名为 LA的类初始化。它是一个由虚拟机自动生成的、直接继承于Object 的子类，创建动作由字节码指令 newarray 触发。这个类代表了一个元素类型为 A 的一位数组，数组中的属性和方法都实现在这个类中。Java 语言中数组的访问比C/C++ 安全是因为这个类封装了数组元素的访问方法。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SuperClass[] sca = new SuperClass[10];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SuperClass类为上面的那个，运行后发现并没有打印出SuperClass init!，说明没有触发SuperClass类的初始化阶段。</p>
<p>（3）常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class ConstClass&#123;  </div><div class="line">    static&#123;  </div><div class="line">        System.out.println(&quot;ConstClass init!&quot;);  </div><div class="line">    &#125;  </div><div class="line">    public static final String HELLOWORLD = &quot;hello world&quot;;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">public class Test &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        System.out.println(ConstClass.HELLOWORLD);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello world</div></pre></td></tr></table></figure></p>
<p>只是输出了hello world，并没有输出ConstClass init!，可见ConstClass类并没有被初始化。</p>
<p>注意：<br>上面讲的三个例子是被动引用的情况，很多情况下我们会通过new来初始化一个类，这个情形它属于上面提到的5种主动引用的场景，因此会触发这个类的初始化，如果这个类有父类的话，会先触发父类的初始化。注意不要和上面的被动引用搞混了。</p>
<p>接口的初始化<br>上面代码中用static语句块进行初始化，而结构中不能使用static语句块，但是编译器仍然回味接口生成&lt;clinit&gt;()类构造器来初始化接口中的成员变量（常量）；接口与类初始化的区别主要是在上面五种主动引用中的第三种：当一个类在初始化时，要求其父类全部已经初始化过了，但是对于接口的初始化来说，并不要求其父接口全部都完成了初始化，只有在真正使用到付接口的时候（如引用接口中定义的常量）才会初始化。</p>
<h1 id="三：类加载过程"><a href="#三：类加载过程" class="headerlink" title="三：类加载过程"></a>三：类加载过程</h1><h2 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h2><p>在加载阶段，需要完成三件事情：<br>（1）通过一个类的全限定名来获取其定义的二进制字节流。(<font color="red">获取.class文件的二进制流</font>)</p>
<p>（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。(<font color="red">将类信息、静态变量、字节码、常量这些.class文件中的内容放入方法区中</font>)</p>
<p>（3）在内存中生成一个代表这个类的java.lang.Class对象（并没有明确规定是在java堆中，对于HotSpot虚拟机来说，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），作为对方法区中这些数据的访问入口。(<font color="red">在内存中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的</font>)</p>
<p>对于（1），并没有指明二进制字节流的获取途径，也即不一定都是从一个Class文件中获取，还可以从如下方式获取：</p>
<p>1）从压缩包中获取，比如 JAR包、EAR、WAR包等<br>2）从网络中获取，比如红极一时的Applet技术<br>3）从运行过程中动态生成，最出名的便是动态代理技术，在java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为“$Proxy”的代理类的二进制流<br>4）从其它文件生成，如JSP文件生成Class 类<br>5）从数据库中读取，比如说有些中间件服务器，通过数据库完成程序代码在集群之间的分发</p>
<p>相对于类加载过程的其他阶段，加载这一步骤是开发人员可控的，即可以通过自定义类加载器来控制加载过程。</p>
<p>对于数组来说，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但是数组的元素类型，最终是要靠类加载器去创建。</p>
<h2 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h2><p>验证阶段的目的是<font color="red">为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</font><br>Java语言本身是相对安全的，因为使用纯粹的java代码无法做到诸如访问数组边界意外的数据、讲一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果我们这样做了，那编译器将拒绝编译，也就保证了安全。但是前面说过，Class文件并不一定要用Java源码编译而来，它还可以从很多途径产生，在字节码层面，其他方式可能能做到java代码无法做到的事情，因此虚拟机需要对加载尽量的字节流进行验证。验证过程分为四步：<br>（1）文件格式验证<br>这一阶段是要<font color="red">验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</font>包括以下这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info 型的常量中是否有不符合UTF8 编码的数据</li>
<li>Class 文件中各个部分以及文件本身是否有被删除的或被附加的其它信息<br>…</li>
</ul>
<p>这一阶段验证的目的是<font color="red">保证输入的字节流能正确的解析并存储到方法区中，这阶段是基于二进制字节流进行的</font>，通过验证后，字节流才会进入到内存的方法区中进行存储。因此，后面的3个验证阶段是基于方法区的存储结构进行分析的，不会再直接操作字节流了。</p>
<p>（2）元数据验证<br>对字节码描述的信息进行语义分析，以<font color="red">保证其描述的信息符合Java语言规范的要求</font>，主要是验证类的继承关系、数据类型是否符合，验证点包括：</p>
<ul>
<li>这个类是否有父类（除Object类外，其他所有类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li>
<li>这个类如果不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否和父类产生矛盾（如覆盖了父类final 字段，出现了非法的方法重载，如方法参数一致，但返回类型却不同）</li>
</ul>
<p>（3）字节码验证<br>最复杂的一个阶段，主要目的是<font color="red">通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</font>。在元数据验证阶段对数据类型做完校验后，这个阶段将对类的方法体进行校验分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，有如下一些验证点：</p>
<ul>
<li>保证任何时候，操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放入了一个int类型数据，使用时却按 long 类型加载到本地变量表中</li>
<li>保证跳转指令不会跳转到方法体外的字节码指令上</li>
<li>保证方法体中类型转换是有效的</li>
</ul>
<p>（4）符号引用验证<br>这一阶段发生在虚拟机将符号引用转化为直接引用的时候，而这个转化动作发生在解析阶段，符号引用可以看做是<font color="red">对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</font>，验证点如下：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到相应的类</li>
<li>在指定类中对否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问<br>这一阶段验证的目的是确保解析动作能正常执行。</li>
</ul>
<p>对于虚拟机来说，验证阶段是一个非常重要的，但不是一定必要（因为对程序运行期没有影响）的的阶段。</p>
<h2 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。有两点需要注意：<br>（1）这阶段进行内存分配的仅包括类变量（即被static修饰的变量），不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中；<br>（2）这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义如下：<br>    public static int value = 123;<br>那变量value在准备阶段过后的零值为0而不是123，因为这时候并未执行任何Java方法，把value赋值为123的动作是在初始化阶段才会进行。对于“非通常情况”，是指定义为常量的那些变量（即final修饰的），会在这一阶段就被赋值，如：<br>    public static final int value = 123;<br>此时在准备阶段过后，value的值将会被赋值为123。</p>
<h2 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h2><p>解析阶段是<font color="red">虚拟机将常量池中的符号引用转化为直接引用的过程。</font></p>
<ul>
<li>符号引用（Symbolic References）：即用一组符号来描述所引用的目标。它与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中。</li>
<li>直接引用（Direct References）：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。它是和虚拟机内存布局相关的，如果有了直接引用，那引用的目标必定已经在内存中存在了。<br>解析动作主要针对 类或接口、字段、类方法、接口方法、方法类型、方法句柄 和 调用限定符 7类符号引用进行。<br>（1）类或接口的解析<br>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。<br>（2）字段解析<br>在对字段进行解析前，会先查看该字段所属的类或接口的符号引用是否已经解析过，没有就先对字段所属的接口或类进行解析。在对字段进行解析的时候，先查找本类或接口中是否有该字段，有就直接返回；否则，再对实现的接口进行遍历，会按照继承关系从下往上递归（也就是说，每个父接口都会走一遍）搜索各个接口和它的父接口，返回最近一个接口的直接引用；再对继承的父类进行遍历，会按照继承关系从下往上递归（也就是说，每个父类都会走一遍）搜索各个父类，返回最近一个父类的直接引用。<br>（3）类方法解析<br>和字段解析搜索步骤差不多，只不过是先搜索父类，再搜索接口。<br>（4）接口方法解析<br>和类方法解析差不多，只不过接口中不会有父类，因此只需要对父接口进行搜索即可。</li>
</ul>
<h2 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h2><p>初始化是类加载过程的最后一步，此阶段才开始真正执行类中定义的Java程序代码（或者说字节码，也仅限与执行&lt;clinit&gt;()方法）。在准备阶段，我们已经给变量付过一次系统要求的初始值（零值），而<font color="red">在初始化阶段，则会根据程序员的意愿给类变量和其他资源赋值。</font>主要是通过&lt;clinit&gt;()方法来执行的：<br> （1）&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;  </div><div class="line">    static&#123;  </div><div class="line">        i = 0;//可以给变量赋值，编译通过  </div><div class="line">        System.out.println(i);//编译不通过！！不能进行访问后面的静态变量  </div><div class="line">    &#125;  </div><div class="line">    static int i =1;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有点与我们平常的认知相反，这里是可以下赋值，却不能访问…</p>
<p> （2）&lt;clinit&gt;()方法与实例构造器&lt;init&gt;()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。因此，在虚拟机中第一个被执行的&lt;clinit&gt;()方法的类肯定是java.lang.Object。</p>
<p> （3）&lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</p>
<p> （4）接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成&lt;clinit&gt;()方法。但是接口与类不同的是：执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。</p>
<p> （5）虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>
<h1 id="四：类加载器"><a href="#四：类加载器" class="headerlink" title="四：类加载器"></a>四：类加载器</h1><p>前面说过，在类加载过程的第一个阶段：加载阶段，除了可以使用系统提供的引导类加载器外，还可以使用用户自定义的类加载器，以便让用户决定如何去获取所需要的类（是从Class文件中？还是从jar、或者其他方式…可以自由决定）。</p>
<h2 id="4-1-类和类加载器"><a href="#4-1-类和类加载器" class="headerlink" title="4.1 类和类加载器"></a>4.1 类和类加载器</h2><p>任意一个类，都需要由加载它的类加载器和这个类本身共同确定其在Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达的更通俗一些：<font color="red">比较两个类是否相等，只有在这两个类是同一个类加载器加载的前提下才意义。</font>否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，但只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里的“相等”，包括代表类的 Class 对象的equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括 instanceof 关键字对对象所属关系判定等情况。下面代码演示了不同类加载器对 instanceof 关键字运算的结果的影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTest &#123;    </div><div class="line">    public static void main(String[] args) throws Exception &#123;    </div><div class="line">        ClassLoader myLoader = new ClassLoader() &#123;    </div><div class="line">            @Override    </div><div class="line">            public Class&lt;?&gt; loadClass(String name)    </div><div class="line">                    throws ClassNotFoundException &#123;    </div><div class="line">                try &#123;    </div><div class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1)    </div><div class="line">                            + &quot;.class&quot;;    </div><div class="line">                    InputStream is = getClass().getResourceAsStream(fileName);    </div><div class="line">                    if (is == null) &#123;    </div><div class="line">                        return super.loadClass(name);    </div><div class="line">                    &#125;    </div><div class="line">                    byte[] b = new byte[is.available()];    </div><div class="line">                    is.read(b);    </div><div class="line">                    return defineClass(name, b, 0, b.length);    </div><div class="line">                &#125; catch (IOException e) &#123;    </div><div class="line">                    throw new ClassNotFoundException(name);    </div><div class="line">                &#125;    </div><div class="line">            &#125;    </div><div class="line">        &#125;;    </div><div class="line">  </div><div class="line">        Class c = myLoader.loadClass(&quot;org.bupt.xiaoye.blog.ClassLoaderTest&quot;);    </div><div class="line">        Object obj = c.newInstance();    </div><div class="line">        System.out.println(obj.getClass());    </div><div class="line">        System.out.println(ClassLoaderTest.class);    </div><div class="line">        System.out.println(obj instanceof ClassLoaderTest);    </div><div class="line">  </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class org.bupt.xiaoye.blog.ClassLoaderTest  </div><div class="line">class org.bupt.xiaoye.blog.ClassLoaderTest  </div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>我们使用了一个自定义的类加载器去加载ClassLoaderTest，由第一句也可以看出这个对象也的确是ClassLoaderTest实例化出来的对象，但是这个对象在与类class org.bupt.xiaoye.blog.ClassLoaderTest 做属性检查的时候却反悔了false，这就是因为虚拟机中存在了两个ClassLoaderTest类，一个由系统应用程序类加载器加载，一个由我们自定义的类加载器加载，虽然是 来自同一个Class文件，但依然是两个独立的类。</p>
<p>因此，<font color="red">类是否相等，取决于类本身和加载该类的类加载器是否是同一个类加载器。</font></p>
<h2 id="4-2-双亲委派模型"><a href="#4-2-双亲委派模型" class="headerlink" title="4.2 双亲委派模型"></a>4.2 双亲委派模型</h2><p>从虚拟机的角度来讲，只存在两种不同的类加载器：</p>
<p>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++  语言实现， 是虚拟机自身的一部分：<br>另一种就是所有其它的类加载器， 这些类加载器用Java 语言实现，独立于虚拟机外部，并且全都继承与抽象类 java.lang.ClassLoader。</p>
<p>从Java 开发人员的角度来看，类加载器还可以划分的更细致一些，绝大多数Java 程序都会用到以下3种系统提供的类加载器：</p>
<p>（1）启动类加载器（Bootstrap ClassLoader） ： 这个类加载器负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数指定的路径中的，并且是虚拟机识别的(仅按照文件名识别,如rt.jar ，名字不符合类库不会加载) 类库加载到虚拟机内存中。启动类加载器无法被 java 程序直接引用，如需要，直接使用 null 代替即可。<br>（2）扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<br>（3）应用程序类加载器(Application ClassLoader)：这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。这个这个类加载器是 ClassLoader 中的getSystemClassLoader() 方法的返回值，所以一般称它为系统类加载器。它负责加载用户路径(ClassPath)上所指定的类库，开发者可以使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>我们的应用程序都是由这3中类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如下图所示：</p>
<p>!双亲委派](Java虚拟机学习——类加载机制/双亲委派.png)</p>
<p>图中的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器，其余的类加载器都应该有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是使用组合关系来复用父加载器的代码。<br>双亲委派模型的工作过程是：<font color="red">如果一个类加载器收到了类加载器的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类时），子加载类才会尝试自己去加载。</font></p>
<p>使用双亲委派模型的好处：就是<font color="red">Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</font>比如对于类Object来说，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器去加载，因此Object类在程序中的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类自己去加载的话，按照我们前面说的，如果用户自己编写了一个Object类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，此时Java类型提醒中最基础的行为也就无法保证了，应用程序也将变得混乱。</p>
<p>因此，双亲委派模型对于保证Java程序的稳定运作很重要，但是他的实现其实很简单，实现双亲委派模型的代码几种在java.lang.ClassLoader的loadClass()方法之中，逻辑清晰易懂：先检查类是否被加载过，若没有则调用父加载器的loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载器失败，抛出 ClassNotFoundException 异常后，再调用自己的 finClass() 方法进行加载，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)    </div><div class="line">        throws ClassNotFoundException &#123;    </div><div class="line">    synchronized (getClassLoadingLock(name)) &#123;    </div><div class="line">        // 首先检查类是否已经被加载过    </div><div class="line">        Class c = findLoadedClass(name);    </div><div class="line">        if (c == null) &#123;    </div><div class="line">            long t0 = System.nanoTime();    </div><div class="line">            try &#123;    </div><div class="line">                if (parent != null) &#123;    </div><div class="line">                    // 调用父类加载器加载    </div><div class="line">                    c = parent.loadClass(name, false);    </div><div class="line">                &#125; else &#123;    </div><div class="line">                    c = findBootstrapClassOrNull(name);    </div><div class="line">                &#125;    </div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;    </div><div class="line">                // ClassNotFoundException thrown if class not found    </div><div class="line">                // from the non-null parent class loader    </div><div class="line">            &#125;    </div><div class="line">  </div><div class="line">            if (c == null) &#123;    </div><div class="line">                // If still not found, then invoke findClass in order    </div><div class="line">                // to find the class.    </div><div class="line">                //父类加载器无法完成加载，调用本身的加载器加载  </div><div class="line">                long t1 = System.nanoTime();    </div><div class="line">                c = findClass(name);    </div><div class="line">  </div><div class="line">                // this is the defining class loader; record the stats    </div><div class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(    </div><div class="line">                        t1 - t0);    </div><div class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(    </div><div class="line">                        t1);    </div><div class="line">                sun.misc.PerfCounter.getFindClasses().increment();    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        if (resolve) &#123;    </div><div class="line">            resolveClass(c);    </div><div class="line">        &#125;    </div><div class="line">        return c;    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考:<br>周志明:《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>
</div><div class="tags"><a href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/01/31/IntelliJ-IDEA-2017-3激活/" class="pre">IntelliJ IDEA 2017.3激活</a><a href="/2018/01/30/JDK1.8源码解析——String/" class="next">JDK1.8源码解析——String</a></div><div id="comments"><div id="SOHUCS" sid="2018/01/31/Java虚拟机学习——类加载机制/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一：类加载机制概述"><span class="toc-text">一：类加载机制概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二：类加载时机"><span class="toc-text">二：类加载时机</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三：类加载过程"><span class="toc-text">三：类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-加载"><span class="toc-text">3.1 加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-验证"><span class="toc-text">3.2 验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-准备"><span class="toc-text">3.3 准备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-解析"><span class="toc-text">3.4 解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-初始化"><span class="toc-text">3.5 初始化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四：类加载器"><span class="toc-text">四：类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-类和类加载器"><span class="toc-text">4.1 类和类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-双亲委派模型"><span class="toc-text">4.2 双亲委派模型</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/Java多线程系列——Lock类解析/">Java多线程系列——Lock类解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/Java多线程系列——原子类的实现（CAS算法）/">Java多线程系列——原子类的实现（CAS算法）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/乐观锁与悲观锁/">乐观锁与悲观锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/Spring源码学习-Bean的生命周期/">Spring源码学习--Bean的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/19/如何显示或者隐藏Ext-grid-Panel/">如何显示或者隐藏Ext.grid.Panel</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/springMVC通过Filter实现防止xss注入/">springMVC通过Filter实现防止xss注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/09/Caused-by-java-sql-SQLSyntaxErrorException-ORA-00932-数据类型不一致-应为-但却获得-CLOB/">Caused by: java.sql.SQLSyntaxErrorException: ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/JDK1-8源码解析——HashMap-二/">JDK1.8源码解析——HashMap(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/JDK1-8源码解析——HashMap/">JDK1.8源码解析——HashMap(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/JDK1-7源码解析——HashMap/">JDK1.7源码解析——HashMap</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HttpClient/">HttpClient</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK1-8源码/">JDK1.8源码</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebService/">WebService</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/axios/">axios</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/element-ui/">element ui</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/extjs/">extjs</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/oracle/">oracle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/quartz/">quartz</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/select2/">select2</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shiro/">shiro</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tomcat/">tomcat</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/weblogic/">weblogic</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ztree/">ztree</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/">学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信公共号/">微信公共号</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编码规范/">编码规范</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/extjs/" style="font-size: 15px;">extjs</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/IDEA/" style="font-size: 15px;">IDEA</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/JDK1-8源码/" style="font-size: 15px;">JDK1.8源码</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/tomcat/" style="font-size: 15px;">tomcat</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/Oracle-VM-VirtualBox/" style="font-size: 15px;">Oracle VM VirtualBox</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/quartz/" style="font-size: 15px;">quartz</a> <a href="/tags/spring-aop/" style="font-size: 15px;">spring aop</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/WebService/" style="font-size: 15px;">WebService</a> <a href="/tags/HttpClient/" style="font-size: 15px;">HttpClient</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/ztree/" style="font-size: 15px;">ztree</a> <a href="/tags/weblogic/" style="font-size: 15px;">weblogic</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/select2/" style="font-size: 15px;">select2</a> <a href="/tags/axios/" style="font-size: 15px;">axios</a> <a href="/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/tags/shiro/" style="font-size: 15px;">shiro</a> <a href="/tags/微信公共号/" style="font-size: 15px;">微信公共号</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/element-ui/" style="font-size: 15px;">element ui</a> <a href="/tags/编码规范/" style="font-size: 15px;">编码规范</a> <a href="/tags/git/" style="font-size: 15px;">git</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/wangyuanjun008" title="GitHub" target="_blank">GitHub</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">WangYuanJun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytn089Dg'; 
  var conf = '4501ebcf59ba2646236d1827a7751555'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>