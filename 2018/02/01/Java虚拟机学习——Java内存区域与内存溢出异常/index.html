<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java虚拟机学习——Java内存区域与内存溢出异常 | 守望的稻草人</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java虚拟机学习——Java内存区域与内存溢出异常</h1><a id="logo" href="/.">守望的稻草人</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java虚拟机学习——Java内存区域与内存溢出异常</h1><div class="post-meta"><a href="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/#comments" class="comment-count"><i id="changyan_count_unit" data-xid="2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/"></i>留言,<i id="changyan_parti_unit" data-xid="2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/"></i>参与</a><p><span class="date">Feb 01, 2018</span><span><a href="/categories/JVM/" class="category">JVM</a></span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h1 id="一：运行时数据区域"><a href="#一：运行时数据区域" class="headerlink" title="一：运行时数据区域"></a>一：运行时数据区域</h1><p><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/MemoryArea.jpg" alt="MemoryArea"></p>
<h2 id="1-1-程序计数器（Program-Counter-Register）"><a href="#1-1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.1 程序计数器（Program Counter Register）"></a>1.1 程序计数器（Program Counter Register）</h2><p>程序计数器（Program Counter Register），也有称作为PC寄存器。在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。<br>虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的。程序计数器（ Program Counter Register）是一块较小的内存空间，<font color="red">它的作用可以看做是当前线程所执行的字节码的行号指示器。</font>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序,此时程序计数器需要记录当前线程执行到哪一步了，以便下一次CPU可以在这个记录点上继续执行。因此，可以这么说，<font color="red">程序计数器是每个线程所私有的。</font></p>
<p>在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址,如果线程执行的是native方法，则程序计数器中的值是undefined。</p>
<p>由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于<font color="red">程序计数器是不会发生内存溢出现象(OutOfMemory)的。</font></p>
<h2 id="1-2-java虚拟机栈"><a href="#1-2-java虚拟机栈" class="headerlink" title="1.2 java虚拟机栈"></a>1.2 java虚拟机栈</h2><p>与程序计时器一样,<font color="red">虚拟机栈也是线程私有的，</font>它的生命周期与线程相同，虚拟机中描述的是Java方法执行的内存模型，<font color="red">每个方法在执行的同时都会创建一个栈帧（Stack Frame）(Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</font>每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈道出栈的过程。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。其中局部变量表中存放了编译器可知的各种基本数据类型、对象引用类型（不是对象本身）。</p>
<p>局部变量表，就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。局部变量表中存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用（ reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。<font color="red">局部变量表所需的内存空间在编译期完成分配</font>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期不会改变局部变量大小。</p>
<p>操作数栈，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的以及参数的传递。</p>
<p>指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。</p>
<p>方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。<br>由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。<br> 对于java虚拟机栈，有两种异常情况：<br><strong>1)如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常 。</strong><br><strong>2)如果虚拟机栈扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</strong><br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/java虚拟机栈.png" alt="java虚拟机栈"></p>
<h2 id="1-3-本地方法栈（Native-Method-Stack）"><a href="#1-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.3 本地方法栈（Native Method Stack）"></a>1.3 本地方法栈（Native Method Stack）</h2><p><font color="red">线程私有。</font>本地方法栈与Java栈的作用和原理非常相似。区别只不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，<font color="red">而本地方法栈则是为虚拟机使用到的 Native方法服务</font>。有的虚拟机（譬如 Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。<br>与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutMemoryError错误。</p>
<h2 id="1-4-java堆-Java-Heap"><a href="#1-4-java堆-Java-Heap" class="headerlink" title="1.4 java堆(Java Heap)"></a>1.4 java堆(Java Heap)</h2><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。<font color="red">Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</font></p>
<p><font color="red">Java 堆是垃圾收集器管理的主要区域</font>，因此很多时候也被称做“GC 堆”（Garbage Collected Heap）。如果从内存回收的角度看，由于<font color="red">现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代（Young Generation）与老生代(Old Generation)；再细致一点的有Eden空间,From Survivor空间,To Survivor空间等。</font><strong>值得注意的是，从JKD1.7开始，永久代Perm逐渐被移除，最新的JDK1.8中已经使用元空间（MetaSpace）代替永久代。</strong>如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。但无论怎么去划分，无论那个区域，java堆中存储的依然是对象的实例。进一步划分的目的是为了更好地回收内存，或者更快地分配内存。<br>当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果堆中没有内存完成实例分配，并且对也无法再扩展时，将会抛出OutOfMemoryError异常。<br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/java堆.jpg" alt="java堆"><br>如图，新生代还可以分为Eden空间、From Survivor空间、To Survivor空间。<br>永久代(Permanent Generation)用于存储静态类型数据，与垃圾收集器关系不大。<br>注意：本图展示的是JVM堆的内存模型，JVM堆内存包括Java堆区域 和 永久代区域。因此，永久代不属于Java堆。</p>
<h2 id="1-5-方法区（Method-Area）"><a href="#1-5-方法区（Method-Area）" class="headerlink" title="1.5 方法区（Method Area）"></a>1.5 方法区（Method Area）</h2><p><font color="red">方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 </font>。</p>
<p>方法区与堆一样，是各个线程共享的内存区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。<br>在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。<font color="red">不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。<br>相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，<font color="red">这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</font><br><strong>JDK1.7中，已经把放在永久代的字符串常量池移到堆中。JDK1.8撤销永久代，引入元空间。</strong></font></p>
<p>根据java虚拟机规范的规定：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h2 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h2><p>运行时常量池是方法区的一部分，在Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将<font color="red">在类加载后进入方法区的运行时常量池中存放</font>。</p>
<p><font color="red">同时运行时常量池具备动态性</font>，并非预置入Class文件中常量池的内存才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，例如String类的intern()方法(方法返回s1在常量池中的引用，没有则创建)。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h2 id="1-7-直接内存（Direct-Memory）"><a href="#1-7-直接内存（Direct-Memory）" class="headerlink" title="1.7 直接内存（Direct Memory）"></a>1.7 直接内存（Direct Memory）</h2><p><font color="red">直接内存（Direct memory）并不是JVM运行时数据区的一部分</font>，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁使用，而且它也可能导致OutOfMemoryError异常出现。</p>
<p>直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因此避免了在java堆和Native堆中来回复制数据。</p>
<p>本机直接内存的分配不会受到Java堆大小的限制，但是，还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制，从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h1 id="二：hotspot虚拟机对象奥秘"><a href="#二：hotspot虚拟机对象奥秘" class="headerlink" title="二：hotspot虚拟机对象奥秘"></a>二：hotspot虚拟机对象奥秘</h1><h2 id="2-1-对象的创建过程"><a href="#2-1-对象的创建过程" class="headerlink" title="2.1 对象的创建过程"></a>2.1 对象的创建过程</h2><p>Java在语言层面，通过一个关键字new来创建对象。在虚拟机中，当遇到一条new指令后，将开始如下创建过程：</p>
<h3 id="2-1-1-判断类是否加载、解析、初始化"><a href="#2-1-1-判断类是否加载、解析、初始化" class="headerlink" title="2.1.1 判断类是否加载、解析、初始化"></a>2.1.1 判断类是否加载、解析、初始化</h3><p>虚拟机遇到一条new指令时，先去检查这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那先执行相应的类加载过程。</p>
<h3 id="2-1-2-为新对象分配内存"><a href="#2-1-2-为新对象分配内存" class="headerlink" title="2.1.2 为新对象分配内存"></a>2.1.2 为新对象分配内存</h3><p>前面说到，对象的内存分配是在Java堆中的，对象所需内存的大小在类加载完便可确实。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，此时Java堆中的情况有两种可能，一种是Java堆中内存是绝对规整的，一种是Java堆中的内存并不是规整的。因此有两种分配方式：</p>
<ol>
<li>Java堆内存是规整的，即所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，此时，分配内存仅需要把这个指针向空闲空间那边挪动一段与对象大小相等的距离，这种方式也称为“指针碰撞”（Bump the Pointer）；</li>
<li>Java堆内存不是规整的，即已使用的内存和空闲的内存相互交错，就没有办法简单地进行指针的移动，此时的分配方案是，虚拟机必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的控件划分给对象实例，并更新列表上的记录，这种方式也称为“空闲列表”（Free List）；</li>
</ol>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，对于Serial、ParNew等带Compact过程的垃圾收集器，系统采用的是指针碰撞算法；对于CMS这种基于Mark-Sweep算法的收集器，通常采用空闲列表算法。</p>
<h3 id="2-1-3-解决并发安全问题"><a href="#2-1-3-解决并发安全问题" class="headerlink" title="2.1.3 解决并发安全问题"></a>2.1.3 解决并发安全问题</h3><p>确定了如何划分内存空间之后，还有一个问题就是，对象的创建在虚拟机中是非常频繁的行为，比如，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，解决这种并发问题，一般有两种方案：</p>
<ol>
<li>对分配内存空间的动作进行同步处理，比如，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；</li>
<li>另一种方式是，把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁定，虚拟机是否使用TLAB，可以通过-XX:+/-UserTLAB参数来设定。</li>
</ol>
<h3 id="2-1-4-初始化分配到的内存空间"><a href="#2-1-4-初始化分配到的内存空间" class="headerlink" title="2.1.4 初始化分配到的内存空间"></a>2.1.4 初始化分配到的内存空间</h3><p>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作也可以提前至TLAB分配时进行。也正是这一步操作，才保证了我们对象的实例字段在Java代码中可以不赋初值就直接使用。注意，此时对象的实例字段全部为零值，并没有按照程序中的初值进行初始化。</p>
<h3 id="2-1-5-设置对象实例的对象头"><a href="#2-1-5-设置对象实例的对象头" class="headerlink" title="2.1.5 设置对象实例的对象头"></a>2.1.5 设置对象实例的对象头</h3><p>上面工作完成后，虚拟机对对象进行必要的设置，主要是设置对象的对象头信息，比如，这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等…</p>
<h3 id="2-1-6-初始化对象方法"><a href="#2-1-6-初始化对象方法" class="headerlink" title="2.1.6 初始化对象方法"></a>2.1.6 初始化对象<init>方法</init></h3><p>其实，上面工作完成后，从虚拟机角度来看，一个新的对象已经产生了，但从Java程序的角度来看，对象创建才刚刚开始，对象实例中的字段仅仅都为零值，还需要通过<init>方法进行初始化，把对象按照程序员的意愿进行初始化。此时，一个真正可用的对象才算完全产生出来。</init></p>
<h2 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h2><p>经过前面的创建工作，一个对象已经成功产生，也已经在Java堆中分配好了内存。那这个对象在Java堆内存中到底是什么形态呢？又包括哪些部分呢？这就涉及到了对象的内存布局了。<br>不同的虚拟机实现中，对象的内存布局有差别，以最常用的HotSpot虚拟机为例，对象在内存中存储的布局分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。</p>
<ul>
<li>对象头：包含两部分信息，一部分是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，对象头中还有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组大小。</li>
<li>实例数据：真正存储对象有效信息的部分。也就是在程序中定义的各种类型的字段内容，包括从父类继承下来的，以及子类中定义的，都会在实例数据中记录。</li>
<li>对齐填充：不是必然存在的，仅起着占位符的作用，对于HotSpot来说，虚拟机的自动内存管理系统要求对象其实地址必须是8字节的整数倍，因此，如果对象实例数据部分没有对齐时，就需要通过对齐填充的方式来补全。</li>
</ul>
<h2 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h2><p>建立了对象是为了使用对象，我们对数据的使用是通过栈上的reference数据来操作堆上的具体对象，对于不同的虚拟机实现，reference数据类型有不同的定义，主要是如下两种访问方式：</p>
<h3 id="2-3-1-使用句柄访问"><a href="#2-3-1-使用句柄访问" class="headerlink" title="2.3.1 使用句柄访问"></a>2.3.1 使用句柄访问</h3><p>此时，Java堆中将会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图：<br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/句柄访问.png" alt="句柄访问"></p>
<h3 id="2-3-2-使用直接指针访问"><a href="#2-3-2-使用直接指针访问" class="headerlink" title="2.3.2 使用直接指针访问"></a>2.3.2 使用直接指针访问</h3><p>此时reference中存储的就是对象的地址。如下图：<br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/直接指针访问.png" alt="直接指针访问"></p>
<p>上面所说的，所谓对象类型，其实就是指，对象所属的哪个类。</p>
<p>上面两种对象访问方式各有优势，使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时，只会改变句柄中的实例数据指针，而reference本身不需要修改；使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销（根据上图，节省的是对象实例数据的指针定位），由于对象的访问在Java中非常频繁，因此，这类开销积少成多后也是一项非常可观的执行成本。对于HotSpot而言，选择的是第二种方式。</p>
<h1 id="三：内存溢出"><a href="#三：内存溢出" class="headerlink" title="三：内存溢出"></a>三：内存溢出</h1><p><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/内存溢出测试.png" alt="内存溢出测试"><br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/内存区域报错.png" alt="内存区域报错"><br>OOM分为两种情况：内存溢出（Memory Overflow）和内存泄漏（Memory Leak）。</p>
<h2 id="3-1-OutOfMemoryError"><a href="#3-1-OutOfMemoryError" class="headerlink" title="3.1 OutOfMemoryError"></a>3.1 OutOfMemoryError</h2><p>是指程序在申请内存时，没有足够的空间供其使用，出现了Out Of Memory，也就是要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。<br>内存溢出分为上溢和下溢，比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。</p>
<h3 id="3-1-1-java堆溢出-OutOfMemoryError：Java-heap-space"><a href="#3-1-1-java堆溢出-OutOfMemoryError：Java-heap-space" class="headerlink" title="3.1.1 java堆溢出(OutOfMemoryError：Java heap space)"></a>3.1.1 java堆溢出(OutOfMemoryError：Java heap space)</h3><p>是被所有线程共享的一块内存区域，该内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配创建。由于他是虚拟机中管理的最大一块内存，所以是主要的收集区域。如果还需要再堆上分配实例，但是无法扩展出足够的内存空间，将会抛出OutOfMemoryError异常。<br><strong>Java堆用于存储对象实例，我们只要不断的创建对象，而又没有及时回收这些对象（即内存泄漏），就会在对象数量达到最大堆容量限制后产生内存溢出异常。</strong><br>如下代码限制java堆的大小为1m，不可扩展（就堆的最小值-Xms参数与最大值-Xmx参数设置为一样的即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出时Dump出当前的转储快照以便事后进行分析。<br>    /**</p>
<pre><code> * VM Args: -Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError
 * java堆溢出
 * 
 * @author：WangYuanJun
 * @date：2018年2月7日 下午2:22:42
 */
public class HeapOOM {

    static class OOMObejct {
    }

    public static void main(String[] args) {
        List&lt;OOMObejct&gt; list = new ArrayList&lt;&gt;();

        while (true) {
            list.add(new OOMObejct());
        }
    }
}

java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid4008.hprof ...
Heap dump file created [2760158 bytes in 0.013 secs]
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
    at com.example.demo.test3.HeapOOM.main(HeapOOM.java:21)
</code></pre><h3 id="3-1-2-虚拟机栈和本地方法栈溢出-OutOfMemoryError：Java-heap-space"><a href="#3-1-2-虚拟机栈和本地方法栈溢出-OutOfMemoryError：Java-heap-space" class="headerlink" title="3.1.2 虚拟机栈和本地方法栈溢出(OutOfMemoryError：Java heap space)"></a>3.1.2 虚拟机栈和本地方法栈溢出(OutOfMemoryError：Java heap space)</h3><p>虚拟机栈：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值，我们通过下面这段程序可以测试一下这个结果<br>当应用程序递归太深而发生堆栈溢出时，抛出该错误。因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。<br>栈溢出的原因：<br>（1）递归调用<br>（2）大量循环或死循环<br>（3）全局变量是否过多<br>（4）数组、List、Map数据过大<br><strong>1)如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常 。</strong></p>
<pre><code>/**
 * VM Args: -Xss160k
 * 
 * 
 * @author：WangYuanJun
 * @date：2018年2月7日 下午2:45:03
 */
public class JavaVMStackSOF {
    private int stackLen = 1;

    public void stackLeak() {
        stackLen++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println(&quot;stack length:&quot; + oom.stackLen);
            throw e;
        }
    }
}

stack length:771Exception in thread &quot;main&quot; 
java.lang.StackOverflowError
    at com.wdm.mem.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)
    at com.wdm.mem.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
    at com.wdm.mem.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
    at com.wdm.mem.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
</code></pre><p><strong>2)如果虚拟机栈扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</strong></p>
<pre><code> /**
 * VM Args: -Xss2m
 * 
 * 
 * @author：WangYuanJun
 * @date：2018年2月7日 下午3:04:59
 */
public class JavaVMStackOOM {

    private void dontStop() {
        while (true) {

        }
    }

    public void stackLeakByThread() {
        while (true) {
            Thread thread = new Thread(new Runnable() {

                @Override
                public void run() {
                    dontStop();
                }
            });
            thread.start();
        }

    }

    public static void main(String[] args) {
        JavaVMStackOOM javaVMStackOOM = new JavaVMStackOOM();
        javaVMStackOOM.stackLeakByThread();
    }
}

Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread
</code></pre><h3 id="3-1-3-方法区和运行常量池溢出"><a href="#3-1-3-方法区和运行常量池溢出" class="headerlink" title="3.1.3 方法区和运行常量池溢出"></a>3.1.3 方法区和运行常量池溢出</h3><p>1.方法区溢出<br>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过动态生成类来模拟 “PermGen space”的内存溢出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">  * jdk1.7</div><div class="line">  * VM Args: -XX:PermSize=8M -XX:MaxPermSize=8M</div><div class="line">  *</div><div class="line">  * @author：WangYuanJun</div><div class="line">  * @date：2018年2月2日 下午1:42:48</div><div class="line">  */</div><div class="line">public class PermGenOomMock&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        URL url = null;</div><div class="line">        List&lt;ClassLoader&gt; classLoaderList = new ArrayList&lt;ClassLoader&gt;();</div><div class="line">        try &#123;</div><div class="line">            url = new File(&quot;/tmp&quot;).toURI().toURL();</div><div class="line">            URL[] urls = &#123;url&#125;;</div><div class="line">            while (true)&#123;</div><div class="line">                ClassLoader loader = new URLClassLoader(urls);</div><div class="line">                classLoaderList.add(loader);</div><div class="line">                loader.loadClass(&quot;com.example.demo.test2.test&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</div></pre></td></tr></table></figure></p>
<p>本例中使用的 JDK 版本是 1.7，指定的 PermGen 区的大小为 8M。通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟悉的 “java.lang.OutOfMemoryError: PermGen space “ 异常了。这里之所以采用 JDK 1.7，是因为在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。可参考<a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p>
<p>2.运行常量池溢出 </p>
<p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">运行常量池溢出(jdk1.6及jdk1.6之前)</div><div class="line">/**</div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M -Xmx16m</div><div class="line"> * 使用jdk1.6及jdk1.6之前</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年2月2日 下午2:10:12</div><div class="line"> */</div><div class="line">public class RuntimeConsPoolOOM &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        int i = 0;</div><div class="line">        while (true) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError： PermGen space</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M -Xmx16m</div><div class="line"> * 使用jdk1.7</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年2月2日 下午2:10:12</div><div class="line"> */</div><div class="line">public class RuntimeConsPoolOOM &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        int i = 0;</div><div class="line">        while (true) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError： Java heap space</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * VM Args: -Xmx16m</div><div class="line"> * 使用jdk1.8</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年2月2日 下午2:10:12</div><div class="line"> */</div><div class="line">public class RuntimeConsPoolOOM &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        int i = 0;</div><div class="line">        while (true) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError： Java heap space</div></pre></td></tr></table></figure>
<p>　　从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。现在我们看看元空间到底是一个什么东西？</p>
<p>　　元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br>　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集<br>　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<p>现在我们在 JDK 8下重新运行一下代码段 ，不过这次不再指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">  * jdk1.8</div><div class="line">  * -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</div><div class="line">  * 1.8无PermGen space，取而代之是一个叫做 Metaspace（元空间）</div><div class="line">  * Metaspace（元空间）内存溢出</div><div class="line">  * 解决：增大perm区，允许class回收 </div><div class="line">  * </div><div class="line">  * @author：WangYuanJun</div><div class="line">  * @date：2018年2月2日 下午1:42:48</div><div class="line">  */</div><div class="line">public class PermGenOomMock&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        URL url = null;</div><div class="line">        List&lt;ClassLoader&gt; classLoaderList = new ArrayList&lt;ClassLoader&gt;();</div><div class="line">        try &#123;</div><div class="line">            url = new File(&quot;/tmp&quot;).toURI().toURL();</div><div class="line">            URL[] urls = &#123;url&#125;;</div><div class="line">            while (true)&#123;</div><div class="line">                ClassLoader loader = new URLClassLoader(urls);</div><div class="line">                classLoaderList.add(loader);</div><div class="line">                loader.loadClass(&quot;com.example.demo.test2.test&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError： Metaspace</div></pre></td></tr></table></figure></p>
<h3 id="3-1-4-本机直接内存溢出"><a href="#3-1-4-本机直接内存溢出" class="headerlink" title="3.1.4 本机直接内存溢出"></a>3.1.4 本机直接内存溢出</h3><p>通过参数-XX:MaxDirectMemorySize指定DirectMemory容量，若不指定则与Java堆最大值一样。可以直接通过反射获取Unsafe实例并进行内存分配，使用unsafe.allocateMemory()申请分配内存。不足时会出现OutOfMemoryError。</p>
<h2 id="3-2-内存泄露（memory-leak）"><a href="#3-2-内存泄露（memory-leak）" class="headerlink" title="3.2 内存泄露（memory leak）"></a>3.2 内存泄露（memory leak）</h2><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，举个例子，就是说系统的篮子（内存）是有限的，而你申请了一个篮子，拿到之后没有归还（忘记还了或是丢了），于是造成一次内存泄漏。在你需要用篮子的时候，又去申请，如此反复，最终系统的篮子无法满足你的需求，最终会由内存泄漏造成内存溢出。</p>
<h1 id="四：总结"><a href="#四：总结" class="headerlink" title="四：总结"></a>四：总结</h1><h2 id="4-1-内存区域模型小结："><a href="#4-1-内存区域模型小结：" class="headerlink" title="4.1 内存区域模型小结："></a>4.1 内存区域模型小结：</h2><pre><code>（1）线程私有的区域：程序计数器、虚拟机栈、本地方法栈；
（2）所有线程共享的区域：Java堆、方法区；（注：直接内存不属于虚拟机内存模型的部分）
（3）没有异常的区域：程序计数器；
（4）StackOverflowError异常：Java虚拟机栈、本地方法栈；
（5）OutOfMemoryError异常：除程序计数器外的其他四个区域，Java虚拟机栈、本地方法栈、Java堆、方法区；直接内存也会出现OutOfMemoryError。
</code></pre><h2 id="4-2-类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？"><a href="#4-2-类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？" class="headerlink" title="4.2 类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？"></a>4.2 类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？</h2><pre><code>- 在程序运行时类是在方法区，实例对象本身在堆里面。
- 方法字节码在方法区。
- 线程调用方法执行时创建栈帧并压栈，方法的参数和局部变量在栈帧的局部变量表。
- 对象的实例变量和对象一起在堆里，所以各个线程都可以共享访问对象的实例变量。
- 静态变量在方法区，所有对象共享。字符串常量等常量在运行时常量池。
- 各线程调用的方法，通过堆内的对象，方法区的静态数据，可以共享交互信息。
</code></pre><p>对于JVM的内存管理， 最重要的还是与OS内存管理知识进行类比以及结合实践来学习。理解JVM内存区域的目的也是为了在工程中出现内存相关异常时能够准确的定位所在区域，及时处理。</p>
<p>参考:<br>周志明:《深入理解Java虚拟机：JVM高级特性与最佳实践》<br><!-- [http://blog.csdn.net/qq_36859415/article/details/53407439](http://blog.csdn.net/qq_36859415/article/details/53407439)
[https://www.cnblogs.com/ACFLOOD/p/5608292.html](https://www.cnblogs.com/ACFLOOD/p/5608292.html)
[http://www.cnblogs.com/paddix/p/5309550.html](http://www.cnblogs.com/paddix/p/5309550.html)
[https://www.cnblogs.com/hawk-whu/p/6731260.html](https://www.cnblogs.com/hawk-whu/p/6731260.html)
[http://blog.csdn.net/jiyiqinlovexx/article/details/51171452](http://blog.csdn.net/jiyiqinlovexx/article/details/51171452)
[http://blog.csdn.net/u011080472/article/details/51320300](http://blog.csdn.net/u011080472/article/details/51320300) --></p>
</div><div class="tags"><a href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/" class="pre">Java虚拟机学习——垃圾收集器与内存分配策略</a><a href="/2018/01/31/IntelliJ-IDEA-2017-3激活/" class="next">IntelliJ IDEA 2017.3激活</a></div><div id="comments"><div id="SOHUCS" sid="2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/"></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一：运行时数据区域"><span class="toc-text">一：运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-程序计数器（Program-Counter-Register）"><span class="toc-text">1.1 程序计数器（Program Counter Register）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-java虚拟机栈"><span class="toc-text">1.2 java虚拟机栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-本地方法栈（Native-Method-Stack）"><span class="toc-text">1.3 本地方法栈（Native Method Stack）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-java堆-Java-Heap"><span class="toc-text">1.4 java堆(Java Heap)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-方法区（Method-Area）"><span class="toc-text">1.5 方法区（Method Area）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-运行时常量池"><span class="toc-text">1.6 运行时常量池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-直接内存（Direct-Memory）"><span class="toc-text">1.7 直接内存（Direct Memory）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二：hotspot虚拟机对象奥秘"><span class="toc-text">二：hotspot虚拟机对象奥秘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-对象的创建过程"><span class="toc-text">2.1 对象的创建过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-判断类是否加载、解析、初始化"><span class="toc-text">2.1.1 判断类是否加载、解析、初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-为新对象分配内存"><span class="toc-text">2.1.2 为新对象分配内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-解决并发安全问题"><span class="toc-text">2.1.3 解决并发安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-初始化分配到的内存空间"><span class="toc-text">2.1.4 初始化分配到的内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-设置对象实例的对象头"><span class="toc-text">2.1.5 设置对象实例的对象头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-初始化对象方法"><span class="toc-text">2.1.6 初始化对象方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-对象的内存布局"><span class="toc-text">2.2 对象的内存布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-对象的访问定位"><span class="toc-text">2.3 对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-使用句柄访问"><span class="toc-text">2.3.1 使用句柄访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-使用直接指针访问"><span class="toc-text">2.3.2 使用直接指针访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三：内存溢出"><span class="toc-text">三：内存溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-OutOfMemoryError"><span class="toc-text">3.1 OutOfMemoryError</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-java堆溢出-OutOfMemoryError：Java-heap-space"><span class="toc-text">3.1.1 java堆溢出(OutOfMemoryError：Java heap space)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-虚拟机栈和本地方法栈溢出-OutOfMemoryError：Java-heap-space"><span class="toc-text">3.1.2 虚拟机栈和本地方法栈溢出(OutOfMemoryError：Java heap space)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-方法区和运行常量池溢出"><span class="toc-text">3.1.3 方法区和运行常量池溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-本机直接内存溢出"><span class="toc-text">3.1.4 本机直接内存溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-内存泄露（memory-leak）"><span class="toc-text">3.2 内存泄露（memory leak）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四：总结"><span class="toc-text">四：总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-内存区域模型小结："><span class="toc-text">4.1 内存区域模型小结：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？"><span class="toc-text">4.2 类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/Java多线程系列——原子类的实现（CAS算法）/">Java多线程系列——原子类的实现（CAS算法）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/13/乐观锁与悲观锁/">乐观锁与悲观锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/20/Spring源码学习-Bean的生命周期/">Spring源码学习--Bean的生命周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/19/如何显示或者隐藏Ext-grid-Panel/">如何显示或者隐藏Ext.grid.Panel</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/17/springMVC通过Filter实现防止xss注入/">springMVC通过Filter实现防止xss注入</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/09/Caused-by-java-sql-SQLSyntaxErrorException-ORA-00932-数据类型不一致-应为-但却获得-CLOB/">Caused by: java.sql.SQLSyntaxErrorException: ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/JDK1-8源码解析——HashMap-二/">JDK1.8源码解析——HashMap(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/27/JDK1-8源码解析——HashMap/">JDK1.8源码解析——HashMap(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/JDK1-7源码解析——HashMap/">JDK1.7源码解析——HashMap</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/12/Docker容器部署Java-web应用方式二/">Docker容器部署Java web应用(定制镜像)</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dubbo/">Dubbo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/HttpClient/">HttpClient</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/IDEA/">IDEA</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JDK1-8源码/">JDK1.8源码</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebService/">WebService</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/axios/">axios</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/element-ui/">element ui</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/extjs/">extjs</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/oracle/">oracle</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/quartz/">quartz</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/select2/">select2</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shiro/">shiro</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tomcat/">tomcat</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/weblogic/">weblogic</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ztree/">ztree</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习/">学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微信公共号/">微信公共号</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编码规范/">编码规范</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/SpringMVC/" style="font-size: 15px;">SpringMVC</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/tags/extjs/" style="font-size: 15px;">extjs</a> <a href="/tags/工具/" style="font-size: 15px;">工具</a> <a href="/tags/IDEA/" style="font-size: 15px;">IDEA</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/JDK1-8源码/" style="font-size: 15px;">JDK1.8源码</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/tomcat/" style="font-size: 15px;">tomcat</a> <a href="/tags/oracle/" style="font-size: 15px;">oracle</a> <a href="/tags/Oracle-VM-VirtualBox/" style="font-size: 15px;">Oracle VM VirtualBox</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/quartz/" style="font-size: 15px;">quartz</a> <a href="/tags/spring-aop/" style="font-size: 15px;">spring aop</a> <a href="/tags/spring/" style="font-size: 15px;">spring</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/SpringBoot/" style="font-size: 15px;">SpringBoot</a> <a href="/tags/WebService/" style="font-size: 15px;">WebService</a> <a href="/tags/HttpClient/" style="font-size: 15px;">HttpClient</a> <a href="/tags/hexo/" style="font-size: 15px;">hexo</a> <a href="/tags/mybatis/" style="font-size: 15px;">mybatis</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/jquery/" style="font-size: 15px;">jquery</a> <a href="/tags/ztree/" style="font-size: 15px;">ztree</a> <a href="/tags/weblogic/" style="font-size: 15px;">weblogic</a> <a href="/tags/java/" style="font-size: 15px;">java</a> <a href="/tags/select2/" style="font-size: 15px;">select2</a> <a href="/tags/axios/" style="font-size: 15px;">axios</a> <a href="/tags/java基础/" style="font-size: 15px;">java基础</a> <a href="/tags/shiro/" style="font-size: 15px;">shiro</a> <a href="/tags/微信公共号/" style="font-size: 15px;">微信公共号</a> <a href="/tags/学习/" style="font-size: 15px;">学习</a> <a href="/tags/element-ui/" style="font-size: 15px;">element ui</a> <a href="/tags/编码规范/" style="font-size: 15px;">编码规范</a> <a href="/tags/git/" style="font-size: 15px;">git</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">五月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">十一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://github.com/wangyuanjun008" title="GitHub" target="_blank">GitHub</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">订阅</a> |  <a href="/about/">关于</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">WangYuanJun.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script><script>window._config = { showScore: true };
(function(){ 
  var appid = 'cytn089Dg'; 
  var conf = '4501ebcf59ba2646236d1827a7751555'; 
  var width = window.innerWidth || document.documentElement.clientWidth; 
  var nodes =document.getElementsByTagName("head")[0]||document.head||document.documentElement;
  if (/(Android|iPhone|iPad|iPod|iOS)/i.test(navigator.userAgent) && width < 750) {  
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>');
  }
  else { 
    var loadJs=function(d,a){
      var b=document.createElement("script");b.setAttribute("type","text/javascript");
      b.setAttribute("charset","UTF-8");
      b.setAttribute("src",d);
      if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}
      nodes.appendChild(b)
    };
    loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); 
  } 
  var loadCss = function(cssString){  
    var style=document.createElement("style");  
    style.setAttribute("type", "text/css");  
    if(style.styleSheet){// IE  
        style.styleSheet.cssText = cssString;  
    } else {// w3c  
        var cssText = document.createTextNode(cssString);  
        style.appendChild(cssText);  
    }
    nodes.appendChild(style);
  }
  window.onload=function(){loadCss('.module-hot-topic,.module-cmt-float-bar{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .cbox-prompt-w span.prompt-empty-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w .form-text-w span.text-null,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w a.comment-link-w,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-minwidth-w div.cont-comment-w span.comment-text-w,#SOHUCS #SOHU_MAIN .module-cmt-footer .section-service-w div.service-wrap-w a:hover,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w span.wrap-name-w,#SOHUCS #SOHU_MAIN .module-cmt-list .action-click-gw span.click-disable-eg a em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li div.title-name-gw,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number .comment-number span.cy-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .cmt-list-number span.comment-number,#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active,#SOHUCS #SOHU_MAIN .module-cmt-list .msg-wrap-gw .wrap-action-gw .action-click-gw span a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .picture-box-gw div.box-action-gw a:hover,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-action-gw .action-click-gw span a:hover em.icon-name-bg,#SOHUCS #SOHU_MAIN .module-cmt-list .wrap-user-gw span.user-name-gw a{color:#40759b!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-r,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-l,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-border-r{display:none!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .post-wrap-border-t div.post-wrap-border-t-l{background:#FFF!important;top:-2px!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-function-w .uploading-wrapper-dw div.wrapper-image-dw,#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w div.post-wrap-main,#SOHUCS #SOHU_MAIN .module-cmt-float-bar .wrap-cont-w .cont-form-w div.form-text-w,#SOHUCS #SOHU_MAIN .module-cmt-header .section-cbox-w .block-head-w div.header-login,#SOHUCS #SOHU_MAIN .module-cmt-list .module-cmt-box .post-wrap-w div.post-wrap-main{border:1px solid #e6e6e6!important;border-radius:20px 20px 20px 20px;margin:0!important}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw{width:130px!important;height:34px!important;line-height:33px!important;font-size:17px!important;background:#5483b1!important;border-radius:20px!important;color:#FFF!important;-webkit-box-shadow:0 -1px 4px #5483b1 inset;box-shadow:0 -1px 10px #5483b1 inset}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a .btn-fw:before{content:"发表评论"}#SOHUCS #SOHU_MAIN .module-cmt-box .post-wrap-w .wrap-action-w .action-issue-w .issue-btn-w a:hover .btn-fw{color:#40759b!important;background:#FFF!important}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li{background:none!important;border-bottom:1px solid #e6e6e6}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type .type-lists li.active{border:1px solid #e6e6e6;border-radius:10px 10px 0 0;border-bottom:none}#SOHUCS #SOHU_MAIN .module-cmt-list .block-title-gw ul li .title-name-gw div.title-name-gw-tag{background:#5483b1!important;border-radius:3px}#SOHUCS #SOHU_MAIN .module-cmt-list .cmt-list-type div.cmt-list-border{background-color:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item{border:1px solid #e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo{text-align:center;line-height:40px;border-radius:50%!important;background:#e6e6e6!important}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item .nt-logo:before{content:"畅";font-size:22px;color:#FFF}#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text,#SOHUCS #SOHU_MAIN .module-cmt-notice ul.nt-list li.nt-item a.nt-text i{color:#5483b1!important}#SOHUCS #SOHU_MAIN .module-cmt-header .section-title-w .title-user-w .user-wrap-w{background:#FFF!important}');};
})();</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>