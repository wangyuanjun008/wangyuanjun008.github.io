<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>守望的稻草人</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangyuanjun.cn/"/>
  <updated>2018-04-10T02:18:00.995Z</updated>
  <id>http://wangyuanjun.cn/</id>
  
  <author>
    <name>WangYuanJun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Caused by: java.sql.SQLSyntaxErrorException: ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</title>
    <link href="http://wangyuanjun.cn/2018/04/09/Caused-by-java-sql-SQLSyntaxErrorException-ORA-00932-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E4%B8%80%E8%87%B4-%E5%BA%94%E4%B8%BA-%E4%BD%86%E5%8D%B4%E8%8E%B7%E5%BE%97-CLOB/"/>
    <id>http://wangyuanjun.cn/2018/04/09/Caused-by-java-sql-SQLSyntaxErrorException-ORA-00932-数据类型不一致-应为-但却获得-CLOB/</id>
    <published>2018-04-09T09:50:07.000Z</published>
    <updated>2018-04-10T02:18:00.995Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div></pre></td><td class="code"><pre><div class="line">Internal Exception: java.sql.SQLSyntaxErrorException: ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</div><div class="line"></div><div class="line">Error Code: 932</div><div class="line">Call: SELECT * FROM (SELECT a.*, ROWNUM rnum  FROM (SELECT DISTINCT t0.PRICEINQUIRYID AS a1, t0.CLIENTCODE AS a2, t0.COSTPRICEQUO AS a3, t0.CREATETIME AS a4, t0.CREATEUSERID AS a5, t0.CREATEUSERNAME AS a6, t0.ENDTIME AS a7, t0.INQUIRYREQUIRE AS a8, t0.MODIFYTIME AS a9, t0.MODIFYUSERID AS a10, t0.MODIFYUSERNAME AS a11, t0.MROPRICEINQUIRYSTATE AS a12, t0.PRICEINQUIRYNO AS a13, t0.PRICEINQUIRYTITLE AS a14, t0.PRICEQUOTETEMPLATE AS a15, t0.PRICEQUOTETYPE AS a16, t0.PURCHASINGGROUPCODE AS a17, t0.PURCHASINGGROUPNAME AS a18, t0.PURCHASINGORGCODE AS a19, t0.PURCHASINGORGNAME AS a20, t0.STARTTIME AS a21 FROM d_xbj_mro_priceInquiry t0, d_xbj_mro_priceinquiryvendor t1 WHERE ((t1.MROPRICEINQUIRYVENDORSTATE = ?) AND (t1.priceInquiryId = t0.PRICEINQUIRYID)) ORDER BY t0.PRICEINQUIRYID DESC) a WHERE ROWNUM &lt;= ?) WHERE rnum &gt; ?</div><div class="line">	bind =&gt; [0, 20, 0]</div><div class="line">Query: ReadAllQuery(referenceClass=MroPriceInquiry sql=&quot;SELECT * FROM (SELECT a.*, ROWNUM rnum  FROM (SELECT DISTINCT t0.PRICEINQUIRYID AS a1, t0.CLIENTCODE AS a2, t0.COSTPRICEQUO AS a3, t0.CREATETIME AS a4, t0.CREATEUSERID AS a5, t0.CREATEUSERNAME AS a6, t0.ENDTIME AS a7, t0.INQUIRYREQUIRE AS a8, t0.MODIFYTIME AS a9, t0.MODIFYUSERID AS a10, t0.MODIFYUSERNAME AS a11, t0.MROPRICEINQUIRYSTATE AS a12, t0.PRICEINQUIRYNO AS a13, t0.PRICEINQUIRYTITLE AS a14, t0.PRICEQUOTETEMPLATE AS a15, t0.PRICEQUOTETYPE AS a16, t0.PURCHASINGGROUPCODE AS a17, t0.PURCHASINGGROUPNAME AS a18, t0.PURCHASINGORGCODE AS a19, t0.PURCHASINGORGNAME AS a20, t0.STARTTIME AS a21 FROM d_xbj_mro_priceInquiry t0, d_xbj_mro_priceinquiryvendor t1 WHERE ((t1.MROPRICEINQUIRYVENDORSTATE = ?) AND (t1.priceInquiryId = t0.PRICEINQUIRYID)) ORDER BY t0.PRICEINQUIRYID DESC) a WHERE ROWNUM &lt;= ?) WHERE rnum &gt; ?&quot;)</div><div class="line">[ERROR] DefaultDispatcherErrorHandler.error(CommonsLogger.java:42) - Exception occurred during processing request: EJB Exception: </div><div class="line">javax.ejb.EJBTransactionRolledbackException: EJB Exception: </div><div class="line">	at weblogic.ejb.container.internal.BaseLocalObject.handleSystemException(BaseLocalObject.java:452)</div><div class="line">	at weblogic.ejb.container.internal.BaseLocalObject.postInvoke1(BaseLocalObject.java:251)</div><div class="line">	at weblogic.ejb.container.internal.BaseLocalObject.__WL_postInvokeTxRetry(BaseLocalObject.java:204)</div><div class="line">	at weblogic.ejb.container.internal.SessionLocalMethodInvoker.invoke(SessionLocalMethodInvoker.java:46)</div><div class="line">	at com.huiju.srm.e.ss.mro.inquiryquotation.eao.MroPriceInquiryEaoBean_jugebu_MroPriceInquiryEaoLocalImpl.findAll(Unknown Source)</div><div class="line">	at com.huiju.module.data.logic.GenericLogicImpl.findAll(GenericLogicImpl.java:122)</div><div class="line">	at sun.reflect.GeneratedMethodAccessor2231.invoke(Unknown Source)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)</div><div class="line">	at com.oracle.pitchfork.intercept.MethodInvocationInvocationContext.proceed(MethodInvocationInvocationContext.java:100)</div><div class="line">	at com.oracle.pitchfork.intercept.JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:117)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.JdkDynamicAopProxy.invoke(Unknown Source)</div><div class="line">	at com.sun.proxy.$Proxy537.findAll(Unknown Source)</div><div class="line">	at com.huiju.srm.e.ss.mro.inquiryquotation.logic.MroPriceInquiryBean_ra0lj4_MroPriceInquiryRemoteImpl.__WL_invoke(Unknown Source)</div><div class="line">	at weblogic.ejb.container.internal.SessionRemoteMethodInvoker.invoke(SessionRemoteMethodInvoker.java:34)</div><div class="line">	at com.huiju.srm.e.ss.mro.inquiryquotation.logic.MroPriceInquiryBean_ra0lj4_MroPriceInquiryRemoteImpl.findAll(Unknown Source)</div><div class="line">	at com.huiju.srm.e.ss.mro.inquiryquotation.logic.MroPriceInquiryBean_ra0lj4_MroPriceInquiryRemoteImpl_CBV.findAll(Unknown Source)</div><div class="line">	at sun.reflect.GeneratedMethodAccessor2887.invoke(Unknown Source)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">	at weblogic.ejb.container.internal.RemoteBusinessIntfProxy.invoke(RemoteBusinessIntfProxy.java:84)</div><div class="line">	at com.sun.proxy.$Proxy342.findAll(Unknown Source)</div><div class="line">	at com.huiju.srm.e.ss.mro.inquiryquotation.action.MroPriceInquiryAction.getJson(MroPriceInquiryAction.java:140)</div><div class="line">	at sun.reflect.GeneratedMethodAccessor3818.invoke(Unknown Source)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">	at ognl.OgnlRuntime.invokeMethod(OgnlRuntime.java:897)</div><div class="line">	at ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:1299)</div><div class="line">	at ognl.ObjectMethodAccessor.callMethod(ObjectMethodAccessor.java:68)</div><div class="line">	at com.opensymphony.xwork2.ognl.accessor.XWorkMethodAccessor.callMethodWithDebugInfo(XWorkMethodAccessor.java:117)</div><div class="line">	at com.opensymphony.xwork2.ognl.accessor.XWorkMethodAccessor.callMethod(XWorkMethodAccessor.java:108)</div><div class="line">	at ognl.OgnlRuntime.callMethod(OgnlRuntime.java:1375)</div><div class="line">	at ognl.ASTMethod.getValueBody(ASTMethod.java:91)</div><div class="line">	at ognl.SimpleNode.evaluateGetValueBody(SimpleNode.java:212)</div><div class="line">	at ognl.SimpleNode.getValue(SimpleNode.java:258)</div><div class="line">	at ognl.Ognl.getValue(Ognl.java:470)</div><div class="line">	at ognl.Ognl.getValue(Ognl.java:434)</div><div class="line">	at com.opensymphony.xwork2.ognl.OgnlUtil$3.execute(OgnlUtil.java:362)</div><div class="line">	at com.opensymphony.xwork2.ognl.OgnlUtil.compileAndExecuteMethod(OgnlUtil.java:414)</div><div class="line">	at com.opensymphony.xwork2.ognl.OgnlUtil.callMethod(OgnlUtil.java:360)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invokeAction(DefaultActionInvocation.java:430)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invokeActionOnly(DefaultActionInvocation.java:290)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:251)</div><div class="line">	at com.huiju.srm.license.interceptor.LicenseInterceptor$1.proceed(LicenseInterceptor.java:85)</div><div class="line">	at com.huiju.module.license.interceptor.AbstractLicenseInterceptor.interceptor(AbstractLicenseInterceptor.java:48)</div><div class="line">	at com.huiju.srm.license.interceptor.LicenseInterceptor.intercept(LicenseInterceptor.java:45)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.huiju.module.web.interceptor.InvocationContextAdapter.proceed(InvocationContextAdapter.java:75)</div><div class="line">	at com.huiju.module.plugin.log.interceptor.AbstractLoggingInterceptor.aroundLogging(AbstractLoggingInterceptor.java:112)</div><div class="line">	at com.huiju.module.web.interceptor.LoggingInterceptor.intercept(LoggingInterceptor.java:45)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.DefaultWorkflowInterceptor.doIntercept(DefaultWorkflowInterceptor.java:168)</div><div class="line">	at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.validator.ValidationInterceptor.doIntercept(ValidationInterceptor.java:265)</div><div class="line">	at org.apache.struts2.interceptor.validation.AnnotationValidationInterceptor.doIntercept(AnnotationValidationInterceptor.java:76)</div><div class="line">	at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.ConversionErrorInterceptor.intercept(ConversionErrorInterceptor.java:138)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:229)</div><div class="line">	at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:229)</div><div class="line">	at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.StaticParametersInterceptor.intercept(StaticParametersInterceptor.java:191)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at org.apache.struts2.interceptor.FileUploadInterceptor.intercept(FileUploadInterceptor.java:253)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor.intercept(ModelDrivenInterceptor.java:100)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.ChainingInterceptor.intercept(ChainingInterceptor.java:145)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.PrepareInterceptor.doIntercept(PrepareInterceptor.java:171)</div><div class="line">	at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at org.apache.struts2.interceptor.ServletConfigInterceptor.intercept(ServletConfigInterceptor.java:164)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.ParametersInterceptor.doIntercept(ParametersInterceptor.java:229)</div><div class="line">	at com.opensymphony.xwork2.interceptor.MethodFilterInterceptor.intercept(MethodFilterInterceptor.java:98)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at org.apache.struts2.interceptor.MultiselectInterceptor.intercept(MultiselectInterceptor.java:73)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at org.apache.struts2.interceptor.DateTextFieldInterceptor.intercept(DateTextFieldInterceptor.java:125)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at org.apache.struts2.interceptor.CheckboxInterceptor.intercept(CheckboxInterceptor.java:91)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.I18nInterceptor.intercept(I18nInterceptor.java:140)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.AliasInterceptor.intercept(AliasInterceptor.java:193)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor.intercept(ExceptionMappingInterceptor.java:189)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at org.apache.struts2.interceptor.MessageStoreInterceptor.intercept(MessageStoreInterceptor.java:206)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at com.huiju.module.web.interceptor.AuthorizationInterceptor.intercept(AuthorizationInterceptor.java:111)</div><div class="line">	at com.opensymphony.xwork2.DefaultActionInvocation.invoke(DefaultActionInvocation.java:245)</div><div class="line">	at org.apache.struts2.impl.StrutsActionProxy.execute(StrutsActionProxy.java:54)</div><div class="line">	at org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:575)</div><div class="line">	at org.apache.struts2.dispatcher.ng.ExecuteOperations.executeAction(ExecuteOperations.java:81)</div><div class="line">	at org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter.doFilter(StrutsPrepareAndExecuteFilter.java:99)</div><div class="line">	at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:79)</div><div class="line">	at com.huiju.module.context.CurrentContextFilter.doFilter(CurrentContextFilter.java:49)</div><div class="line">	at com.huiju.module.web.filter.WebCurrentContextFilter.doFilter(WebCurrentContextFilter.java:61)</div><div class="line">	at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:79)</div><div class="line">	at com.huiju.module.web.filter.HttpContextWrapperFilter.doFilter(HttpContextWrapperFilter.java:37)</div><div class="line">	at weblogic.servlet.internal.FilterChainImpl.doFilter(FilterChainImpl.java:79)</div><div class="line">	at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.wrapRun(WebAppServletContext.java:3436)</div><div class="line">	at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.__run(WebAppServletContext.java:3402)</div><div class="line">	at weblogic.servlet.internal.WebAppServletContext$ServletInvocationAction.run(WebAppServletContext.java)</div><div class="line">	at weblogic.security.acl.internal.AuthenticatedSubject.doAs(AuthenticatedSubject.java:321)</div><div class="line">	at weblogic.security.service.SecurityManager.runAs(SecurityManager.java:120)</div><div class="line">	at weblogic.servlet.provider.WlsSubjectHandle.run(WlsSubjectHandle.java:57)</div><div class="line">	at weblogic.servlet.internal.WebAppServletContext.doSecuredExecute(WebAppServletContext.java:2285)</div><div class="line">	at weblogic.servlet.internal.WebAppServletContext.securedExecute(WebAppServletContext.java:2201)</div><div class="line">	at weblogic.servlet.internal.WebAppServletContext.execute(WebAppServletContext.java:2179)</div><div class="line">	at weblogic.servlet.internal.ServletRequestImpl.run(ServletRequestImpl.java:1572)</div><div class="line">	at weblogic.servlet.provider.ContainerSupportProviderImpl$WlsRequestExecutor.run(ContainerSupportProviderImpl.java:255)</div><div class="line">	at weblogic.work.ExecuteThread.execute(ExecuteThread.java:311)</div><div class="line">	at weblogic.work.ExecuteThread.run(ExecuteThread.java:263)</div><div class="line">Caused by: javax.persistence.PersistenceException: Exception [EclipseLink-4002] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.DatabaseException</div><div class="line">Internal Exception: java.sql.SQLSyntaxErrorException: ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</div><div class="line"></div><div class="line">Error Code: 932</div><div class="line">Call: SELECT * FROM (SELECT a.*, ROWNUM rnum  FROM (SELECT DISTINCT t0.PRICEINQUIRYID AS a1, t0.CLIENTCODE AS a2, t0.COSTPRICEQUO AS a3, t0.CREATETIME AS a4, t0.CREATEUSERID AS a5, t0.CREATEUSERNAME AS a6, t0.ENDTIME AS a7, t0.INQUIRYREQUIRE AS a8, t0.MODIFYTIME AS a9, t0.MODIFYUSERID AS a10, t0.MODIFYUSERNAME AS a11, t0.MROPRICEINQUIRYSTATE AS a12, t0.PRICEINQUIRYNO AS a13, t0.PRICEINQUIRYTITLE AS a14, t0.PRICEQUOTETEMPLATE AS a15, t0.PRICEQUOTETYPE AS a16, t0.PURCHASINGGROUPCODE AS a17, t0.PURCHASINGGROUPNAME AS a18, t0.PURCHASINGORGCODE AS a19, t0.PURCHASINGORGNAME AS a20, t0.STARTTIME AS a21 FROM d_xbj_mro_priceInquiry t0, d_xbj_mro_priceinquiryvendor t1 WHERE ((t1.MROPRICEINQUIRYVENDORSTATE = ?) AND (t1.priceInquiryId = t0.PRICEINQUIRYID)) ORDER BY t0.PRICEINQUIRYID DESC) a WHERE ROWNUM &lt;= ?) WHERE rnum &gt; ?</div><div class="line">	bind =&gt; [0, 20, 0]</div><div class="line">Query: ReadAllQuery(referenceClass=MroPriceInquiry sql=&quot;SELECT * FROM (SELECT a.*, ROWNUM rnum  FROM (SELECT DISTINCT t0.PRICEINQUIRYID AS a1, t0.CLIENTCODE AS a2, t0.COSTPRICEQUO AS a3, t0.CREATETIME AS a4, t0.CREATEUSERID AS a5, t0.CREATEUSERNAME AS a6, t0.ENDTIME AS a7, t0.INQUIRYREQUIRE AS a8, t0.MODIFYTIME AS a9, t0.MODIFYUSERID AS a10, t0.MODIFYUSERNAME AS a11, t0.MROPRICEINQUIRYSTATE AS a12, t0.PRICEINQUIRYNO AS a13, t0.PRICEINQUIRYTITLE AS a14, t0.PRICEQUOTETEMPLATE AS a15, t0.PRICEQUOTETYPE AS a16, t0.PURCHASINGGROUPCODE AS a17, t0.PURCHASINGGROUPNAME AS a18, t0.PURCHASINGORGCODE AS a19, t0.PURCHASINGORGNAME AS a20, t0.STARTTIME AS a21 FROM d_xbj_mro_priceInquiry t0, d_xbj_mro_priceinquiryvendor t1 WHERE ((t1.MROPRICEINQUIRYVENDORSTATE = ?) AND (t1.priceInquiryId = t0.PRICEINQUIRYID)) ORDER BY t0.PRICEINQUIRYID DESC) a WHERE ROWNUM &lt;= ?) WHERE rnum &gt; ?&quot;)</div><div class="line">	at org.eclipse.persistence.internal.jpa.QueryImpl.getDetailedException(QueryImpl.java:378)</div><div class="line">	at org.eclipse.persistence.internal.jpa.QueryImpl.executeReadQuery(QueryImpl.java:260)</div><div class="line">	at org.eclipse.persistence.internal.jpa.QueryImpl.getResultList(QueryImpl.java:469)</div><div class="line">	at com.huiju.module.data.eao.GenericEaoImpl.findAll(GenericEaoImpl.java:232)</div><div class="line">	at sun.reflect.GeneratedMethodAccessor2260.invoke(Unknown Source)</div><div class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:310)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:182)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:149)</div><div class="line">	at com.oracle.pitchfork.intercept.MethodInvocationInvocationContext.proceed(MethodInvocationInvocationContext.java:100)</div><div class="line">	at com.oracle.pitchfork.intercept.JeeInterceptorInterceptor.invoke(JeeInterceptorInterceptor.java:117)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.support.DelegatingIntroductionInterceptor.doProceed(DelegatingIntroductionInterceptor.java:131)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.support.DelegatingIntroductionInterceptor.invoke(DelegatingIntroductionInterceptor.java:119)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:171)</div><div class="line">	at com.bea.core.repackaged.springframework.aop.framework.JdkDynamicAopProxy.invoke(Unknown Source)</div><div class="line">	at com.sun.proxy.$Proxy540.findAll(Unknown Source)</div><div class="line">	at com.huiju.srm.e.ss.mro.inquiryquotation.eao.MroPriceInquiryEaoBean_jugebu_MroPriceInquiryEaoLocalImpl.__WL_invoke(Unknown Source)</div><div class="line">	at weblogic.ejb.container.internal.SessionLocalMethodInvoker.invoke(SessionLocalMethodInvoker.java:33)</div><div class="line">	... 121 more</div><div class="line">Caused by: Exception [EclipseLink-4002] (Eclipse Persistence Services - 2.5.2.v20140319-9ad6abd): org.eclipse.persistence.exceptions.DatabaseException</div><div class="line">Internal Exception: java.sql.SQLSyntaxErrorException: ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</div><div class="line"></div><div class="line">Error Code: 932</div><div class="line">Call: SELECT * FROM (SELECT a.*, ROWNUM rnum  FROM (SELECT DISTINCT t0.PRICEINQUIRYID AS a1, t0.CLIENTCODE AS a2, t0.COSTPRICEQUO AS a3, t0.CREATETIME AS a4, t0.CREATEUSERID AS a5, t0.CREATEUSERNAME AS a6, t0.ENDTIME AS a7, t0.INQUIRYREQUIRE AS a8, t0.MODIFYTIME AS a9, t0.MODIFYUSERID AS a10, t0.MODIFYUSERNAME AS a11, t0.MROPRICEINQUIRYSTATE AS a12, t0.PRICEINQUIRYNO AS a13, t0.PRICEINQUIRYTITLE AS a14, t0.PRICEQUOTETEMPLATE AS a15, t0.PRICEQUOTETYPE AS a16, t0.PURCHASINGGROUPCODE AS a17, t0.PURCHASINGGROUPNAME AS a18, t0.PURCHASINGORGCODE AS a19, t0.PURCHASINGORGNAME AS a20, t0.STARTTIME AS a21 FROM d_xbj_mro_priceInquiry t0, d_xbj_mro_priceinquiryvendor t1 WHERE ((t1.MROPRICEINQUIRYVENDORSTATE = ?) AND (t1.priceInquiryId = t0.PRICEINQUIRYID)) ORDER BY t0.PRICEINQUIRYID DESC) a WHERE ROWNUM &lt;= ?) WHERE rnum &gt; ?</div><div class="line">	bind =&gt; [0, 20, 0]</div><div class="line">Query: ReadAllQuery(referenceClass=MroPriceInquiry sql=&quot;SELECT * FROM (SELECT a.*, ROWNUM rnum  FROM (SELECT DISTINCT t0.PRICEINQUIRYID AS a1, t0.CLIENTCODE AS a2, t0.COSTPRICEQUO AS a3, t0.CREATETIME AS a4, t0.CREATEUSERID AS a5, t0.CREATEUSERNAME AS a6, t0.ENDTIME AS a7, t0.INQUIRYREQUIRE AS a8, t0.MODIFYTIME AS a9, t0.MODIFYUSERID AS a10, t0.MODIFYUSERNAME AS a11, t0.MROPRICEINQUIRYSTATE AS a12, t0.PRICEINQUIRYNO AS a13, t0.PRICEINQUIRYTITLE AS a14, t0.PRICEQUOTETEMPLATE AS a15, t0.PRICEQUOTETYPE AS a16, t0.PURCHASINGGROUPCODE AS a17, t0.PURCHASINGGROUPNAME AS a18, t0.PURCHASINGORGCODE AS a19, t0.PURCHASINGORGNAME AS a20, t0.STARTTIME AS a21 FROM d_xbj_mro_priceInquiry t0, d_xbj_mro_priceinquiryvendor t1 WHERE ((t1.MROPRICEINQUIRYVENDORSTATE = ?) AND (t1.priceInquiryId = t0.PRICEINQUIRYID)) ORDER BY t0.PRICEINQUIRYID DESC) a WHERE ROWNUM &lt;= ?) WHERE rnum &gt; ?&quot;)</div><div class="line">	at org.eclipse.persistence.exceptions.DatabaseException.sqlException(DatabaseException.java:340)</div><div class="line">	at org.eclipse.persistence.internal.databaseaccess.DatabaseAccessor.basicExecuteCall(DatabaseAccessor.java:682)</div><div class="line">	at org.eclipse.persistence.internal.databaseaccess.DatabaseAccessor.executeCall(DatabaseAccessor.java:558)</div><div class="line">	at org.eclipse.persistence.internal.sessions.AbstractSession.basicExecuteCall(AbstractSession.java:2002)</div><div class="line">	at org.eclipse.persistence.sessions.server.ServerSession.executeCall(ServerSession.java:570)</div><div class="line">	at org.eclipse.persistence.sessions.server.ClientSession.executeCall(ClientSession.java:250)</div><div class="line">	at org.eclipse.persistence.internal.queries.DatasourceCallQueryMechanism.executeCall(DatasourceCallQueryMechanism.java:242)</div><div class="line">	at org.eclipse.persistence.internal.queries.DatasourceCallQueryMechanism.executeCall(DatasourceCallQueryMechanism.java:228)</div><div class="line">	at org.eclipse.persistence.internal.queries.DatasourceCallQueryMechanism.executeSelectCall(DatasourceCallQueryMechanism.java:299)</div><div class="line">	at org.eclipse.persistence.internal.queries.DatasourceCallQueryMechanism.selectAllRows(DatasourceCallQueryMechanism.java:694)</div><div class="line">	at org.eclipse.persistence.internal.queries.ExpressionQueryMechanism.selectAllRowsFromTable(ExpressionQueryMechanism.java:2738)</div><div class="line">	at org.eclipse.persistence.internal.queries.ExpressionQueryMechanism.selectAllRows(ExpressionQueryMechanism.java:2691)</div><div class="line">	at org.eclipse.persistence.queries.ReadAllQuery.executeObjectLevelReadQuery(ReadAllQuery.java:495)</div><div class="line">	at org.eclipse.persistence.queries.ObjectLevelReadQuery.executeDatabaseQuery(ObjectLevelReadQuery.java:1168)</div><div class="line">	at org.eclipse.persistence.queries.DatabaseQuery.execute(DatabaseQuery.java:899)</div><div class="line">	at org.eclipse.persistence.queries.ObjectLevelReadQuery.execute(ObjectLevelReadQuery.java:1127)</div><div class="line">	at org.eclipse.persistence.queries.ReadAllQuery.execute(ReadAllQuery.java:403)</div><div class="line">	at org.eclipse.persistence.queries.ObjectLevelReadQuery.executeInUnitOfWork(ObjectLevelReadQuery.java:1215)</div><div class="line">	at org.eclipse.persistence.internal.sessions.UnitOfWorkImpl.internalExecuteQuery(UnitOfWorkImpl.java:2896)</div><div class="line">	at org.eclipse.persistence.internal.sessions.AbstractSession.executeQuery(AbstractSession.java:1804)</div><div class="line">	at org.eclipse.persistence.internal.sessions.AbstractSession.executeQuery(AbstractSession.java:1786)</div><div class="line">	at org.eclipse.persistence.internal.sessions.AbstractSession.executeQuery(AbstractSession.java:1751)</div><div class="line">	at org.eclipse.persistence.internal.jpa.QueryImpl.executeReadQuery(QueryImpl.java:258)</div><div class="line">	... 138 more</div><div class="line">Caused by: java.sql.SQLSyntaxErrorException: ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</div><div class="line"></div><div class="line">	at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:450)</div><div class="line">	at oracle.jdbc.driver.T4CTTIoer.processError(T4CTTIoer.java:399)</div><div class="line">	at oracle.jdbc.driver.T4C8Oall.processError(T4C8Oall.java:1059)</div><div class="line">	at oracle.jdbc.driver.T4CTTIfun.receive(T4CTTIfun.java:522)</div><div class="line">	at oracle.jdbc.driver.T4CTTIfun.doRPC(T4CTTIfun.java:257)</div><div class="line">	at oracle.jdbc.driver.T4C8Oall.doOALL(T4C8Oall.java:587)</div><div class="line">	at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:225)</div><div class="line">	at oracle.jdbc.driver.T4CPreparedStatement.doOall8(T4CPreparedStatement.java:53)</div><div class="line">	at oracle.jdbc.driver.T4CPreparedStatement.executeForDescribe(T4CPreparedStatement.java:774)</div><div class="line">	at oracle.jdbc.driver.OracleStatement.executeMaybeDescribe(OracleStatement.java:925)</div><div class="line">	at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1111)</div><div class="line">	at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:4798)</div><div class="line">	at oracle.jdbc.driver.OraclePreparedStatement.executeQuery(OraclePreparedStatement.java:4845)</div><div class="line">	at oracle.jdbc.driver.OraclePreparedStatementWrapper.executeQuery(OraclePreparedStatementWrapper.java:1501)</div><div class="line">	at weblogic.jdbc.wrapper.PreparedStatement.executeQuery(PreparedStatement.java:141)</div><div class="line">	at org.eclipse.persistence.internal.databaseaccess.DatabaseAccessor.executeSelect(DatabaseAccessor.java:1007)</div><div class="line">	at org.eclipse.persistence.internal.databaseaccess.DatabaseAccessor.basicExecuteCall(DatabaseAccessor.java:642)</div><div class="line">	... 159 more</div></pre></td></tr></table></figure>
<p>总是报：ORA-00932: 数据类型不一致: 应为 -, 但却获得 CLOB</p>
<p><img src="/2018/04/09/Caused-by-java-sql-SQLSyntaxErrorException-ORA-00932-数据类型不一致-应为-但却获得-CLOB/实体.png" alt="实体"><br><img src="/2018/04/09/Caused-by-java-sql-SQLSyntaxErrorException-ORA-00932-数据类型不一致-应为-但却获得-CLOB/数据库字段.png" alt="数据库字段"></p>
<p>是由于这个t0.INQUIRYREQUIRE字段clob字段。</p>
<p>第一种解决方法： t0.INQUIRYREQUIRE 改成 to_char(t0.INQUIRYREQUIRE)。</p>
<p>第二种解决方法：去掉distinct 去重。</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK1.8源码解析——HashMap(二)</title>
    <link href="http://wangyuanjun.cn/2018/02/27/JDK1-8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94HashMap-%E4%BA%8C/"/>
    <id>http://wangyuanjun.cn/2018/02/27/JDK1-8源码解析——HashMap-二/</id>
    <published>2018-02-27T07:53:36.000Z</published>
    <updated>2018-02-27T08:26:29.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：摘要"><a href="#一：摘要" class="headerlink" title="一：摘要"></a>一：摘要</h1><p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。</p>
<h1 id="二：简介"><a href="#二：简介" class="headerlink" title="二：简介"></a>二：简介</h1><p>Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图所示：</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/java.util.map类图.png" alt="java.util.map类图"></p>
<p>下面针对各个实现类的特点做一些说明：</p>
<p>(1) HashMap：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。</p>
<p>(2) Hashtable：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。</p>
<p>(3) LinkedHashMap：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p>
<p>(4) TreeMap：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p>
<p>对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h1 id="三：内部实现"><a href="#三：内部实现" class="headerlink" title="三：内部实现"></a>三：内部实现</h1><p>搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。</p>
<h2 id="3-1-存储结构-字段"><a href="#3-1-存储结构-字段" class="headerlink" title="3.1 存储结构-字段"></a>3.1 存储结构-字段</h2><p>从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/hashMap内存结构图.png" alt="hashMap内存结构图"></p>
<p>这里需要讲明白两个问题：数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>
<p>(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;    //用来定位数组索引位置</div><div class="line">        final K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;   //链表的下一个node</div><div class="line"></div><div class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class="line">        public final K getKey()&#123; ... &#125;</div><div class="line">        public final V getValue() &#123; ... &#125;</div><div class="line">        public final String toString() &#123; ... &#125;</div><div class="line">        public final int hashCode() &#123; ... &#125;</div><div class="line">        public final V setValue(V newValue) &#123; ... &#125;</div><div class="line">        public final boolean equals(Object o) &#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。例如程序执行下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.put(&quot;美团&quot;,&quot;小美&quot;);</div></pre></td></tr></table></figure>
<p>系统将调用”美团”这个key的hashCode()方法得到其hashCode 值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int threshold;             // 所能容纳的key-value对极限 </div><div class="line">final float loadFactor;    // 负载因子</div><div class="line">int modCount;  </div><div class="line">int size;</div></pre></td></tr></table></figure>
<p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。" target="_blank" rel="external">http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</a></p>
<p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630。" target="_blank" rel="external">http://blog.csdn.net/v_july_v/article/details/6105630。</a></p>
<h2 id="3-2-功能实现-方法"><a href="#3-2-功能实现-方法" class="headerlink" title="3.2 功能实现-方法"></a>3.2 功能实现-方法</h2><p>HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p>
<h3 id="3-2-1-确定哈希桶数组索引位置"><a href="#3-2-1-确定哈希桶数组索引位置" class="headerlink" title="3.2.1 确定哈希桶数组索引位置"></a>3.2.1 确定哈希桶数组索引位置</h3><p>不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">方法一：</div><div class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</div><div class="line">     int h;</div><div class="line">     // h = key.hashCode() 为第一步 取hashCode值</div><div class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</div><div class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line">方法二：</div><div class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</div><div class="line">     return h &amp; (length-1);  //第三步 取模运算</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/hashMap哈希算法例图.png" alt="hashMap哈希算法例图"></p>
<h3 id="3-2-2-分析HashMap的put方法"><a href="#3-2-2-分析HashMap的put方法" class="headerlink" title="3.2.2 分析HashMap的put方法"></a>3.2.2 分析HashMap的put方法</h3><p>HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/hashMap put方法执行流程图.png" alt="hashMap put方法执行流程图"></p>
<p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p>
<p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p>
<p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p>
<p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</p>
<p>JDK1.8HashMap的put方法源码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">   public V put(K key, V value) &#123;</div><div class="line">      // 对key的hashCode()做hash</div><div class="line">      return putVal(hash(key), key, value, false, true);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div class="line">                 boolean evict) &#123;</div><div class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">      // 步骤①：tab为空则创建</div><div class="line">     if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">         n = (tab = resize()).length;</div><div class="line">     // 步骤②：计算index，并对null做处理 </div><div class="line">     if ((p = tab[i = (n - 1) &amp; hash]) == null) </div><div class="line">         tab[i] = newNode(hash, key, value, null);</div><div class="line">     else &#123;</div><div class="line">         Node&lt;K,V&gt; e; K k;</div><div class="line">         // 步骤③：节点key存在，直接覆盖value</div><div class="line">         if (p.hash == hash &amp;&amp;</div><div class="line">             ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">             e = p;</div><div class="line">         // 步骤④：判断该链为红黑树</div><div class="line">         else if (p instanceof TreeNode)</div><div class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">         // 步骤⑤：该链为链表</div><div class="line">         else &#123;</div><div class="line">             for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                 if ((e = p.next) == null) &#123;</div><div class="line">                     p.next = newNode(hash, key,value,null);</div><div class="line">                        //链表长度大于8转换为红黑树进行处理</div><div class="line">                     if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  </div><div class="line">                         treeifyBin(tab, hash);</div><div class="line">                     break;</div><div class="line">                 &#125;</div><div class="line">                    // key已经存在直接覆盖value</div><div class="line">                 if (e.hash == hash &amp;&amp;</div><div class="line">                     ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) </div><div class="line">                            break;</div><div class="line">                 p = e;</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         </div><div class="line">         if (e != null) &#123; // existing mapping for key</div><div class="line">             V oldValue = e.value;</div><div class="line">             if (!onlyIfAbsent || oldValue == null)</div><div class="line">                 e.value = value;</div><div class="line">             afterNodeAccess(e);</div><div class="line">             return oldValue;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line">     ++modCount;</div><div class="line">     // 步骤⑥：超过最大容量 就扩容</div><div class="line">     if (++size &gt; threshold)</div><div class="line">         resize();</div><div class="line">     afterNodeInsertion(evict);</div><div class="line">     return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-3-扩容机制"><a href="#3-2-3-扩容机制" class="headerlink" title="3.2.3 扩容机制"></a>3.2.3 扩容机制</h3><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//用新的容量来给table扩容  </div><div class="line">void resize(int newCapacity) &#123;  </div><div class="line">    Entry[] oldTable = table; //引用扩容前的Entry数组 </div><div class="line">    int oldCapacity = oldTable.length; //保存old capacity  </div><div class="line">    // 如果旧的容量已经是系统默认最大容量了(扩容前的数组大小如果已经达到最大(2^30)了 )，那么将阈值设置成整形的最大值，退出 ,  </div><div class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;  </div><div class="line">        threshold = Integer.MAX_VALUE;  </div><div class="line">        return;  </div><div class="line">    &#125;  </div><div class="line">    //初始化一个新的Entry数组  </div><div class="line">    Entry[] newTable = new Entry[newCapacity];  </div><div class="line">    //将数据转移到新的Entry数组里 </div><div class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));  </div><div class="line">    //HashMap的table属性引用新的Entry数组</div><div class="line">    table = newTable;  </div><div class="line">    //设置阈值  </div><div class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void transfer(Entry[] newTable) &#123;</div><div class="line">    Entry[] src = table;                   //src引用了旧的Entry数组</div><div class="line">    int newCapacity = newTable.length;</div><div class="line">    for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组</div><div class="line">        Entry&lt;K,V&gt; e = src[j];             //取得旧Entry数组的每个元素</div><div class="line">        if (e != null) &#123;</div><div class="line">            src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</div><div class="line">            do &#123;</div><div class="line">                Entry&lt;K,V&gt; next = e.next;</div><div class="line">                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置</div><div class="line">                e.next = newTable[i]; //标记[1]</div><div class="line">                newTable[i] = e;      //将元素放在数组上</div><div class="line">                e = next;             //访问下一个Entry链上的元素</div><div class="line">            &#125; while (e != null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/jdk1.7扩容例图.png" alt="jdk1.7扩容例图"></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/hashMap 1.8 哈希算法例图1.png" alt="hashMap 1.8 哈希算法例图1"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/hashMap 1.8 哈希算法例图2.png" alt="hashMap 1.8 哈希算法例图2"></p>
<p>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/jdk1.8 hashMap扩容例图.png" alt="jdk1.8 hashMap扩容例图"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<p>代码中主要点在于判断高位新增的是1还是0，if ((e.hash &amp; oldCap) == 0) 就在原位置，否则在原索引+oldCap的位置。这个if即判断了新增的位是1还是0，一般我们用hash定址，都是hash &amp; length - 1，而这里是直接hash &amp; length，这样的做法是让低位全部为0，这样就可以判断高位是1还是0了！</p>
<p>例如：</p>
<p>0000 0101 &amp; 0000 1111（15），解为5，而0000 0101 &amp; 0001 0000（16），解为0。</p>
<p>因此，假如现在在原table索引位置为5的地方有两个节点，分别为5和21，那么当16扩容成为32时，他们在新数组的位置是这样的：</p>
<p>0000 0101 &amp; 0001 0000 = <font color="red">0</font> 所以5在新数组的位置：<font color="red">原索引位置5</font></p>
<p>0001 0101 &amp; 0001 0000 = <font color="red">1</font> 所以21在新数组的位置：<font color="red">索引位置 + 16</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    if (oldCap &gt; 0) &#123;</div><div class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125;</div><div class="line">        // 没超过最大值，就扩充为原来的2倍</div><div class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">    &#125;</div><div class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</div><div class="line">        newCap = oldThr;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    // 计算新的resize上限</div><div class="line">    if (newThr == 0) &#123;</div><div class="line"></div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;，&quot;unchecked&quot;&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        // 把每个bucket都移动到新的buckets中</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                else if (e instanceof TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                else &#123; // 链表优化重hash的代码块</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        // 原索引</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        // 原索引+oldCap</div><div class="line">                        else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    // 原索引放到bucket里</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    // 原索引+oldCap放到bucket里</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="四：线程安全性"><a href="#四：线程安全性" class="headerlink" title="四：线程安全性"></a>四：线程安全性</h1><p>在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class HashMapInfiniteLoop &#123;  </div><div class="line"></div><div class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2，0.75f);  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        map.put(5， &quot;C&quot;);  </div><div class="line"></div><div class="line">        new Thread(&quot;Thread1&quot;) &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(7, &quot;B&quot;);  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();  </div><div class="line">        new Thread(&quot;Thread2&quot;) &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(3, &quot;A);  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/jdk1.7 hashMap死循环例图1.png" alt="jdk1.7 hashMap死循环例图1"><br>注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。<br><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/jdk1.7 hashMap死循环例图2.png" alt="jdk1.7 hashMap死循环例图2"></p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/jdk1.7 hashMap死循环例图3.png" alt="jdk1.7 hashMap死循环例图3"><br>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/jdk1.7 hashMap死循环例图4.png" alt="jdk1.7 hashMap死循环例图4"><br>于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。</p>
<h1 id="五：JDK1-8与JDK1-7的性能对比"><a href="#五：JDK1-8与JDK1-7的性能对比" class="headerlink" title="五：JDK1.8与JDK1.7的性能对比"></a>五：JDK1.8与JDK1.7的性能对比</h1><p>HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7，下面我们从两个方面用例子证明这一点。</p>
<h2 id="5-1-Hash较均匀的情况"><a href="#5-1-Hash较均匀的情况" class="headerlink" title="5.1 Hash较均匀的情况"></a>5.1 Hash较均匀的情况</h2><p>为了便于测试，我们先写一个类Key，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"></div><div class="line">    private final int value;</div><div class="line"></div><div class="line">    Key(int value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int compareTo(Key o) &#123;</div><div class="line">        return Integer.compare(this.value, o.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean equals(Object o) &#123;</div><div class="line">        if (this == o) return true;</div><div class="line">        if (o == null || getClass() != o.getClass())</div><div class="line">            return false;</div><div class="line">        Key key = (Key) o;</div><div class="line">        return value == key.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类复写了equals方法，并且提供了相当好的hashCode函数，任何一个值的hashCode都不会相同，因为直接使用value当做hashcode。为了避免频繁的GC，我将不变的Key实例缓存了起来，而不是一遍一遍的创建它们。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class Keys &#123;</div><div class="line"></div><div class="line">    public static final int MAX_KEY = 10_000_000;</div><div class="line">    private static final Key[] KEYS_CACHE = new Key[MAX_KEY];</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        for (int i = 0; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = new Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Key of(int value) &#123;</div><div class="line">        return KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在开始我们的试验，测试需要做的仅仅是，创建不同size的HashMap（1、10、100、……10000000），屏蔽了扩容的情况，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">static void test(int mapSize) &#123;</div><div class="line"></div><div class="line">     HashMap&lt;Key, Integer&gt; map = new HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">     for (int i = 0; i &lt; mapSize; ++i) &#123;</div><div class="line">         map.put(Keys.of(i), i);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     long beginTime = System.nanoTime(); //获取纳秒</div><div class="line">     for (int i = 0; i &lt; mapSize; i++) &#123;</div><div class="line">         map.get(Keys.of(i));</div><div class="line">     &#125;</div><div class="line">     long endTime = System.nanoTime();</div><div class="line">     System.out.println(endTime - beginTime);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> public static void main(String[] args) &#123;</div><div class="line">     for(int i=10;i&lt;= 1000 0000;i*= 10)&#123;</div><div class="line">         test(i);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>在测试中会查找不同的值，然后度量花费的时间，为了计算getKey的平均时间，我们遍历所有的get方法，计算总的时间，除以key的数量，计算一个平均值，主要用来比较，绝对值可能会受很多环境因素的影响。结果如下：</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/性能比较表1.png" alt="性能比较表1"></p>
<p>通过观测测试结果可知，JDK1.8的性能要高于JDK1.7 15%以上，在某些size的区域上，甚至高于100%。由于Hash算法较均匀，JDK1.8引入的红黑树效果不明显，下面我们看看Hash不均匀的的情况。</p>
<h2 id="5-2-Hash极不均匀的情况"><a href="#5-2-Hash极不均匀的情况" class="headerlink" title="5.2 Hash极不均匀的情况"></a>5.2 Hash极不均匀的情况</h2><p>假设我们又一个非常差的Key，它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Key implements Comparable&lt;Key&gt; &#123;</div><div class="line"></div><div class="line">    //...</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public int hashCode() &#123;</div><div class="line">        return 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仍然执行main方法，得出的结果如下表所示：</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap-二/性能比较表2.png" alt="性能比较表2"></p>
<p>从表中结果中可知，随着size的变大，JDK1.7的花费时间是增长的趋势，而JDK1.8是明显的降低趋势，并且呈现对数增长稳定。当一个链表太长的时候，HashMap会动态的将它替换成一个红黑树，这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同，这两种情况的相对比较，可以说明一个好的hash算法的重要性。</p>
<pre><code>测试环境：处理器为2.2 GHz Intel Core i7，内存为16 GB 1600 MHz DDR3，SSD硬盘，使用默认的JVM参数，运行在64位的OS X 10.10.1上。
</code></pre><h1 id="六：小结"><a href="#六：小结" class="headerlink" title="六：小结"></a>六：小结</h1><p>(1) 扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
<p>(2) 负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
<p>(3) HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</p>
<p>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。</p>
<p>(5) 还没升级JDK1.8的，现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>
<h1 id="七：参考"><a href="#七：参考" class="headerlink" title="七：参考"></a>七：参考</h1><p>JDK1.7&amp;JDK1.8 源码。<br>CSDN博客频道，HashMap多线程死循环问题，2014。<br>红黑联盟，Java类集框架之HashMap(JDK1.8)源码剖析，2015。<br>CSDN博客频道， 教你初步了解红黑树，2010。<br>Java Code Geeks，HashMap performance improvements in Java 8，2014。<br>Importnew，危险！在HashMap中将可变对象用作Key，2014。<br>CSDN博客频道，为什么一般hashtable的桶数会取一个素数，2013。<br>转自：<a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">http://tech.meituan.com/java-hashmap.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：摘要&quot;&gt;&lt;a href=&quot;#一：摘要&quot; class=&quot;headerlink&quot; title=&quot;一：摘要&quot;&gt;&lt;/a&gt;一：摘要&lt;/h1&gt;&lt;p&gt;HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet K
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK1.8源码解析——HashMap(一)</title>
    <link href="http://wangyuanjun.cn/2018/02/27/JDK1-8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94HashMap/"/>
    <id>http://wangyuanjun.cn/2018/02/27/JDK1-8源码解析——HashMap/</id>
    <published>2018-02-27T02:51:29.000Z</published>
    <updated>2018-03-01T01:44:14.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：HashMap概述"><a href="#一：HashMap概述" class="headerlink" title="一：HashMap概述"></a>一：HashMap概述</h1><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<h1 id="二：HashMap的数据结构"><a href="#二：HashMap的数据结构" class="headerlink" title="二：HashMap的数据结构"></a>二：HashMap的数据结构</h1><p>在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结构，但是在jdk1.8里 加入了红黑树的实现，当链表的长度大于8时，转换为红黑树的结构。<br><img src="/2018/02/27/JDK1-8源码解析——HashMap/1.jpg" alt="1"><br>从上图中可以看出，java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final int hash;//用于定位数组索引的位置</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Node&lt;K,V&gt; next;//链表的下一个Node</div><div class="line"></div><div class="line">    Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</div><div class="line">        this.hash = hash;</div><div class="line">        this.key = key;</div><div class="line">        this.value = value;</div><div class="line">        this.next = next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p>
<p>有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。</p>
<p>HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。</p>
<p>如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int threshold;             // 所能容纳的key-value对极限 </div><div class="line">final float loadFactor;    // 负载因子</div><div class="line">int modCount;  </div><div class="line">int size;</div></pre></td></tr></table></figure>
<p>首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知，threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。</p>
<p>size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p>
<p>在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。" target="_blank" rel="external">http://blog.csdn.net/liuqiyao_01/article/details/14475159，Hashtable初始化桶大小为11，就是桶大小设计为素数的应用（Hashtable扩容后不能保证还是素数）。HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。</a></p>
<p>这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法</p>
<h1 id="三：确定哈希桶数组索引位置"><a href="#三：确定哈希桶数组索引位置" class="headerlink" title="三：确定哈希桶数组索引位置"></a>三：确定哈希桶数组索引位置</h1><p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//方法一：</div><div class="line">static final int hash(Object key) &#123;   //jdk1.8 &amp; jdk1.7</div><div class="line">     int h;</div><div class="line">     // h = key.hashCode() 为第一步 取hashCode值</div><div class="line">     // h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</div><div class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line">//方法二：</div><div class="line">static int indexFor(int h, int length) &#123;  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</div><div class="line">     return h &amp; (length-1);  //第三步 取模运算</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的Hash算法本质上就是三步：取key的hashCode值、高位运算、取模运算。</p>
<p>对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，模运算的消耗还是比较大的，在HashMap中是这样做的：调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙，它通过h &amp; (table.length -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。</p>
<p>下面举例说明下，n为table的长度。<br><img src="/2018/02/27/JDK1-8源码解析——HashMap/2.png" alt="2"></p>
<h1 id="四：HashMap的put方法实现"><a href="#四：HashMap的put方法实现" class="headerlink" title="四：HashMap的put方法实现"></a>四：HashMap的put方法实现</h1><p><img src="/2018/02/27/JDK1-8源码解析——HashMap/7.png" alt="7"><br>put函数大致的思路为：</p>
<ol>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize。<br>具体代码实现如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line"></div><div class="line">    return putVal(hash(key), key, value, false, true);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">*生成hash的方法</div><div class="line">*/</div><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div><div class="line"></div><div class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div class="line">    //判断table是否为空，</div><div class="line">    if ((tab = table) == null || (n = tab.length) == 0)</div><div class="line">        n = (tab = resize()).length;//创建一个新的table数组，并且获取该数组的长度</div><div class="line">    //根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加   </div><div class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</div><div class="line">        tab[i] = newNode(hash, key, value, null);</div><div class="line">    else &#123;//如果对应的节点存在</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        //判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</div><div class="line">        if (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        //判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</div><div class="line">        else if (p instanceof TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div class="line">       // 该链为链表</div><div class="line">        else &#123;</div><div class="line">        //遍历table[i]，判断链表长度是否大于TREEIFY_THRESHOLD(默认值为8)，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</div><div class="line">            for (int binCount = 0; ; ++binCount) &#123;</div><div class="line">                if ((e = p.next) == null) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, null);</div><div class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                if (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                    break;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 写入</div><div class="line">        if (e != null) &#123; // existing mapping for key</div><div class="line">            V oldValue = e.value;</div><div class="line">            if (!onlyIfAbsent || oldValue == null)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    // 插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容</div><div class="line">    if (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="五：HashMap的get方法实现"><a href="#五：HashMap的get方法实现" class="headerlink" title="五：HashMap的get方法实现"></a>五：HashMap的get方法实现</h1><p>思路如下：</p>
<ol>
<li>bucket里的第一个节点，直接命中；</li>
<li>如果有冲突，则通过key.equals(k)去查找对应的entry ,若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Node&lt;K,V&gt; e;</div><div class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</div><div class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</div><div class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</div><div class="line">            // 直接命中</div><div class="line">            if (first.hash == hash &amp;&amp; // 每次都是校验第一个node</div><div class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                return first;</div><div class="line">           // 未命中</div><div class="line">            if ((e = first.next) != null) &#123;</div><div class="line">            // 在树中获取</div><div class="line">                if (first instanceof TreeNode)</div><div class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">                // 在链表中获取</div><div class="line">                do &#123;</div><div class="line">                    if (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">                        return e;</div><div class="line">                &#125; while ((e = e.next) != null);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="六：扩容机制"><a href="#六：扩容机制" class="headerlink" title="六：扩容机制"></a>六：扩容机制</h1><p>扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。</p>
<p>我们分析下resize的源码，鉴于JDK1.8融入了红黑树，较复杂，为了便于理解我们仍然使用JDK1.7的代码，好理解一些，本质上区别不大，具体区别后文再说。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void resize(int newCapacity) &#123;   //传入新的容量</div><div class="line">     Entry[] oldTable = table;    //引用扩容前的Entry数组</div><div class="line">     int oldCapacity = oldTable.length;         </div><div class="line">     if (oldCapacity == MAXIMUM_CAPACITY) &#123;  //扩容前的数组大小如果已经达到最大(2^30)了</div><div class="line">          threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</div><div class="line">         return;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     Entry[] newTable = new Entry[newCapacity];  //初始化一个新的Entry数组</div><div class="line">     transfer(newTable);                         //！！将数据转移到新的Entry数组里</div><div class="line">     table = newTable;                           //HashMap的table属性引用新的Entry数组</div><div class="line">   threshold = (int)(newCapacity * loadFactor);//修改阈值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组，transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"> void transfer(Entry[] newTable) &#123;</div><div class="line">     Entry[] src = table;                   //src引用了旧的Entry数组</div><div class="line">     int newCapacity = newTable.length;</div><div class="line">     for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组</div><div class="line">         Entry&lt;K,V&gt; e = src[j];             //取得旧Entry数组的每个元素</div><div class="line">         if (e != null) &#123;</div><div class="line">             src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象）</div><div class="line">             do &#123;</div><div class="line">                 Entry&lt;K,V&gt; next = e.next;</div><div class="line">                int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置</div><div class="line">                e.next = newTable[i]; //标记[1]</div><div class="line">                newTable[i] = e;      //将元素放在数组上</div><div class="line">                e = next;             //访问下一个Entry链上的元素</div><div class="line">            &#125; while (e != null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别，下文详解。在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。其中的哈希桶数组table的size=2， 所以key = 3、7、5，put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1，即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4，然后所有的Node重新rehash的过程。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap/3.png" alt="3"></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap/4.png" alt="4"></p>
<p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p>
<p><img src="/2018/02/27/JDK1-8源码解析——HashMap/5.png" alt="5"><br>因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：<br><img src="/2018/02/27/JDK1-8源码解析——HashMap/6.png" alt="6"></p>
<p>这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码，写的很赞，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">final Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div class="line">    int oldThr = threshold;</div><div class="line">    int newCap, newThr = 0;</div><div class="line">    if (oldCap &gt; 0) &#123;</div><div class="line">        // 超过最大值就不再扩充了，就只好随你碰撞去吧</div><div class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            return oldTab;</div><div class="line">        &#125;</div><div class="line">        // 没超过最大值，就扩充为原来的2倍</div><div class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</div><div class="line">    &#125;</div><div class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</div><div class="line">        newCap = oldThr;</div><div class="line">    else &#123;               // zero initial threshold signifies using defaults</div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    // 计算新的resize上限</div><div class="line">    if (newThr == 0) &#123;</div><div class="line"></div><div class="line">        float ft = (float)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div class="line">                  (int)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    if (oldTab != null) &#123;</div><div class="line">        // 把每个bucket都移动到新的buckets中</div><div class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            if ((e = oldTab[j]) != null) &#123;</div><div class="line">                oldTab[j] = null;</div><div class="line">                if (e.next == null)</div><div class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div class="line">                else if (e instanceof TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div class="line">                else &#123; // preserve order</div><div class="line">                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div class="line">                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    do &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        // 原索引</div><div class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</div><div class="line">                            if (loTail == null)</div><div class="line">                                loHead = e;</div><div class="line">                            else</div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        // 原索引+oldCap</div><div class="line">                        else &#123;</div><div class="line">                            if (hiTail == null)</div><div class="line">                                hiHead = e;</div><div class="line">                            else</div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; while ((e = next) != null);</div><div class="line">                    // 原索引放到bucket里</div><div class="line">                    if (loTail != null) &#123;</div><div class="line">                        loTail.next = null;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    // 原索引+oldCap放到bucket里</div><div class="line">                    if (hiTail != null) &#123;</div><div class="line">                        hiTail.next = null;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="七：总结"><a href="#七：总结" class="headerlink" title="七：总结"></a>七：总结</h1><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p>
<p>1.什么时候会使用HashMap？他有什么特点？</p>
<blockquote>
<p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p>
</blockquote>
<p>2.你知道HashMap的工作原理吗？</p>
<blockquote>
<p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p>
</blockquote>
<p>3.你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</p>
<blockquote>
<p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p>
</blockquote>
<p>4.你知道hash的实现吗？为什么要这样实现？</p>
<blockquote>
<p>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p>
</blockquote>
<p>5.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p>
<blockquote>
<p>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。<br>关于Java集合的小抄中是这样描述的：<br>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。<br>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。<br>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。<br>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。<br>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。<br>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p>
</blockquote>
<p>6.当两个对象的hashcode相同会发生什么？</p>
<blockquote>
<p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p>
</blockquote>
<p>7.如果两个键的hashcode相同，你如何获取值对象？</p>
<blockquote>
<p>找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。因此，设计HashMap的key类型时，如果使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择</p>
</blockquote>
<p>8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p>
<blockquote>
<p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置</p>
</blockquote>
<p>9.你了解重新调整HashMap大小存在什么问题吗？</p>
<blockquote>
<p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。因此在并发环境下，我们使用CurrentHashMap来替代HashMap</p>
</blockquote>
<p>10.为什么String, Interger这样的wrapper类适合作为键？</p>
<blockquote>
<p>因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能</p>
</blockquote>
<p>转载：<a href="http://blog.csdn.net/fjse51/article/details/53811465" target="_blank" rel="external">http://blog.csdn.net/fjse51/article/details/53811465</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：HashMap概述&quot;&gt;&lt;a href=&quot;#一：HashMap概述&quot; class=&quot;headerlink&quot; title=&quot;一：HashMap概述&quot;&gt;&lt;/a&gt;一：HashMap概述&lt;/h1&gt;&lt;p&gt;HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK1.7源码解析——HashMap</title>
    <link href="http://wangyuanjun.cn/2018/02/26/JDK1-7%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94HashMap/"/>
    <id>http://wangyuanjun.cn/2018/02/26/JDK1-7源码解析——HashMap/</id>
    <published>2018-02-26T06:05:10.000Z</published>
    <updated>2018-02-27T02:47:42.674Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：HashMap的定义和构造函数"><a href="#一：HashMap的定义和构造函数" class="headerlink" title="一：HashMap的定义和构造函数"></a>一：HashMap的定义和构造函数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class HashMap&lt;K,V&gt;</div><div class="line">    extends AbstractMap&lt;K,V&gt;</div><div class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable</div></pre></td></tr></table></figure>
<p>HashMap继承自AbstractMap，AbstractMap是Map接口的骨干实现，AbstractMap中实现了Map中最重要最常用和方法，这样HashMap继承AbstractMap就不需要实现Map的所有方法，让HashMap减少了大量的工作。<br>而在这里仍然实现Map结构，没有什么作用，应该是为了让map的层次结构更加清晰<br>HashMap有两个参数影响其性能：初始容量和加载因子。默认初始容量是16，加载因子是0.75。容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用 rehash 方法将容量翻倍。</p>
<h2 id="HashMap中定义的成员变量如下："><a href="#HashMap中定义的成员变量如下：" class="headerlink" title="HashMap中定义的成员变量如下："></a>HashMap中定义的成员变量如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * The default initial capacity - MUST be a power of two. </div><div class="line"> */  </div><div class="line">static final int DEFAULT_INITIAL_CAPACITY = 16;// 默认初始容量为16，必须为2的幂  </div><div class="line">  </div><div class="line">/** </div><div class="line"> * The maximum capacity, used if a higher value is implicitly specified </div><div class="line"> * by either of the constructors with arguments. </div><div class="line"> * MUST be a power of two &lt;= 1&lt;&lt;30. </div><div class="line"> */  </div><div class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 最大容量为2的30次方  </div><div class="line">  </div><div class="line">/** </div><div class="line"> * The load factor used when none specified in constructor. </div><div class="line"> */  </div><div class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;// 默认加载因子0.75  </div><div class="line">  </div><div class="line">/** </div><div class="line"> * The table, resized as necessary. Length MUST Always be a power of two. </div><div class="line"> */  </div><div class="line">transient Entry&lt;K,V&gt;[] table;// Entry数组，哈希表，长度必须为2的幂  </div><div class="line">  </div><div class="line">/** </div><div class="line"> * The number of key-value mappings contained in this map. </div><div class="line"> */  </div><div class="line">transient int size;// 已存元素的个数  </div><div class="line">  </div><div class="line">/** </div><div class="line"> * The next size value at which to resize (capacity * load factor). </div><div class="line"> * @serial </div><div class="line"> */  </div><div class="line">int threshold;// 下次扩容的临界值，size&gt;=threshold就会扩容，扩容临界点（容量和加载因子的乘积）  </div><div class="line">  </div><div class="line">  </div><div class="line">/** </div><div class="line"> * The load factor for the hash table. </div><div class="line"> * </div><div class="line"> * @serial </div><div class="line"> */  </div><div class="line">final float loadFactor;// 加载因子</div></pre></td></tr></table></figure>
<h2 id="HashMap的四个构造函数"><a href="#HashMap的四个构造函数" class="headerlink" title="HashMap的四个构造函数"></a>HashMap的四个构造函数</h2><p>public HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap<br>public HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap<br>public HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap<br>public HashMap(Map&lt; ? extends K, ? extends V&gt; m)：构造一个映射关系与指定 Map 相同的新 HashMap</p>
<p>这里有两个很重要的参数：<strong>initialCapacity</strong>（初始容量）、<strong>loadFactor</strong>（加载因子），看看JDK中的解释：<br>HashMap 的实例有两个参数影响其性能：初始容量 和加载因子。<br><strong>容量</strong> ：是哈希表中桶的数量，<strong>初始容量只是哈希表在创建时的容量</strong>，实际上就是Entry&lt; K,V&gt;[] table的容量<br><strong>加载因子</strong> ：是哈希表在<strong>其容量自动增加之前可以达到多满的一种尺度</strong>。它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。<br>当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约<strong>两倍的桶数</strong>。</p>
<h1 id="二：HashMap的数据结构"><a href="#二：HashMap的数据结构" class="headerlink" title="二：HashMap的数据结构"></a>二：HashMap的数据结构</h1><p>我们知道在Java中最常用的两种结构是数组和模拟指针(引用)，几乎所有的数据结构都可以利用这两种来组合实现，HashMap也是如此。实际上HashMap是一个“链表散列”，如下是它数据结构：<br><img src="/2018/02/26/JDK1-7源码解析——HashMap/数据结构.png" alt="数据结构"></p>
<p>从上图我们可以看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity就代表了该数组的长度。下面为HashMap构造函数的源码： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">    //容量不能小于0</div><div class="line">    if (initialCapacity &lt; 0)</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                           initialCapacity);</div><div class="line">    //容量不能超出最大容量</div><div class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    //加载因子不能&lt;=0 或者 为非数字</div><div class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div class="line">                                           loadFactor);</div><div class="line"></div><div class="line">    //计算出大于初始容量的最小 2的n次方作为哈希表table的长度，下面会说明为什么要这样</div><div class="line">    int capacity = 1;</div><div class="line">    while (capacity &lt; initialCapacity)</div><div class="line">        capacity &lt;&lt;= 1;</div><div class="line"></div><div class="line">    this.loadFactor = loadFactor;</div><div class="line">    //设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作</div><div class="line">    threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</div><div class="line">    //创建Entry数组</div><div class="line">    table = new Entry[capacity];</div><div class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</div><div class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</div><div class="line">    init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这个构造函数主要做的事情就是： </p>
<ol>
<li>对传入的 容量 和 加载因子进行判断处理 </li>
<li>设置HashMap的容量极限 </li>
<li>计算出大于初始容量的最小 2的n次方作为哈希表table的长度，然后用该长度创建Entry数组（table），这个是最核心的</li>
</ol>
<p>可以发现，一个HashMap对应一个Entry数组，来看看Entry这个元素的内部结构： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    int hash;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * Creates new entry.</div><div class="line">     */</div><div class="line">    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">        value = v;</div><div class="line">        next = n;</div><div class="line">        key = k;</div><div class="line">        hash = h;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Entry是HashMap的一个内部类，它也是维护着一个key-value映射关系，除了key和value，还有<strong>next引用（该引用指向当前table位置的链表），hash值（用来确定每一个Entry链表在table中位置）</strong></p>
<h1 id="三：HashMap的存储实现put（K-V）"><a href="#三：HashMap的存储实现put（K-V）" class="headerlink" title="三：HashMap的存储实现put（K,V）"></a>三：HashMap的存储实现put（K,V）</h1><p>HashMap中我们最长用的就是put(K, V)和get(K)。我们都知道，HashMap的K值是唯一的，那如何保证唯一性呢？我们首先想到的是用equals比较，没错，这样可以实现，但随着内部元素的增多，put和get的效率将越来越低，这里的时间复杂度是O(n)，假如有1000个元素，put时最差情况需要比较1000次。实际上，HashMap很少会用到equals方法，因为其内通过一个哈希表管理所有元素，哈希是通过hash单词音译过来的，也可以称为散列表，哈希算法可以快速的存取元素，当我们调用put存值时，HashMap首先会调用K的hashCode方法，获取哈希码，通过哈希码快速找到某个存放位置，这个位置可以被称之为<strong>bucketIndex</strong>，但可能会存在多个元素找到了相同的<strong>bucketIndex</strong>，有个专业名词叫<strong>碰撞</strong>，当碰撞发生时，这时会取到<strong>bucketIndex</strong>位置已存储的元素，最终通过equals来比较，equals方法就是碰撞时才会执行的方法，所以前面说HashMap很少会用到equals。HashMap通过hashCode和equals最终判断出K是否已存在，如果已存在，则使用新V值替换旧V值，并返回旧V值，如果不存在 ，则存放新的键值对<k, v="">到<strong>bucketIndex</strong>位置。文字描述有些乱，通过下面的流程图来梳理一下整个put过程。<br><img src="/2018/02/26/JDK1-7源码解析——HashMap/3.png" alt="3"><br>现在我们知道，执行put方法后，最终HashMap的存储结构会有这三种情况，我们当然期望情形3是最少发生的（效率最低）。到目前为止，我们了解了两件事：</k,></p>
<ul>
<li>HashMap通过键的hashCode来快速的存取元素。</li>
<li>当不同的对象发生碰撞时，HashMap通过单链表来解决，将新元素加入链表表头，通过next指向原有的元素。单链表在Java中的实现就是对象的引用(复合)。<br>来鉴赏一下HashMap中put方法源码：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    //如果key为空的情况</div><div class="line">    if (key == null)</div><div class="line">        return putForNullKey(value);</div><div class="line">    //计算key的hash值</div><div class="line">    int hash = hash(key);</div><div class="line">    //计算该hash值在table中的下标</div><div class="line">    int i = indexFor(hash, table.length);</div><div class="line">    //对table[i]存放的链表进行遍历</div><div class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        //判断该条链上是否有hash值相同的(key相同)  </div><div class="line">        //若存在相同，则直接覆盖value，返回旧value</div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(this);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //修改次数+1</div><div class="line">    modCount++;</div><div class="line">    //把当前key，value添加到table[i]的链表中</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的过程中，我们起码可以发现两点：</p>
<p>1.如果为null，则调用putForNullKey：这就是为什么HashMap可以用null作为键的原因，来看看HashMap是如何处理null键的： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private V putForNullKey(V value) &#123;</div><div class="line">    //查找链表中是否有null键</div><div class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</div><div class="line">        if (e.key == null) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(this);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    modCount++;</div><div class="line">    //如果链中查找不到，则把该null键插入</div><div class="line">    addEntry(0, null, value, 0);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</div><div class="line">        resize(2 * table.length);</div><div class="line">        //这一步就是对null的处理，如果key为null，hash值为0，也就是会插入到哈希表的表头table[0]的位置</div><div class="line">        hash = (null != key) ? hash(key) : 0;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回：这就是为什么HashMap不能有两个相同的key的原因</p>
<p>对于hash操作，最重要也是最困难的就是如何通过确定hash的位置，我们来看看HashMap的做法：<br>首先求得key的hash值：hash(key)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">final int hash(Object k) &#123;</div><div class="line">    int h = 0;</div><div class="line">    if (useAltHashing) &#123;</div><div class="line">        if (k instanceof String) &#123;</div><div class="line">            return sun.misc.Hashing.stringHash32((String) k);</div><div class="line">        &#125;</div><div class="line">        h = hashSeed;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    h ^= k.hashCode();</div><div class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个数学计算，可以不用深入，关键是下面这里：<br>计算该hash值在table中的下标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">static int indexFor(int h, int length) &#123;</div><div class="line">    return h &amp; (length-1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，而HashMap是通过&amp;运算符（按位与操作）来实现的：h &amp; (length-1)</p>
<p>在构造函数中存在：capacity &lt;&lt;= 1，这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。至于为什么是2的n次方下面解释。<br>我们回到indexFor方法，该方法仅有一条语句：h&amp;(length - 1)，这句话除了上面的取模运算外还有一个非常重要的责任：均匀分布table数据和充分利用空间。<br>这里我们假设length为16(2^n)和15，h为5、6、7。 </p>
<p><img src="/2018/02/26/JDK1-7源码解析——HashMap/1.png" alt="1"></p>
<p>当length-1 = 14时，6和7的结果一样，这样表示他们在table存储的位置是相同的，也就是产生了碰撞，6、7就会在一个位置形成链表，这样就会导致查询速度降低详细地看看当length-1 = 14 时的情况：<br><img src="/2018/02/26/JDK1-7源码解析——HashMap/2.png" alt="2"></p>
<p>可以看到，这样发生发生的碰撞是非常多的，1,3,5,7,9,11,13都没有存放数据，空间减少，进一步增加碰撞几率，这样就会导致查询速度慢，<br>分析一下：当length-1 = 14时，二进制的最后一位是0，在&amp;操作时，一个为0，无论另一个为1还是0，最终&amp;操作结果都是0，这就造成了结果的二进制的最后一位都是0，这就导致了所有数据都存储在2的倍数位上，所以说，<font color="red">所以说当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。 </font><br>　　<br>然后我们来看看计算了hash值，并用该hash值来求得哈希表中的索引值之后，如何把该key-value插入到该索引的链表中：<br>调用 addEntry(hash, key, value, i) 方法：<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">    //如果size大于极限容量，将要进行重建内部数据结构操作，之后的容量是原来的两倍，并且重新设置hash值和hash值在table中的索引值</div><div class="line">    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;</div><div class="line">        resize(2 * table.length);</div><div class="line">        hash = (null != key) ? hash(key) : 0;</div><div class="line">        bucketIndex = indexFor(hash, table.length);</div><div class="line">    &#125;</div><div class="line">    //真正创建Entry节点的操作</div><div class="line">    createEntry(hash, key, value, bucketIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void createEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    size++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先取得bucketIndex位置的Entry头结点，并创建新节点，把该新节点插入到<strong>链表中的头部</strong>，该新节点的next指针指向原来的头结点<br>　　<br>这里有两点需要注意：<br>一、链的产生<br>这是一个非常优雅的设计。系统总是将新的Entry对象添加到bucketIndex处。如果bucketIndex处已经有了对象，那么新添加的Entry对象将指向原有的Entry对象，形成一条Entry链，但是若bucketIndex处没有Entry对象，也就是e==null,那么新添加的Entry对象指向null，也就不会产生Entry链了。<br>二、扩容问题<br>还记得HashMap中的一个变量吗，threshold，这是容器的容量极限，还有一个变量size，这是指HashMap中键值对的数量，也就是node的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);</div></pre></td></tr></table></figure>
<p>什么时候发生扩容？<br>当不断添加key-value，size大于了容量极限threshold时，会发生扩容<br>如何扩容？<br>扩容发生在resize方法中，也就是扩大数组（桶）的数量，如何扩容参考：<a href="http://blog.csdn.net/jeffleo/article/details/63684953" target="_blank" rel="external">http://blog.csdn.net/jeffleo/article/details/63684953</a> </p>
<p><strong>我们重新来理一下存储的步骤：</strong></p>
<ol>
<li>传入key和value，判断key是否为null，如果为null，则调用putForNullKey，以null作为key存储到哈希表中； </li>
<li>然后计算key的hash值，根据hash值搜索在哈希表table中的索引位置，若当前索引位置不为null，则对该位置的Entry链表进行遍历，如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回，结束； </li>
<li>否则调用addEntry，用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部</li>
</ol>
<h1 id="四：HashMap的读取实现get（key，value）"><a href="#四：HashMap的读取实现get（key，value）" class="headerlink" title="四：HashMap的读取实现get（key，value）"></a>四：HashMap的读取实现get（key，value）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">    //如果key为null，求null键</div><div class="line">    if (key == null)</div><div class="line">        return getForNullKey();</div><div class="line">    // 用该key求得entry</div><div class="line">    Entry&lt;K,V&gt; entry = getEntry(key);</div><div class="line"></div><div class="line">    return null == entry ? null : entry.getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">final Entry&lt;K,V&gt; getEntry(Object key) &#123;</div><div class="line">    int hash = (key == null) ? 0 : hash(key);</div><div class="line">    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</div><div class="line">         e != null;</div><div class="line">         e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        if (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div class="line">            return e;</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读取的步骤比较简单，调用hash（key）求得key的hash值，然后调用indexFor（hash）求得hash值对应的table的索引位置，然后遍历索引位置的链表，如果存在key，则把key对应的Entry返回，否则返回null</p>
<h1 id="五：HashMap键的遍历，keySet"><a href="#五：HashMap键的遍历，keySet" class="headerlink" title="五：HashMap键的遍历，keySet()"></a>五：HashMap键的遍历，keySet()</h1><p>HashMap遍历的核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123;</div><div class="line">    Entry&lt;K,V&gt; next;        // next entry to return</div><div class="line">    int expectedModCount;   // For fast-fail</div><div class="line">    int index;              // current slot</div><div class="line">    Entry&lt;K,V&gt; current;     // current entry</div><div class="line"></div><div class="line">    //当调用keySet().iterator()时，调用此代码</div><div class="line">    HashIterator() &#123;</div><div class="line">        expectedModCount = modCount;</div><div class="line">        if (size &gt; 0) &#123; // advance to first entry</div><div class="line">            Entry[] t = table;</div><div class="line">            //从哈希表数组从上到下，查找第一个不为null的节点，并把next引用指向该节点</div><div class="line">            while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public final boolean hasNext() &#123;</div><div class="line">        return next != null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //当调用next时，会调用此代码</div><div class="line">    final Entry&lt;K,V&gt; nextEntry() &#123;</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        Entry&lt;K,V&gt; e = next;</div><div class="line">        if (e == null)</div><div class="line">            throw new NoSuchElementException();</div><div class="line"></div><div class="line">        //如果当前节点的下一个节点为null，从节点处罚往下查找哈希表，找到第一个不为null的节点</div><div class="line">        if ((next = e.next) == null) &#123;</div><div class="line">            Entry[] t = table;</div><div class="line">            while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)</div><div class="line">                ;</div><div class="line">        &#125;</div><div class="line">        current = e;</div><div class="line">        return e;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void remove() &#123;</div><div class="line">        if (current == null)</div><div class="line">            throw new IllegalStateException();</div><div class="line">        if (modCount != expectedModCount)</div><div class="line">            throw new ConcurrentModificationException();</div><div class="line">        Object k = current.key;</div><div class="line">        current = null;</div><div class="line">        HashMap.this.removeEntryForKey(k);</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里可以看出，HashMap遍历时，按哈希表的每一个索引的链表从上往下遍历，由于HashMap的存储规则，最晚添加的节点都有可能在第一个索引的链表中，这就造成了HashMap的遍历时无序的。</p>
<p>参考：<br><a href="http://blog.csdn.net/jeffleo/article/details/54946424" target="_blank" rel="external">http://blog.csdn.net/jeffleo/article/details/54946424</a><br><a href="http://blog.csdn.net/ghsau/article/details/16843543" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/16843543</a><br><a href="http://blog.csdn.net/ghsau/article/details/16890151" target="_blank" rel="external">http://blog.csdn.net/ghsau/article/details/16890151</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：HashMap的定义和构造函数&quot;&gt;&lt;a href=&quot;#一：HashMap的定义和构造函数&quot; class=&quot;headerlink&quot; title=&quot;一：HashMap的定义和构造函数&quot;&gt;&lt;/a&gt;一：HashMap的定义和构造函数&lt;/h1&gt;&lt;figure class
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker容器部署Java web应用(定制镜像)</title>
    <link href="http://wangyuanjun.cn/2018/02/12/Docker%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2Java-web%E5%BA%94%E7%94%A8%E6%96%B9%E5%BC%8F%E4%BA%8C/"/>
    <id>http://wangyuanjun.cn/2018/02/12/Docker容器部署Java-web应用方式二/</id>
    <published>2018-02-12T08:09:48.000Z</published>
    <updated>2018-02-12T08:59:48.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念简述"><a href="#概念简述" class="headerlink" title="概念简述"></a>概念简述</h1><ul>
<li><p>镜像 一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数。<br>Docker镜像是一个只读的模板。比如一个镜像可以包含Ubuntu系统以及安装在Ubuntu上的Apache Web服务器和你自己的应用。镜像是用来创建容器的。Docker提供了一个简单的方式用以创建新的镜像或者更新现存的镜像，甚至你可以下载其他地方提供的镜像。镜像是Docker服务的组件之一。<br>由于Docker使用一个统一文件系统，Docker镜像其实就是一堆文件的集合，并不是像VM那样的是一个操作系统。镜像可以简单到只有一个程序文件，比如如果你写了一个简单的hello world程序放到一个空的镜像中，那么整个镜像的大小，就是你编译后的二进制文件的大小。<br>总结来说就是：<br>镜像(image)是 Docker 的三大组件之一；<br>镜像是用来启动容器的基石；<br>镜像是只读的，也即是无状态的，一个镜像是永久不会变的；<br>一个没有任何父镜像的镜像，称之为基础镜像;<br>在Docker容器中所有的变更都发生顶层的镜像可写层;<br>Docker 运行容器前需要本地存在对应的镜像，如果镜像不存在本地，Docker 会从镜像仓库下载（ 默认是 Docker Hub 公共注册服务器中的仓库）。</p>
</li>
<li><p>容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
</li>
<li>仓库 镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务 1)docker hub 2)私有仓库</li>
<li>Dockerfile 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</li>
<li>数据卷 一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性: </li>
</ul>
<ul>
<li>数据卷可以在容器之间共享和重用 </li>
<li>对数据卷的修改会立马生效 </li>
<li>对数据卷的更新，不会影响镜像 </li>
<li>数据卷默认会一直存在，即使容器被删除</li>
</ul>
<h1 id="创建docker镜像的两种方法"><a href="#创建docker镜像的两种方法" class="headerlink" title="创建docker镜像的两种方法"></a>创建docker镜像的两种方法</h1><ul>
<li>第一种:启动镜像后进入容器中操作,将需要的软件或者项目移动到容器中,安装或者部署,然后退出即可</li>
<li>第二种:编写dockerfile,将需要的镜像一层层叠加上去,比如我们要部署项目,可以先下载一个ubuntu基础镜像,然后叠加jdk,然后tomcat,然后项目</li>
</ul>
<p>区别在于,第二种比较体现docker的镜像叠加特性,第一种到最终只有一层镜像.本文讲述第二种</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>（运行环境：Ubuntu 16.04） </p>
<ul>
<li>安装jre：<br>可参考1:<a href="http://blog.csdn.net/u010542873/article/details/51679373" target="_blank" rel="external">http://blog.csdn.net/u010542873/article/details/51679373</a><br>2:<a href="http://www.linuxidc.com/Linux/2016-04/129731.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2016-04/129731.htm</a> </li>
<li>安装Tomcat：<br>可参考：Tomcat9安装 </li>
<li>在tomcat中部署webapp：<br>可参考：<a href="http://www.linuxidc.com/Linux/2015-02/112887.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2015-02/112887.htm</a><br>IDEA集成样例可参考<a href="http://blog.csdn.net/yhao2014/article/details/45740111" target="_blank" rel="external">http://blog.csdn.net/yhao2014/article/details/45740111</a> </li>
<li>Ubuntu 16.04安装docker：<br>可参考 <a href="http://www.linuxidc.com/Linux/2016-12/138489.htm" target="_blank" rel="external">http://www.linuxidc.com/Linux/2016-12/138489.htm</a></li>
</ul>
<p>利用DockerFile制定镜像<br>通过编写Dockerfile的方式制作镜像。<br>需要在Dockerfile中完成如下几项工作：<br>（1）安装jre<br>（2）安装tomcat，并完成在tomcat中部署web应用的基本配置（为实现此功能：在制作镜像之前直接先完成tomcat的基础配置，然后直接拷贝到镜像中即可）。<br>（3）对外开发8080端口（具体的端口值可以根据实际Tomcat配置参数为准）。</p>
<pre><code>$mkdir docker
$cd docker
</code></pre><p>建立docker文件夹，并把之前下好的jre文件夹和tomcat文件夹（或者压缩包，均可）拖入其中，docker文件夹下目录如下：<br><img src="/2018/02/12/Docker容器部署Java-web应用方式二/1.png" alt="1"></p>
<h2 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h2><p>补充：关于Dockerfile文件<br>在容器中配置运行环境（此处是jre和tomcat）的任务主要是在容器中安装软件，并进行相应的配置，如果把这个过程所要执行的命令全都提取出来，写入一个文件中，若需要构建镜像则直接运行该文件，基于其中的命令生成一个镜像。这就是基于Dockerfile构建镜像的方式，这个文件就称为Dockerfile<br>Dockerfile文件一共分为四个部分，分别是：注释信息、基础镜像、创建者信息、构建镜像所需的命令：<br>详细介绍可参考：<a href="http://www.tuicool.com/articles/vqAVRrE或http://blog.csdn.net/wsscy2004/article/details/25878223" target="_blank" rel="external">http://www.tuicool.com/articles/vqAVRrE或http://blog.csdn.net/wsscy2004/article/details/25878223</a><br>Dockerfile文件内容如下：<br>（以系统Ubuntu镜像为基础镜像）</p>
<pre><code>#Build java web app container image
FROM ubuntu:16.04
MAINTAINER zhaokx3 &quot;zhaokx3@mail2.sysu.edu.cn&quot;

#Make java and tomcat install directory
RUN mkdir /usr/local/java
RUN mkdir /usr/local/tomcat

#Copy jre and tomcat into image
ADD jre1.8.0_131 /usr/local/java/
ADD apache-tomcat-9.0.0.M21 /usr/local/tomcat/

ENV PATH $PATH:/usr/local/java/bin

#Expose http port
EXPOSE 8080

CMD [&quot;/usr/local/tomcat/bin/catalina.sh&quot;, &quot;run&quot;]
</code></pre><h3 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h3><pre><code>sudo docker build -t=&quot;ubuntu/mine:tomcat&quot; .
</code></pre><p><img src="/2018/02/12/Docker容器部署Java-web应用方式二/2.png" alt="2"></p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><pre><code>sudo docker run -p 8090:8080 --name tomcat -v /home/zhaokx3/docker/webapps/:/webapps/ ubuntu/mine:tomcat
</code></pre><p><img src="/2018/02/12/Docker容器部署Java-web应用方式二/3.png" alt="3"></p>
<p>简要说明：参数-v指定挂载的卷，如没有可不使用，参数-p将8080端口映射成主机的8090端口，这样就可以访问主机的8090端口就到容器的8080端口。<br>docker run 命令详解可参考：<a href="http://www.lupaworld.com/article-250439-1.html" target="_blank" rel="external">http://www.lupaworld.com/article-250439-1.html</a></p>
<p>最后成功通过<a href="http://localhost:8090/your_test" target="_blank" rel="external">http://localhost:8090/your_test</a> 访问自己的web应用（端口8090）：<br><img src="/2018/02/12/Docker容器部署Java-web应用方式二/4.png" alt="4"><br>可对比直接利用Tomcat部署web应用（端口8080）：<br><img src="/2018/02/12/Docker容器部署Java-web应用方式二/5.png" alt="5"></p>
<p>转载：<a href="http://blog.csdn.net/zhaokx3/article/details/72757527" target="_blank" rel="external">http://blog.csdn.net/zhaokx3/article/details/72757527</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念简述&quot;&gt;&lt;a href=&quot;#概念简述&quot; class=&quot;headerlink&quot; title=&quot;概念简述&quot;&gt;&lt;/a&gt;概念简述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;镜像 一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的
    
    </summary>
    
      <category term="Docker" scheme="http://wangyuanjun.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://wangyuanjun.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器部署Java web应用(容器基础上创建新镜像)</title>
    <link href="http://wangyuanjun.cn/2018/02/12/Docker%E5%AE%B9%E5%99%A8%E9%83%A8%E7%BD%B2Java-web%E5%BA%94%E7%94%A8/"/>
    <id>http://wangyuanjun.cn/2018/02/12/Docker容器部署Java-web应用/</id>
    <published>2018-02-12T07:32:54.000Z</published>
    <updated>2018-02-12T09:02:00.065Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：本文主要讲了如何在Ubuntu14.04 64位系统下来创建一个运行Java web应用程序的Docker容器。<br>创建docker镜像的两种方法</p>
<ul>
<li>第一种:启动镜像后进入容器中操作,将需要的软件或者项目移动到容器中,安装或者部署,然后退出即可</li>
<li>第二种:编写dockerfile,将需要的镜像一层层叠加上去,比如我们要部署项目,可以先下载一个ubuntu基础镜像,然后叠加jdk,然后tomcat,然后项目</li>
</ul>
<p>区别在于,第二种比较体现docker的镜像叠加特性,第一种到最终只有一层镜像.本文讲述第一种</p>
<h1 id="一：下载镜像、启动容器"><a href="#一：下载镜像、启动容器" class="headerlink" title="一：下载镜像、启动容器"></a>一：下载镜像、启动容器</h1><p>1、下载镜像<br>先查看镜像</p>
<pre><code>docker images  
</code></pre><p><img src="/2018/02/12/Docker容器部署Java-web应用/查看镜像.png" alt="查看镜像"></p>
<p>记住这个Image ID，下面我们启动容器需要用到它。<br>如果看到以上输出，说明您可以使用“oursuer/ubuntu”这个镜像了，或将其称为仓库（Repository），该镜像有一个名为“14.04”的标签（Tag），此外还有一个名为<br>1f879014f4d2 的镜像 ID（可能您所看到的镜像 ID 与此处的不一致，那是正常现象，因为这个数字是随机生成的）。此外，我们可以看到该镜像只有188.4 MB，非常小巧，而不像虚拟机的镜像文件那样庞大。<br>现在镜像已经有了，我们下面就需要使用该镜像，来启动容器。</p>
<p>2、启动容器</p>
<p>容器是在镜像的基础上来运行的，一旦容器启动了，我们就可以登录到容器中，安装自己所需的软件或应用程序。既然镜像已经下载到本地，那么如何才能启动容器呢？<br>只需使用以下命令即可启动容器：</p>
<pre><code>docker run -i -t -v /download/:/mnt/software/ 1f879014f4d2 /bin/bash  
</code></pre><p>这条命令比较长，我们稍微分解一下，其实包含以下三个部分：</p>
<pre><code>docker run &lt;相关参数&gt; &lt;镜像 ID&gt; &lt;初始命令&gt;  
</code></pre><p>如果看到以上输出，说明您可以使用“docker.cn/docker/centos”这个镜像了，或将其称为仓库（Repository），该镜像有一个名为“centos6”的标签（Tag），此外还有一个名为“25c5298b1a36 ”的镜像 ID（可能您所看到的镜像 ID 与此处的不一致，那是正常现象，因为这个数字是随机生成的）。此外，我们可以看到该镜像只有 215.8 MB，非常小巧，而不像虚拟机的镜像文件那样庞大。<br>现在镜像已经有了，我们下面就需要使用该镜像，来启动容器。</p>
<pre><code>其中，相关参数包括：  
-i：表示以“交互模式”运行容器  
-t：表示容器启动后会进入其命令行  
-v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;  
</code></pre><p>假设我们的所有安装程序都放在了宿主机的/download/目录下，现在需要将其挂载到容器的/mnt/software/目录下。<br>需要说明的是，不一定要使用“镜像 ID”，也可以使用“仓库名:标签名”，例如：oursuer/ubuntu:14.04。<br>初始命令表示一旦容器启动，需要运行的命令，此时使用“/bin/bash”，表示什么也不做，只需进入命令行即可。<br>退出容器使用Ctrl+d或输入exit</p>
<p>如果退出容器后，可以再次使用命令（注意，得先运行docker run之后然后被stop掉的容器才可以使用如下命令）</p>
<pre><code>docker start 容器ID  
</code></pre><p>其中容器ID。使用命令docker ps -a来看，如下：</p>
<p><img src="/2018/02/12/Docker容器部署Java-web应用/查看运行容器.png" alt="查看运行容器"></p>
<p>然后再次启动已启动过但现在是关闭的容器</p>
<pre><code>docker start sick_mestorf  
</code></pre><p>如下：<br><img src="/2018/02/12/Docker容器部署Java-web应用/如下.png" alt="如下"></p>
<h1 id="二：安装相关软件"><a href="#二：安装相关软件" class="headerlink" title="二：安装相关软件"></a>二：安装相关软件</h1><p>首先先将JDK和tomcat的安装包.gz文件放在外面的/download文件夹下<br><img src="/2018/02/12/Docker容器部署Java-web应用/21.png" alt="21"><br>然后再次启动容器。进入容器<br><img src="/2018/02/12/Docker容器部署Java-web应用/22.png" alt="22"><br>然后看看是否有安装包。发现两个都在了，下面可以安装了<br><img src="/2018/02/12/Docker容器部署Java-web应用/23.png" alt="23"></p>
<p>1、JDK安装</p>
<p>直接使用</p>
<pre><code>cd /usr  
mkdir java  
cd java  
mkdir jdk  
cd /mnt/software/  
tar zxvf jdk-8u65-linux-x64.gz -C /usr/java/jdk  
</code></pre><p>这里直接接文件解压到/usr/java/jdk目录，如下<br><img src="/2018/02/12/Docker容器部署Java-web应用/24.png" alt="24"></p>
<p>配置环境变量<br>输入：</p>
<pre><code>vi /etc/profile  
</code></pre><p>或<br>添加如下内容：</p>
<pre><code>#set java environment   
export JAVA_HOME=/usr/java/jdk/jdk1.8.0_65   
export JRE_HOME=/usr/java/jdk/jdk1.8.0_65/jre   
export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH   
export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH   
</code></pre><p><img src="/2018/02/12/Docker容器部署Java-web应用/25.png" alt="25"></p>
<p>注意此处改成对应的jdk的目录，并且要以root用户来做修改，否则无法保存<br>保存后执行：</p>
<pre><code>source /etc/profile   
</code></pre><p>验证安装：<br>输入:</p>
<pre><code>java -version
</code></pre><p><img src="/2018/02/12/Docker容器部署Java-web应用/26.png" alt="26"></p>
<p>如果出现如下内容，说明安装成功</p>
<p>2、tomcat安装</p>
<p>直接解压</p>
<pre><code>cd /usr/java  
mkdir tomcat  
tar zxvf  -C /usr/java/tomcat  
</code></pre><p>配置环境<br>进入到上面的tomcat的bin文件夹下：<br>打开</p>
<pre><code>vi setclasspath.sh  
</code></pre><p>或</p>
<pre><code>gedit setclasspath.sh  
</code></pre><p>添加如下内容：</p>
<pre><code>export JAVA_HOME=/usr/java/jdk/jdk1.8.0_65   
export JRE_HOME=/usr/java/jdk/jdk1.8.0_65/jre   
</code></pre><p>保存即可。<br>然后退回到bin目录下：</p>
<p>执行：</p>
<pre><code>./startup.sh  
</code></pre><p><img src="/2018/02/12/Docker容器部署Java-web应用/27.png" alt="27"></p>
<p>说明tomcat启动成功<br>或者使用如下命令查看：<br><img src="/2018/02/12/Docker容器部署Java-web应用/28.png" alt="28"></p>
<h1 id="三：配置容器启动环境变量"><a href="#三：配置容器启动环境变量" class="headerlink" title="三：配置容器启动环境变量"></a>三：配置容器启动环境变量</h1><p>（上面的JDK配置环境变量可以不要，但是这里的一定要写！！！！！！！！！！因为这里是设置容器启动时加载的环境变量）</p>
<p>1、设置环境变量</p>
<p>首先，编辑.bashrc文件</p>
<pre><code>vi ~/.bashrc  
</code></pre><p>然后，在该文件末尾添加如下配置：</p>
<pre><code>export JAVA_HOME=/usr/java/jdk/jdk1.8.0_65   
export JRE_HOME=/usr/java/jdk/jdk1.8.0_65/jre   
export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH   
export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$JAVA_HOME:$PATH   
</code></pre><p>最后，需要使用source命令，让环境变量生效：</p>
<pre><code>source ~/.bashrc  
</code></pre><p>2、编写运行脚本</p>
<p>我们需要编写一个运行脚本，当启动容器时，运行该脚本，启动 Tomcat，具体过程如下：<br>首先，创建运行脚本：</p>
<pre><code>vi /root/run.sh  
</code></pre><p>然后，编辑脚本内容如下：</p>
<pre><code>#!/bin/bash  
source ~/.bashrc  
sh /usr/java/tomcat/apache-tomcat-7.0.68/bin/catalina.sh run  
</code></pre><p>注意：这里必须先加载环境变量，然后使用 Tomcat 的运行脚本来启动 Tomcat 服务。<br>最后，为运行脚本添加执行权限：</p>
<pre><code>chmod u+x /root/run.sh  
</code></pre><p>3、退出容器</p>
<p>当以上步骤全部完成后，可使用exit或ctrl+d命令，退出容器。<br>随后，可使用如下命令查看正在运行的容器：<br>docker ps<br>此时，您应该看不到任何正在运行的程序，因为刚才已经使用exit命令退出的容器，此时容器处于停止状态，可使用如下命令查看所有容器：<br>docker ps -a<br>输出如下内容：</p>
<p><img src="/2018/02/12/Docker容器部署Java-web应用/31.png" alt="31"></p>
<p>记住以上CONTAINER ID（容器 ID），随后我们将通过该容器，创建一个可运行 Java Web 的镜像。</p>
<h1 id="四：创建-Java-Web-镜像"><a href="#四：创建-Java-Web-镜像" class="headerlink" title="四：创建 Java Web 镜像"></a>四：创建 Java Web 镜像</h1><p>使用以下命令，根据某个“容器 ID”来创建一个新的“镜像”：</p>
<pre><code>docker commit 89a47b5b749e  lin_javaweb:0.1  
</code></pre><p>该容器的 ID 是“89a47b5b749e”，所创建的镜像名是“lin_javaweb:0.1”，随后可使用镜像来启动 Java Web 容器。<br>这是创建成功后<br><img src="/2018/02/12/Docker容器部署Java-web应用/32.png" alt="32"><br>同样可以查看下镜像<br><img src="/2018/02/12/Docker容器部署Java-web应用/33.png" alt="33"></p>
<h1 id="五：启动-Java-Web-容器"><a href="#五：启动-Java-Web-容器" class="headerlink" title="五：启动 Java Web 容器"></a>五：启动 Java Web 容器</h1><p>有必要首先使用docker images命令，查看当前所有的镜像：</p>
<p><img src="/2018/02/12/Docker容器部署Java-web应用/51.png" alt="51"></p>
<p>可见，此时已经看到了最新创建的镜像“lin_javaweb:0.1”，其镜像 ID 是“4487bd38df06”。正如上面所描述的那样，我们可以通过“镜像名”或“镜像 ID”来启动容器，与上次启动容器不同的是，我们现在不再进入容器的命令行，而是直接启动容器内部的 Tomcat 服务。此时，需要使用以下命令：</p>
<pre><code>docker run -d -p 58080:8080 --name javaweb lin_javaweb:0.1 /root/run.sh  
</code></pre><p>稍作解释：</p>
<pre><code>-d：表示以“守护模式”执行/root/run.sh脚本，此时 Tomcat 控制台不会出现在输出终端上。  
-p：表示宿主机与容器的端口映射，此时将容器内部的 8080 端口映射为宿主机的 58080 端口，这样就向外界暴露了 58080 端口，可通过 Docker 网桥来访问容器内部的 8080 端口了。  
--name：表示容器名称，用一个有意义的名称命名即可。 
</code></pre><p>关于 Docker 网桥的内容，需要补充说明一下。实际上 Docker 在宿主机与容器之间，搭建了一座网络通信的桥梁，我们可通过宿主机 IP 地址与端口号来映射容器内部的 IP 地址与端口号，<br>在一系列参数后面的是“镜像名”或“镜像 ID”，怎么方便就怎么来。最后是“初始命令”，它是上面编写的运行脚本，里面封装了加载环境变量并启动 Tomcat 服务的命令。<br>当运行以上命令后，会立即输出一长串“容器 ID”，我们可通过docker ps命令来查看当前正在运行的容器。</p>
<p><img src="/2018/02/12/Docker容器部署Java-web应用/52.png" alt="52"></p>
<p>在浏览器中，输入以下地址，即可访问 Tomcat 首页：<br><a href="http://127.0.0.1:58080/" target="_blank" rel="external">http://127.0.0.1:58080/</a></p>
<p>或者</p>
<p><a href="http://localhost:58080/" target="_blank" rel="external">http://localhost:58080/</a><br>注意：这里使用的是宿主机的 IP 地址，与对外暴露的端口号 58080，它映射容器内部的端口号 8080。</p>
<p><img src="/2018/02/12/Docker容器部署Java-web应用/53.png" alt="53"></p>
<p>转载：<a href="http://blog.csdn.net/evankaka/article/details/50722788" target="_blank" rel="external">http://blog.csdn.net/evankaka/article/details/50722788</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：本文主要讲了如何在Ubuntu14.04 64位系统下来创建一个运行Java web应用程序的Docker容器。&lt;br&gt;创建docker镜像的两种方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种:启动镜像后进入容器中操作,将需要的软件或者项目移动到容器中,安装或者部署,然后退出
    
    </summary>
    
      <category term="Docker" scheme="http://wangyuanjun.cn/categories/Docker/"/>
    
    
      <category term="Docker" scheme="http://wangyuanjun.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Shell脚本学习</title>
    <link href="http://wangyuanjun.cn/2018/02/11/Shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0/"/>
    <id>http://wangyuanjun.cn/2018/02/11/Shell脚本学习/</id>
    <published>2018-02-11T03:40:37.000Z</published>
    <updated>2018-03-02T02:37:19.363Z</updated>
    
    <content type="html"><![CDATA[<p>Shell脚本,就是利用Shell的命令解释的功能，对一个纯文本的文件进行解析，然后执行这些功能，也可以说Shell脚本就是一系列命令的集合。<br>Shell可以直接使用在win/Unix/Linux上面，并且可以调用大量系统内部的功能来解释执行程序，如果熟练掌握Shell脚本，可以让我们操作计算机变得更加轻松，也会节省很多时间。</p>
<h1 id="一：Shell应用场景"><a href="#一：Shell应用场景" class="headerlink" title="一：Shell应用场景"></a>一：Shell应用场景</h1><h2 id="Shell能做什么"><a href="#Shell能做什么" class="headerlink" title="Shell能做什么"></a>Shell能做什么</h2><ul>
<li>将一些复杂的命令简单化(平时我们提交一次github代码可能需要很多步骤，但是可以用Shell简化成一步)</li>
<li>可以写一些脚本自动实现一个工程中自动更换最新的sdk(库)</li>
<li>自动打包、编译、发布等功能</li>
<li>清理磁盘中空文件夹</li>
<li>总之一切有规律的活脚本都可以尝试一下</li>
</ul>
<h2 id="Shell不能做什么"><a href="#Shell不能做什么" class="headerlink" title="Shell不能做什么"></a>Shell不能做什么</h2><ul>
<li>需要精密的运算的时候</li>
<li>需要语言效率很高的时候</li>
<li>需要一些网络操作的时候</li>
<li>总之Shell就是可以快速开发一个脚本简化开发流程，并不可以用来替代高级语言</li>
</ul>
<h2 id="Shell的工作原理"><a href="#Shell的工作原理" class="headerlink" title="Shell的工作原理"></a>Shell的工作原理</h2><p>Shell可以被称作是脚本语言，因为它本身是不需要编译的，而是通过解释器解释之后再编译执行，和传统语言相比多了解释的过程所以效率会略差于传统的直接编译的语言。</p>
<h2 id="最简单的脚本"><a href="#最简单的脚本" class="headerlink" title="最简单的脚本:"></a>最简单的脚本:</h2><p>先来个简单的例子吧，也就是我们程序猿最长说的helloworld</p>
<pre><code>#!/bin/bash
echo &quot;Hello World&quot;
</code></pre><p>只需要打开文本编辑工具，编辑成以上的样子,然后保存成test.sh</p>
<h2 id="运行该脚本："><a href="#运行该脚本：" class="headerlink" title="运行该脚本："></a>运行该脚本：</h2><pre><code>1. cd 到该目录下
2. chmod +x ./test.sh  #给脚本权限
3. ./test.sh  #执行脚本
</code></pre><p><img src="/2018/02/11/Shell脚本学习/helloworld.png" alt="helloworld"></p>
<h1 id="二：shell变量"><a href="#二：shell变量" class="headerlink" title="二：shell变量"></a>二：shell变量</h1><p>定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：</p>
<blockquote>
<p>your_name=”runoob.com”</p>
</blockquote>
<p>注意，变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p>
<p>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。<br>中间不能有空格，可以使用下划线（_）。<br>不能使用标点符号。<br>不能使用bash里的关键字（可用help命令查看保留关键字）。</p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p>
<pre><code>your_name=&quot;qinjx&quot;
echo $your_name
echo ${your_name}
</code></pre><h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。<br>下面的例子尝试更改只读变量，结果报错：</p>
<pre><code>#!/bin/bash
myUrl=&quot;http://www.w3cschool.cc&quot;
readonly myUrl
myUrl=&quot;http://www.runoob.com&quot;
</code></pre><p>运行脚本，结果如下：</p>
<pre><code>/bin/sh: NAME: This variable is read only.
</code></pre><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>变量被删除后不能再次使用。unset 命令不能删除只读变量。</p>
<pre><code>unset variable_name
</code></pre><h1 id="三：Shell-传递参数"><a href="#三：Shell-传递参数" class="headerlink" title="三：Shell 传递参数"></a>三：Shell 传递参数</h1><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以下实例我们向脚本传递三个参数，并分别输出，其中 $0 为执行的文件名：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

echo &quot;Shell 传递参数实例！&quot;;
echo &quot;执行的文件名：$0&quot;;
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;
</code></pre><p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：</p>
<pre><code>$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
执行的文件名：./test.sh
第一个参数为：1
第二个参数为：2
第三个参数为：3
</code></pre><p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$#</td>
<td style="text-align:center">传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td style="text-align:center">以一个单字符串显示所有向脚本传递的参数。如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
<tr>
<td>$$</td>
<td style="text-align:center">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td style="text-align:center">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td style="text-align:center">与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td>
</tr>
<tr>
<td>$-</td>
<td style="text-align:center">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td style="text-align:center">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

echo &quot;Shell 传递参数实例！&quot;;
echo &quot;第一个参数为：$1&quot;;

echo &quot;参数个数为：$#&quot;;
echo &quot;传递的参数作为一个字符串显示：$*&quot;;
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>$ chmod +x test.sh 
$ ./test.sh 1 2 3
Shell 传递参数实例！
第一个参数为：1
参数个数为：3
传递的参数作为一个字符串显示：1 2 3
</code></pre><p>$* 与 $@ 区别：</p>
<ul>
<li>相同点：都是引用所有参数。</li>
<li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li>
</ul>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

echo &quot;-- \$* 演示 ---&quot;
for i in &quot;$*&quot;; do
    echo $i
done

echo &quot;-- \$@ 演示 ---&quot;
for i in &quot;$@&quot;; do
    echo $i
done
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>$ chmod +x test.sh 
$ ./test.sh 1 2 3
-- $* 演示 ---
1 2 3
-- $@ 演示 ---
1
2
3
</code></pre><h1 id="四：shell数组"><a href="#四：shell数组" class="headerlink" title="四：shell数组"></a>四：shell数组</h1><h2 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h2><p>在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：<br>数组名=(值1 值2 … 值n)<br>例如：</p>
<p>在Shell中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：</p>
<pre><code>数组名=(值1 值2 ... 值n)
</code></pre><p>例如：</p>
<pre><code>array_name=(value0 value1 value2 value3)
</code></pre><p>或者</p>
<pre><code>array_name=(
value0
value1
value2
value3
)
</code></pre><p>还可以单独定义数组的各个分量：</p>
<pre><code>array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
</code></pre><p>可以不使用连续的下标，而且下标的范围没有限制。</p>
<h2 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h2><p>读取数组元素值的一般格式是：</p>
<pre><code>${数组名[下标]}
</code></pre><p>例如：</p>
<pre><code>valuen=${array_name[n]}
</code></pre><p>使用@符号可以获取数组中的所有元素，例如：</p>
<pre><code>echo ${array_name[@]}
</code></pre><h2 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h2><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p>
<pre><code># 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
# 取得数组单个元素的长度
lengthn=${#array_name[n]}
</code></pre><h2 id="Shell-注释"><a href="#Shell-注释" class="headerlink" title="Shell 注释"></a>Shell 注释</h2><p>以”#”开头的行就是注释，会被解释器忽略。</p>
<p>sh里没有多行注释，只能每一行加一个#号。只能像这样：</p>
<pre><code>#--------------------------------------------
# 这是一个注释
# author：菜鸟教程
# site：www.runoob.com
# slogan：学的不仅是技术，更是梦想！
#--------------------------------------------
##### 用户配置区 开始 #####
#
#
# 这里可以添加脚本描述信息
# 
#
##### 用户配置区 结束  #####
</code></pre><h1 id="五：基本运算符"><a href="#五：基本运算符" class="headerlink" title="五：基本运算符"></a>五：基本运算符</h1><p>Shell 和其他编程语言一样，支持多种运算符，包括：</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。</p>
<p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<p>例如，两个数相加(<font color="red">注意使用的是反引号 ` 而不是单引号 ‘</font>)：</p>
<pre><code>#!/bin/bash

val=`expr 2 + 2`
echo &quot;两数之和为 : $val&quot;
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>两数之和为 : 4
</code></pre><p>两点注意：</p>
<ul>
<li><font color="red">表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</font></li>
<li><font color="red">完整的表达式要被 `` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。</font>

</li>
</ul>
<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+    加法</td>
<td style="text-align:right"><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td>-    减法</td>
<td style="text-align:right"><code>expr $a - $b</code> 结果为 -10。</td>
</tr>
<tr>
<td>*    乘法</td>
<td style="text-align:right"><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td>/    除法</td>
<td style="text-align:right"><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td>%    取余</td>
<td style="text-align:right"><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td>=    赋值</td>
<td style="text-align:right">a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td>==    相等。用于比较两个数字，相同则返回 true。</td>
<td style="text-align:right">[ $a == $b ] 返回 false。</td>
</tr>
<tr>
<td>!=    不相等。用于比较两个数字，不相同则返回 true。</td>
<td style="text-align:right">[ $a != $b ] 返回 true。</td>
</tr>
</tbody>
</table>
<p>注意：条件表达式要放在方括号之间，并且要有空格，例如: [$a==$b] 是错误的，必须写成 [ $a == $b ]。</p>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>算术运算符实例如下：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

val=`expr $a + $b`
echo &quot;a + b : $val&quot;

val=`expr $a - $b`
echo &quot;a - b : $val&quot;

val=`expr $a \* $b`
echo &quot;a * b : $val&quot;

val=`expr $b / $a`
echo &quot;b / a : $val&quot;

val=`expr $b % $a`
echo &quot;b % a : $val&quot;

if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;a 不等于 b&quot;
fi
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>a + b : 30
a - b : -10
a * b : 200
b / a : 2
b % a : 0
a 不等于 b
</code></pre><p>注意：</p>
<ul>
<li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li>
<li>if…then…fi 是条件语句，后续将会讲解。</li>
<li>在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 “*” 不需要转义符号 “\” 。</li>
</ul>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td style="text-align:right">检测两个数是否相等，相等返回 true。</td>
<td style="text-align:center">[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td>-ne</td>
<td style="text-align:right">检测两个数是否相等，不相等返回 true。</td>
<td style="text-align:center">[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td>-gt</td>
<td style="text-align:right">检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td style="text-align:center">[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td>-lt</td>
<td style="text-align:right">检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td style="text-align:center">[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td>-ge</td>
<td style="text-align:right">检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td style="text-align:center">[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td>-le</td>
<td style="text-align:right">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td style="text-align:center">[ $a -le $b ] 返回 true。</td>
</tr>
</tbody>
</table>
<p>###实例<br>关系运算符实例如下：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

if [ $a -eq $b ]
then
   echo &quot;$a -eq $b : a 等于 b&quot;
else
   echo &quot;$a -eq $b: a 不等于 b&quot;
fi
if [ $a -ne $b ]
then
   echo &quot;$a -ne $b: a 不等于 b&quot;
else
   echo &quot;$a -ne $b : a 等于 b&quot;
fi
if [ $a -gt $b ]
then
   echo &quot;$a -gt $b: a 大于 b&quot;
else
   echo &quot;$a -gt $b: a 不大于 b&quot;
fi
if [ $a -lt $b ]
then
   echo &quot;$a -lt $b: a 小于 b&quot;
else
   echo &quot;$a -lt $b: a 不小于 b&quot;
fi
if [ $a -ge $b ]
then
   echo &quot;$a -ge $b: a 大于或等于 b&quot;
else
   echo &quot;$a -ge $b: a 小于 b&quot;
fi
if [ $a -le $b ]
then
   echo &quot;$a -le $b: a 小于或等于 b&quot;
else
   echo &quot;$a -le $b: a 大于 b&quot;
fi
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>10 -eq 20: a 不等于 b
10 -ne 20: a 不等于 b
10 -gt 20: a 不大于 b
10 -lt 20: a 小于 b
10 -ge 20: a 小于 b
10 -le 20: a 小于或等于 b
</code></pre><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td style="text-align:right">非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td style="text-align:center">[ ! false ] 返回 true。</td>
</tr>
<tr>
<td>-o</td>
<td style="text-align:right">或运算，有一个表达式为 true 则返回 true。    [ $a -lt 20 -o $b -gt 100 ]</td>
<td style="text-align:center">返回 true。</td>
</tr>
<tr>
<td>-a</td>
<td style="text-align:right">与运算，两个表达式都为 true 才返回 true。    [ $a -lt 20 -a $b -gt 100 ]</td>
<td style="text-align:center">返回 false。</td>
</tr>
</tbody>
</table>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>布尔运算符实例如下：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a != $b: a 等于 b&quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;
else
   echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;
else
   echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;
fi
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>10 != 20 : a 不等于 b
10 小于 100 且 20 大于 15 : 返回 true
10 小于 100 或 20 大于 100 : 返回 true
10 小于 5 或 20 大于 100 : 返回 false
</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td style="text-align:right">逻辑的 AND    [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</td>
<td style="text-align:center">返回 false</td>
</tr>
<tr>
<td>ll</td>
<td style="text-align:right">逻辑的 OR    [[ $a -lt 100 ll $b -gt 100 ]]</td>
<td style="text-align:center">返回 true</td>
</tr>
</tbody>
</table>
<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>逻辑运算符实例如下：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=10
b=20

if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &quot;返回 true&quot;
else
   echo &quot;返回 false&quot;
fi
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>返回 false
返回 true
</code></pre><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td style="text-align:right">检测两个字符串是否相等，相等返回 true。</td>
<td style="text-align:center">[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td style="text-align:right">检测两个字符串是否相等，不相等返回 true。</td>
<td style="text-align:center">[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td style="text-align:right">检测字符串长度是否为0，为0返回 true。</td>
<td style="text-align:center">[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td style="text-align:right">检测字符串长度是否为0，不为0返回 true。</td>
<td style="text-align:center">[ -n $a ] 返回 true。</td>
</tr>
<tr>
<td>str</td>
<td style="text-align:right">检测字符串是否为空，不为空返回 true。</td>
<td style="text-align:center">[ $a ] 返回 true。</td>
</tr>
</tbody>
</table>
<h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><p>字符串运算符实例如下：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

a=&quot;abc&quot;
b=&quot;efg&quot;

if [ $a = $b ]
then
   echo &quot;$a = $b : a 等于 b&quot;
else
   echo &quot;$a = $b: a 不等于 b&quot;
fi
if [ $a != $b ]
then
   echo &quot;$a != $b : a 不等于 b&quot;
else
   echo &quot;$a != $b: a 等于 b&quot;
fi
if [ -z $a ]
then
   echo &quot;-z $a : 字符串长度为 0&quot;
else
   echo &quot;-z $a : 字符串长度不为 0&quot;
fi
if [ -n $a ]
then
   echo &quot;-n $a : 字符串长度不为 0&quot;
else
   echo &quot;-n $a : 字符串长度为 0&quot;
fi
if [ $a ]
then
   echo &quot;$a : 字符串不为空&quot;
else
   echo &quot;$a : 字符串为空&quot;
fi
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>abc = efg: a 不等于 b
abc != efg : a 不等于 b
-z abc : 字符串长度不为 0
-n abc : 字符串长度不为 0
abc : 字符串不为空
</code></pre><h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p>
<p>属性检测描述如下：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th style="text-align:right">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b file</td>
<td style="text-align:right">检测文件是否是块设备文件，如果是，则返回 true。</td>
<td style="text-align:center">[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td style="text-align:right">检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td style="text-align:center">[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td style="text-align:right">检测文件是否是目录，如果是，则返回 true。</td>
<td style="text-align:center">[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td style="text-align:right">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td style="text-align:center">[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td style="text-align:right">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td style="text-align:center">[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td style="text-align:right">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td style="text-align:center">[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td style="text-align:right">检测文件是否是有名管道，如果是，则返回 true。</td>
<td style="text-align:center">[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td style="text-align:right">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td style="text-align:center">[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td style="text-align:right">检测文件是否可读，如果是，则返回 true。</td>
<td style="text-align:center">[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td style="text-align:right">检测文件是否可写，如果是，则返回 true。</td>
<td style="text-align:center">[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td style="text-align:right">检测文件是否可执行，如果是，则返回 true。</td>
<td style="text-align:center">[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td style="text-align:right">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td style="text-align:center">[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td style="text-align:right">检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td style="text-align:center">[ -e $file ] 返回 true。</td>
</tr>
</tbody>
</table>
<h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h3><p>变量 file 表示文件”/var/www/runoob/test.sh”，它的大小为100字节，具有 rwx 权限。下面的代码，将检测该文件的各种属性：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

file=&quot;/var/www/runoob/test.sh&quot;
if [ -r $file ]
then
   echo &quot;文件可读&quot;
else
   echo &quot;文件不可读&quot;
fi
if [ -w $file ]
then
   echo &quot;文件可写&quot;
else
   echo &quot;文件不可写&quot;
fi
if [ -x $file ]
then
   echo &quot;文件可执行&quot;
else
   echo &quot;文件不可执行&quot;
fi
if [ -f $file ]
then
   echo &quot;文件为普通文件&quot;
else
   echo &quot;文件为特殊文件&quot;
fi
if [ -d $file ]
then
   echo &quot;文件是个目录&quot;
else
   echo &quot;文件不是个目录&quot;
fi
if [ -s $file ]
then
   echo &quot;文件不为空&quot;
else
   echo &quot;文件为空&quot;
fi
if [ -e $file ]
then
   echo &quot;文件存在&quot;
else
   echo &quot;文件不存在&quot;
fi
</code></pre><p>执行脚本，输出结果如下所示：</p>
<pre><code>文件可读
文件可写
文件可执行
文件为普通文件
文件不是个目录
文件不为空
文件存在
</code></pre><h1 id="六：Shell-test-命令"><a href="#六：Shell-test-命令" class="headerlink" title="六：Shell test 命令"></a>六：Shell test 命令</h1><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</p>
<h2 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-eq</td>
<td style="text-align:center">等于则为真</td>
</tr>
<tr>
<td>-ne</td>
<td style="text-align:center">不等于则为真</td>
</tr>
<tr>
<td>-gt</td>
<td style="text-align:center">大于则为真</td>
</tr>
<tr>
<td>-ge</td>
<td style="text-align:center">大于等于则为真</td>
</tr>
<tr>
<td>-lt</td>
<td style="text-align:center">小于则为真</td>
</tr>
<tr>
<td>-le</td>
<td style="text-align:center">小于等于则为真</td>
</tr>
</tbody>
</table>
<p>实例演示：</p>
<pre><code>num1=100
num2=100
if test $[num1] -eq $[num2]
then
    echo &apos;两个数相等！&apos;
else
    echo &apos;两个数不相等！&apos;
fi
</code></pre><p>输出结果：</p>
<pre><code>两个数相等！
</code></pre><p>代码中的 [] 执行基本的算数运算，如：</p>
<pre><code>#!/bin/bash

a=5
b=6

result=$[a+b] # 注意等号两边不能有空格
echo &quot;result 为： $result&quot;
</code></pre><p>结果为:</p>
<pre><code>result 为： 11
</code></pre><h2 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td style="text-align:center">等于则为真</td>
</tr>
<tr>
<td>!=</td>
<td style="text-align:center">不相等则为真</td>
</tr>
<tr>
<td>-z 字符串</td>
<td style="text-align:center">字符串的长度为零则为真</td>
</tr>
<tr>
<td>-n 字符串</td>
<td style="text-align:center">字符串的长度不为零则为真</td>
</tr>
</tbody>
</table>
<h3 id="实例演示："><a href="#实例演示：" class="headerlink" title="实例演示："></a>实例演示：</h3><pre><code>num1=&quot;ru1noob&quot;
num2=&quot;runoob&quot;
if test $num1 = $num2
then
    echo &apos;两个字符串相等!&apos;
else
    echo &apos;两个字符串不相等!&apos;
fi
</code></pre><p>输出结果：</p>
<pre><code>两个字符串不相等!
</code></pre><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-e 文件名</td>
<td style="text-align:center">如果文件存在则为真</td>
</tr>
<tr>
<td>-r 文件名</td>
<td style="text-align:center">如果文件存在且可读则为真</td>
</tr>
<tr>
<td>-w 文件名</td>
<td style="text-align:center">如果文件存在且可写则为真</td>
</tr>
<tr>
<td>-x 文件名</td>
<td style="text-align:center">如果文件存在且可执行则为真</td>
</tr>
<tr>
<td>-s 文件名</td>
<td style="text-align:center">如果文件存在且至少有一个字符则为真</td>
</tr>
<tr>
<td>-d 文件名</td>
<td style="text-align:center">如果文件存在且为目录则为真</td>
</tr>
<tr>
<td>-f 文件名</td>
<td style="text-align:center">如果文件存在且为普通文件则为真</td>
</tr>
<tr>
<td>-c 文件名</td>
<td style="text-align:center">如果文件存在且为字符型特殊文件则为真</td>
</tr>
<tr>
<td>-b 文件名</td>
<td style="text-align:center">如果文件存在且为块特殊文件则为真</td>
</tr>
</tbody>
</table>
<h3 id="实例演示：-1"><a href="#实例演示：-1" class="headerlink" title="实例演示："></a>实例演示：</h3><pre><code>cd /bin
if test -e ./bash
then
    echo &apos;文件已存在!&apos;
else
    echo &apos;文件不存在!&apos;
fi
</code></pre><p>输出结果：</p>
<pre><code>文件已存在!
</code></pre><p>另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：”!”最高，”-a”次之，”-o”最低。例如：</p>
<pre><code>cd /bin
if test -e ./notFile -o -e ./bash
then
    echo &apos;至少有一个文件存在!&apos;
else
    echo &apos;两个文件都不存在&apos;
fi
</code></pre><p>输出结果：</p>
<pre><code>有一个文件存在!
</code></pre><h1 id="七：Shell-流程控制"><a href="#七：Shell-流程控制" class="headerlink" title="七：Shell 流程控制"></a>七：Shell 流程控制</h1><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)：</p>
<pre><code>&lt;?php
if (isset($_GET[&quot;q&quot;])) {
    search(q);
}
else {
    // 不做任何事情
}
</code></pre><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p>
<h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if 语句语法格式：</p>
<pre><code>if condition
then
    command1 
    command2
    ...
    commandN 
fi
</code></pre><p>写成一行（适用于终端命令提示符）：</p>
<pre><code>if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi
</code></pre><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的。</p>
<h3 id="if-else-1"><a href="#if-else-1" class="headerlink" title="if else"></a>if else</h3><p>if else 语法格式：</p>
<pre><code>if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
</code></pre><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h3><p>if else-if else 语法格式：</p>
<pre><code>if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
</code></pre><p>以下实例判断两个变量是否相等：</p>
<pre><code>a=10
b=20
if [ $a == $b ]
then
   echo &quot;a 等于 b&quot;
elif [ $a -gt $b ]
then
   echo &quot;a 大于 b&quot;
elif [ $a -lt $b ]
then
   echo &quot;a 小于 b&quot;
else
   echo &quot;没有符合的条件&quot;
fi
</code></pre><p>输出结果：</p>
<pre><code>a 小于 b
</code></pre><p>if else语句经常与test命令结合使用，如下所示：</p>
<pre><code>num1=$[2*3]
num2=$[1+5]
if test $[num1] -eq $[num2]
then
    echo &apos;两个数字相等!&apos;
else
    echo &apos;两个数字不相等!&apos;
fi
</code></pre><p>输出结果：</p>
<pre><code>两个数字相等!
</code></pre><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>与其他编程语言类似，Shell支持for循环。</p>
<p>for循环一般格式为：</p>
<pre><code>for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
</code></pre><p>写成一行：</p>
<pre><code>for var in item1 item2 ... itemN; do command1; command2… done;
</code></pre><p>当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。</p>
<p>in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p>
<p>例如，顺序输出当前列表中的数字：</p>
<pre><code>for loop in 1 2 3 4 5
do
    echo &quot;The value is: $loop&quot;
done
</code></pre><p>输出结果：</p>
<pre><code>The value is: 1
The value is: 2
The value is: 3
The value is: 4
The value is: 5
</code></pre><p>顺序输出字符串中的字符：</p>
<pre><code>for str in &apos;This is a string&apos;
do
    echo $str
done
</code></pre><p>输出结果：</p>
<pre><code>This is a string
</code></pre><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p>
<pre><code>while condition
do
    command
done
</code></pre><p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</p>
<pre><code>#!/bin/sh
int=1
while(( $int&lt;=5 ))
do
    echo $int
    let &quot;int++&quot;
done
</code></pre><p>运行脚本，输出：</p>
<pre><code>1
2
3
4
5
</code></pre><p>使用中使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：Bash let 命令</p>
<p>。<br>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<ctrl-d>结束循环。</ctrl-d></p>
<pre><code>echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;
echo -n &apos;输入你最喜欢的网站名: &apos;
while read FILM
do
    echo &quot;是的！$FILM 是一个好网站&quot;
done
</code></pre><p>运行脚本，输出类似下面：</p>
<pre><code>按下 &lt;CTRL-D&gt; 退出
输入你最喜欢的网站名:菜鸟教程
是的！菜鸟教程 是一个好网站
</code></pre><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>无限循环语法格式：</p>
<pre><code>while :
do
    command
done
</code></pre><p>或者</p>
<pre><code>while true
do
    command
done
</code></pre><p>或者</p>
<pre><code>for (( ; ; ))
</code></pre><h2 id="until-循环"><a href="#until-循环" class="headerlink" title="until 循环"></a>until 循环</h2><p>until循环执行一系列命令直至条件为真时停止。</p>
<p>until循环与while循环在处理方式上刚好相反。</p>
<p>一般while循环优于until循环，但在某些时候—也只是极少数情况下，until循环更加有用。</p>
<p>until 语法格式:</p>
<pre><code>until condition
do
    command
done
</code></pre><p>条件可为任意测试条件，测试发生在循环末尾，因此循环至少执行一次—请注意这一点。</p>
<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：</p>
<pre><code>case 值 in
模式1)
    command1
    command2
    ...
    commandN
    ;;
模式2）
    command1
    command2
    ...
    commandN
    ;;
esac
</code></pre><p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。</p>
<p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p>
<p>下面的脚本提示输入1到4，与每一种模式进行匹配：</p>
<pre><code>echo &apos;输入 1 到 4 之间的数字:&apos;
echo &apos;你输入的数字为:&apos;
read aNum
case $aNum in
    1)  echo &apos;你选择了 1&apos;
    ;;
    2)  echo &apos;你选择了 2&apos;
    ;;
    3)  echo &apos;你选择了 3&apos;
    ;;
    4)  echo &apos;你选择了 4&apos;
    ;;
    *)  echo &apos;你没有输入 1 到 4 之间的数字&apos;
    ;;
esac
</code></pre><p>输入不同的内容，会有不同的结果，例如：</p>
<pre><code>输入 1 到 4 之间的数字:
你输入的数字为:
3
你选择了 3
</code></pre><h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p>
<h3 id="break命令"><a href="#break命令" class="headerlink" title="break命令"></a>break命令</h3><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p>
<p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</p>
<pre><code>#!/bin/bash
while :
do
    echo -n &quot;输入 1 到 5 之间的数字:&quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;
            break
        ;;
    esac
done
</code></pre><p>执行以上代码，输出结果为：</p>
<pre><code>输入 1 到 5 之间的数字:3
你输入的数字为 3!
输入 1 到 5 之间的数字:7
你输入的数字不是 1 到 5 之间的! 游戏结束
</code></pre><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p>
<p>对上面的例子进行修改：</p>
<pre><code>#!/bin/bash
while :
do
    echo -n &quot;输入 1 到 5 之间的数字: &quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;
            continue
            echo &quot;游戏结束&quot;
        ;;
    esac
done
</code></pre><p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 echo “Game is over!” 永远不会被执行。</p>
<h3 id="esac"><a href="#esac" class="headerlink" title="esac"></a>esac</h3><p>case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，每个case分支用右圆括号，用两个分号表示break。</p>
<h1 id="八：Shell-函数"><a href="#八：Shell-函数" class="headerlink" title="八：Shell 函数"></a>八：Shell 函数</h1><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p>
<p>shell中函数的定义格式如下：</p>
<pre><code>[ function ] funname [()]

{

    action;

    [return int;]

}
</code></pre><p>说明：</p>
<p>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。<br>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255<br>下面的例子定义了一个函数并进行调用：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

demoFun(){
    echo &quot;这是我的第一个 shell 函数!&quot;
}
echo &quot;-----函数开始执行-----&quot;
demoFun
echo &quot;-----函数执行完毕-----&quot;
</code></pre><p>输出结果：</p>
<pre><code>-----函数开始执行-----
这是我的第一个 shell 函数!
-----函数执行完毕-----
</code></pre><p>下面定义一个带有return语句的函数：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

funWithReturn(){
    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;
    echo &quot;输入第一个数字: &quot;
    read aNum
    echo &quot;输入第二个数字: &quot;
    read anotherNum
    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;
    return $(($aNum+$anotherNum))
}
funWithReturn
echo &quot;输入的两个数字之和为 $? !&quot;
</code></pre><p>输出类似下面：</p>
<pre><code>这个函数会对输入的两个数字进行相加运算...
输入第一个数字: 
1
输入第二个数字: 
2
两个数字分别为 1 和 2 !
输入的两个数字之和为 3 !
</code></pre><p>函数返回值在调用该函数后通过 $? 来获得。</p>
<p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…</p>
<p>带参数的函数示例：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

funWithParam(){
    echo &quot;第一个参数为 $1 !&quot;
    echo &quot;第二个参数为 $2 !&quot;
    echo &quot;第十个参数为 $10 !&quot;
    echo &quot;第十个参数为 ${10} !&quot;
    echo &quot;第十一个参数为 ${11} !&quot;
    echo &quot;参数总数有 $# 个!&quot;
    echo &quot;作为一个字符串输出所有参数 $* !&quot;
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
</code></pre><p>输出结果：</p>
<pre><code>第一个参数为 1 !
第二个参数为 2 !
第十个参数为 10 !
第十个参数为 34 !
第十一个参数为 73 !
参数总数有 11 个!
作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !
</code></pre><p>注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。</p>
<p>另外，还有几个特殊字符用来处理参数：</p>
<table>
<thead>
<tr>
<th>参数处理</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$#</td>
<td style="text-align:center">传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td style="text-align:center">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td>$$</td>
<td style="text-align:center">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td style="text-align:center">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td style="text-align:center">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td>$-</td>
<td style="text-align:center">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td style="text-align:center">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody>
</table>
<h1 id="九：Shell-输入-输出重定向"><a href="#九：Shell-输入-输出重定向" class="headerlink" title="九：Shell 输入/输出重定向"></a>九：Shell 输入/输出重定向</h1><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回​​到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p>
<p>重定向命令列表如下：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>command &gt; file</td>
<td style="text-align:center">将输出重定向到 file。</td>
</tr>
<tr>
<td>command &lt; file</td>
<td style="text-align:center">将输入重定向到 file。</td>
</tr>
<tr>
<td>command &gt;&gt; file</td>
<td style="text-align:center">将输出以追加的方式重定向到 file。</td>
</tr>
<tr>
<td>n &gt; file</td>
<td style="text-align:center">将文件描述符为 n 的文件重定向到 file。</td>
</tr>
<tr>
<td>n &gt;&gt; file</td>
<td style="text-align:center">将文件描述符为 n 的文件以追加的方式重定向到 file。</td>
</tr>
<tr>
<td>n &gt;&amp; m</td>
<td style="text-align:center">将输出文件 m 和 n 合并。</td>
</tr>
<tr>
<td>n &lt;&amp; m</td>
<td style="text-align:center">将输入文件 m 和 n 合并。</td>
</tr>
<tr>
<td>&lt;&lt; tag</td>
<td style="text-align:center">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td>
</tr>
</tbody>
</table>
<p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
<h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p>
<pre><code>command1 &gt; file1
</code></pre><p>上面这个命令执行command1然后将输出的内容存入file1。</p>
<p>注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</p>
<h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):</p>
<pre><code>$ who &gt; users
</code></pre><p>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。</p>
<p>你可以使用 cat 命令查看文件内容：</p>
<pre><code>$ cat users
_mbsetupuser console  Oct 31 17:35 
tianqixin    console  Oct 31 17:35 
tianqixin    ttys000  Dec  1 11:33 
</code></pre><p>输出重定向会覆盖文件内容，请看下面的例子：</p>
<pre><code>$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt; users
$ cat users
菜鸟教程：www.runoob.com
$
</code></pre><p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p>
<pre><code>$ echo &quot;菜鸟教程：www.runoob.com&quot; &gt;&gt; users
$ cat users
菜鸟教程：www.runoob.com
菜鸟教程：www.runoob.com
$
</code></pre><h2 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p>
<pre><code>command1 &lt; file1
</code></pre><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p>
<p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p>
<h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h3><p>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</p>
<pre><code>$ wc -l users
       2 users
</code></pre><p>也可以将输入重定向到 users 文件：</p>
<pre><code>$  wc -l &lt; users
       2 
</code></pre><p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p>
<pre><code>command1 &lt; infile &gt; outfile
</code></pre><p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p>
<h3 id="重定向深入讲解"><a href="#重定向深入讲解" class="headerlink" title="重定向深入讲解"></a>重定向深入讲解</h3><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p>
<ul>
<li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li>
<li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li>
<li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li>
</ul>
<p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p>
<p>如果希望 stderr 重定向到 file，可以这样写：</p>
<pre><code>$ command 2 &gt; file
</code></pre><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p>
<pre><code>$ command 2 &gt;&gt; file
</code></pre><p>2 表示标准错误文件(stderr)。</p>
<p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p>
<pre><code>$ command &gt; file 2&gt;&amp;1
或者

$ command &gt;&gt; file 2&gt;&amp;1
</code></pre><p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p>
<pre><code>$ command &lt; file1 &gt;file2
</code></pre><p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p>
<h2 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h2><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p>
<p>它的基本的形式如下：</p>
<pre><code>command &lt;&lt; delimiter
    document
delimiter
</code></pre><p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<p>注意：</p>
<ul>
<li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li>
<li>开始的delimiter前后的空格会被忽略掉。</li>
</ul>
<h3 id="实例-8"><a href="#实例-8" class="headerlink" title="实例"></a>实例</h3><p>在命令行中通过 wc -l 命令计算 Here Document 的行数：</p>
<pre><code>$ wc -l &lt;&lt; EOF
    欢迎来到
    菜鸟教程
    www.runoob.com
EOF
3          # 输出结果为 3 行
$
</code></pre><p>我们也可以将 Here Document 用在脚本中，例如：</p>
<pre><code>#!/bin/bash
# author:菜鸟教程
# url:www.runoob.com

cat &lt;&lt; EOF
欢迎来到
菜鸟教程
www.runoob.com
EOF
</code></pre><p>执行以上脚本，输出结果：</p>
<pre><code>欢迎来到
菜鸟教程
www.runoob.com
</code></pre><h3 id="dev-null-文件"><a href="#dev-null-文件" class="headerlink" title="/dev/null 文件"></a>/dev/null 文件</h3><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p>
<pre><code>$ command &gt; /dev/null
</code></pre><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p>
<p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p>
<pre><code>$ command &gt; /dev/null 2&gt;&amp;1
</code></pre><p>注意：0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Shell脚本,就是利用Shell的命令解释的功能，对一个纯文本的文件进行解析，然后执行这些功能，也可以说Shell脚本就是一系列命令的集合。&lt;br&gt;Shell可以直接使用在win/Unix/Linux上面，并且可以调用大量系统内部的功能来解释执行程序，如果熟练掌握Shel
    
    </summary>
    
      <category term="shell" scheme="http://wangyuanjun.cn/categories/shell/"/>
    
    
      <category term="shell" scheme="http://wangyuanjun.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>MySQL读写分离详解与实践</title>
    <link href="http://wangyuanjun.cn/2018/02/11/MySQL%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://wangyuanjun.cn/2018/02/11/MySQL读写分离详解与实践/</id>
    <published>2018-02-11T03:38:51.000Z</published>
    <updated>2018-02-11T06:59:32.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：mysql读写分离原理"><a href="#一：mysql读写分离原理" class="headerlink" title="一：mysql读写分离原理"></a>一：mysql读写分离原理</h1><p>MySQL的主从复制和MySQL的读写分离两者有着紧密联系，首先部署主从复制，只有主从复制完了，才能在此基础上进行数据的读写分离。<br>简单来说，读写分离就是只在主服务器上写，只在从服务器上读，基本的原理是让主数据库处理事务性操作，而从数据库处理非事务性操作，然后再采用主从复制来把master上的事务性操作同步到slave数据库中。</p>
<p>1.基于程序代码内部实现<br>在代码中根据select,insert进行路由分类，这类方法也是目前生产环境应用最广泛的，优点是性能好，因为在程序代码中实现，不需要曾加额外的设备作为硬件开支，缺点是需要开发人员来实现，运维人员无从下手。<br>2.基于中间代理层实现<br>代理一般位于客户端和服务器之间，代理服务器接到客户端请求后通过判断后转发到后端数据库，有两个代表性程序。</p>
<p>（1）mysql-proxy 为mysql开源项目，通过其自带的lua脚本进行SQL判断，虽然是mysql的官方产品，但是mysql官方不建议将其应用到生产环境</p>
<p>（2）Amoeba （变形虫）由陈思儒开发，曾就职与阿里巴巴，该程序由java语言进行开发，阿里巴巴将其应用于生成环境，它不支持事物和存储过程</p>
<p>通过程序代码实现mysql读写分离自然是一个不错的选择，但是并不是所有的应用都适合在程序代码中实现读写分离，像一些大型复杂的java应用，如果在程序代码中实现读写分离对代码改动就较大，像这种应用一般会考虑使用代理层来实现。</p>
<h1 id="二：基于-Amoeba-实现读写分离"><a href="#二：基于-Amoeba-实现读写分离" class="headerlink" title="二：基于 Amoeba 实现读写分离"></a>二：基于 Amoeba 实现读写分离</h1><p><img src="/2018/02/11/MySQL读写分离详解与实践/amoeba.png" alt="amoeba"></p>
<h2 id="2-1-环境搭建"><a href="#2-1-环境搭建" class="headerlink" title="2.1 环境搭建"></a>2.1 环境搭建</h2><p>amoeba:192.168.2.203</p>
<p>masterDB：192.168.2.204 </p>
<p>slaveDB：192.168.2.205<br>以上系统全为centos6.8</p>
<p>Amoeba框架是居于JDK1.5开发的，采用了JDK1.5的特性，所以还需要安装java环境，建议使用javaSE1.5以上的JDK版本</p>
<h2 id="2-2-安装java环境"><a href="#2-2-安装java环境" class="headerlink" title="2.2 安装java环境"></a>2.2 安装java环境</h2><p>先去官网下载：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<h3 id="2-2-1-安装"><a href="#2-2-1-安装" class="headerlink" title="2.2.1 安装"></a>2.2.1 安装</h3><pre><code>[root@bogon src]# rpm -ivh jdk-8u111-linux-x64.rpm
Preparing...                ########################################### [100%]
   1:jdk1.8.0_111           ########################################### [100%]
Unpacking JAR files...
    tools.jar...
    plugin.jar...
    javaws.jar...
    deploy.jar...
    rt.jar...
    jsse.jar...
    charsets.jar...
    localedata.jar...
</code></pre><h3 id="2-2-2-设置java环境变量"><a href="#2-2-2-设置java环境变量" class="headerlink" title="2.2.2 设置java环境变量"></a>2.2.2 设置java环境变量</h3><pre><code>[root@bogon src]# vim /etc/profile

#set java environment
JAVA_HOME=/usr/java/jdk1.8.0_111
JRE_HOME=/usr/java/jdk1.8.0_111/jre
CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export JAVA_HOME JRE_HOME CLASS_PATH PATH
[root@bogon amoeba]# source /etc/profile
</code></pre><h3 id="2-2-3-测试是否安装成功"><a href="#2-2-3-测试是否安装成功" class="headerlink" title="2.2.3 测试是否安装成功"></a>2.2.3 测试是否安装成功</h3><pre><code>[root@bogon src]# java -version
java version &quot;1.8.0_111&quot;
Java(TM) SE Runtime Environment (build 1.8.0_111-b14)
Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode)
</code></pre><h2 id="2-3-安装Amoeba"><a href="#2-3-安装Amoeba" class="headerlink" title="2.3 安装Amoeba"></a>2.3 安装Amoeba</h2><p>可以从<a href="https://sourceforge.net/projects/amoeba/下载最新版本的Amoeba，我这里下载的是amoeba-mysql-3.0.5-RC-distribution.zip。Amoeba安装非常简单，直接解压即可使用，这里将Amoeba解压到/usr/local/amoeba目录下，这样就安装完成了" target="_blank" rel="external">https://sourceforge.net/projects/amoeba/下载最新版本的Amoeba，我这里下载的是amoeba-mysql-3.0.5-RC-distribution.zip。Amoeba安装非常简单，直接解压即可使用，这里将Amoeba解压到/usr/local/amoeba目录下，这样就安装完成了</a></p>
<pre><code>[root@bogon amoeba]# pwd
/usr/local/amoeba
  [root@bogon amoeba]# ll
  总用量 20
  drwxrwxrwx. 2 root root 4096 7月 5 2013 benchmark
  drwxrwxrwx. 2 root root 4096 7月 5 2013 bin
  drwxrwxrwx. 2 root root 4096 7月 5 2013 conf
  -rwxrwxrwx. 1 root root 728 7月 5 2013 jvm.properties
  drwxrwxrwx. 2 root root 4096 7月 5 2013 lib
</code></pre><h2 id="2-4-配置Amoeba"><a href="#2-4-配置Amoeba" class="headerlink" title="2.4 配置Amoeba"></a>2.4 配置Amoeba</h2><p>Amoeba的配置文件在本环境下位于/usr/local/amoeba/conf目录下。配置文件比较多，但是仅仅使用读写分离功能，只需配置两个文件即可，分别是dbServers.xml和amoeba.xml，如果需要配置ip访问控制，还需要修改access_list.conf文件，下面首先介绍dbServers.xml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">[root@bogon amoeba]# cat conf/dbServers.xml </div><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot;?&gt;</div><div class="line"></div><div class="line">&lt;!DOCTYPE amoeba:dbServers SYSTEM &quot;dbserver.dtd&quot;&gt;</div><div class="line">&lt;amoeba:dbServers xmlns:amoeba=&quot;http://amoeba.meidusa.com/&quot;&gt;</div><div class="line"></div><div class="line">        &lt;!-- </div><div class="line">            Each dbServer needs to be configured into a Pool,</div><div class="line">            If you need to configure multiple dbServer with load balancing that can be simplified by the following configuration:</div><div class="line">             add attribute with name virtual = &quot;true&quot; in dbServer, but the configuration does not allow the element with name factoryConfig</div><div class="line">             such as &apos;multiPool&apos; dbServer   </div><div class="line">        --&gt;</div><div class="line">        </div><div class="line">    &lt;dbServer name=&quot;abstractServer&quot; abstractive=&quot;true&quot;&gt;</div><div class="line">        &lt;factoryConfig class=&quot;com.meidusa.amoeba.mysql.net.MysqlServerConnectionFactory&quot;&gt;</div><div class="line">            &lt;property name=&quot;connectionManager&quot;&gt;$&#123;defaultManager&#125;&lt;/property&gt;</div><div class="line">            &lt;property name=&quot;sendBufferSize&quot;&gt;64&lt;/property&gt;</div><div class="line">            &lt;property name=&quot;receiveBufferSize&quot;&gt;128&lt;/property&gt;</div><div class="line">                </div><div class="line">            &lt;!-- mysql port --&gt;</div><div class="line">            &lt;property name=&quot;port&quot;&gt;3306&lt;/property&gt;　　#设置Amoeba要连接的mysql数据库的端口，默认是3306</div><div class="line">            </div><div class="line">            &lt;!-- mysql schema --&gt;</div><div class="line">            &lt;property name=&quot;schema&quot;&gt;testdb&lt;/property&gt;　　#设置缺省的数据库，当连接amoeba时，操作表必须显式的指定数据库名，即采用dbname.tablename的方式，不支持 use dbname指定缺省库，因为操作会调度到各个后端dbserver</div><div class="line">            </div><div class="line">            &lt;!-- mysql user --&gt;</div><div class="line">            &lt;property name=&quot;user&quot;&gt;test1&lt;/property&gt;　　#设置amoeba连接后端数据库服务器的账号和密码，因此需要在所有后端数据库上创建该用户，并授权amoeba服务器可连接</div><div class="line">            </div><div class="line">            &lt;property name=&quot;password&quot;&gt;111111&lt;/property&gt;</div><div class="line">        &lt;/factoryConfig&gt;</div><div class="line"></div><div class="line">        &lt;poolConfig class=&quot;com.meidusa.toolkit.common.poolable.PoolableObjectPool&quot;&gt;</div><div class="line">            &lt;property name=&quot;maxActive&quot;&gt;500&lt;/property&gt;　　#最大连接数，默认500</div><div class="line">            &lt;property name=&quot;maxIdle&quot;&gt;500&lt;/property&gt;　　　　#最大空闲连接数</div><div class="line">            &lt;property name=&quot;minIdle&quot;&gt;1&lt;/property&gt;　　　　#最新空闲连接数</div><div class="line">            &lt;property name=&quot;minEvictableIdleTimeMillis&quot;&gt;600000&lt;/property&gt;</div><div class="line">            &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot;&gt;600000&lt;/property&gt;</div><div class="line">            &lt;property name=&quot;testOnBorrow&quot;&gt;true&lt;/property&gt;</div><div class="line">            &lt;property name=&quot;testOnReturn&quot;&gt;true&lt;/property&gt;</div><div class="line">            &lt;property name=&quot;testWhileIdle&quot;&gt;true&lt;/property&gt;</div><div class="line">        &lt;/poolConfig&gt;</div><div class="line">    &lt;/dbServer&gt;</div><div class="line"></div><div class="line">    &lt;dbServer name=&quot;writedb&quot;  parent=&quot;abstractServer&quot;&gt;　　#设置一个后端可写的dbServer，这里定义为writedb，这个名字可以任意命名，后面还会用到</div><div class="line">        &lt;factoryConfig&gt;</div><div class="line">            &lt;!-- mysql ip --&gt;</div><div class="line">            &lt;property name=&quot;ipAddress&quot;&gt;192.168.2.204&lt;/property&gt; #设置后端可写dbserver</div><div class="line">        &lt;/factoryConfig&gt;</div><div class="line">    &lt;/dbServer&gt;</div><div class="line">    </div><div class="line">    &lt;dbServer name=&quot;slave&quot;  parent=&quot;abstractServer&quot;&gt;　　#设置后端可读dbserver</div><div class="line">        &lt;factoryConfig&gt;</div><div class="line">            &lt;!-- mysql ip --&gt;</div><div class="line">            &lt;property name=&quot;ipAddress&quot;&gt;192.168.2.205&lt;/property&gt;</div><div class="line">        &lt;/factoryConfig&gt;</div><div class="line">    &lt;/dbServer&gt;</div><div class="line">    </div><div class="line">    &lt;dbServer name=&quot;myslave&quot; virtual=&quot;true&quot;&gt;　　#设置定义一个虚拟的dbserver，实际上相当于一个dbserver组，这里将可读的数据库ip统一放到一个组中，将这个组的名字命名为myslave</div><div class="line">        &lt;poolConfig class=&quot;com.meidusa.amoeba.server.MultipleServerPool&quot;&gt;</div><div class="line">            &lt;!-- Load balancing strategy: 1=ROUNDROBIN , 2=WEIGHTBASED , 3=HA--&gt;</div><div class="line">            &lt;property name=&quot;loadbalance&quot;&gt;1&lt;/property&gt;　　#选择调度算法，1表示复制均衡，2表示权重，3表示HA， 这里选择1</div><div class="line">            </div><div class="line">            &lt;!-- Separated by commas,such as: server1,server2,server1 --&gt;</div><div class="line">            &lt;property name=&quot;poolNames&quot;&gt;slave&lt;/property&gt;　　#myslave组成员</div><div class="line">        &lt;/poolConfig&gt;</div><div class="line">    &lt;/dbServer&gt;</div><div class="line">        </div><div class="line">&lt;/amoeba:dbServers&gt;</div></pre></td></tr></table></figure>
<p>另一个配置文件amoeba.xml</p>
<pre><code>[root@bogon amoeba]# cat conf/amoeba.xml 
&lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot;?&gt;

&lt;!DOCTYPE amoeba:configuration SYSTEM &quot;amoeba.dtd&quot;&gt;
&lt;amoeba:configuration xmlns:amoeba=&quot;http://amoeba.meidusa.com/&quot;&gt;

    &lt;proxy&gt;

        &lt;!-- service class must implements com.meidusa.amoeba.service.Service --&gt;
        &lt;service name=&quot;Amoeba for Mysql&quot; class=&quot;com.meidusa.amoeba.mysql.server.MySQLService&quot;&gt;
            &lt;!-- port --&gt;
            &lt;property name=&quot;port&quot;&gt;8066&lt;/property&gt;　　　　#设置amoeba监听的端口，默认是8066

            &lt;!-- bind ipAddress --&gt;　　　　#下面配置监听的接口，如果不设置，默认监听所以的IP
            &lt;!-- 
            &lt;property name=&quot;ipAddress&quot;&gt;127.0.0.1&lt;/property&gt;
             --&gt;

            &lt;property name=&quot;connectionFactory&quot;&gt;
                &lt;bean class=&quot;com.meidusa.amoeba.mysql.net.MysqlClientConnectionFactory&quot;&gt;
                    &lt;property name=&quot;sendBufferSize&quot;&gt;128&lt;/property&gt;
                    &lt;property name=&quot;receiveBufferSize&quot;&gt;64&lt;/property&gt;
                &lt;/bean&gt;
            &lt;/property&gt;

            &lt;property name=&quot;authenticateProvider&quot;&gt;
                &lt;bean class=&quot;com.meidusa.amoeba.mysql.server.MysqlClientAuthenticator&quot;&gt;


# 提供客户端连接amoeba时需要使用这里设定的账号 (这里的账号密码和amoeba连接后端数据库服务器的密码无关)

                    &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;　　　　


                    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;

                    &lt;property name=&quot;filter&quot;&gt;
                        &lt;bean class=&quot;com.meidusa.toolkit.net.authenticate.server.IPAccessController&quot;&gt;
                            &lt;property name=&quot;ipFile&quot;&gt;${amoeba.home}/conf/access_list.conf&lt;/property&gt;
                        &lt;/bean&gt;
                    &lt;/property&gt;
                &lt;/bean&gt;
            &lt;/property&gt;

        &lt;/service&gt;

        &lt;runtime class=&quot;com.meidusa.amoeba.mysql.context.MysqlRuntimeContext&quot;&gt;

            &lt;!-- proxy server client process thread size --&gt;
            &lt;property name=&quot;executeThreadSize&quot;&gt;128&lt;/property&gt;

            &lt;!-- per connection cache prepared statement size  --&gt;
            &lt;property name=&quot;statementCacheSize&quot;&gt;500&lt;/property&gt;

            &lt;!-- default charset --&gt;
            &lt;property name=&quot;serverCharset&quot;&gt;utf8&lt;/property&gt;

            &lt;!-- query timeout( default: 60 second , TimeUnit:second) --&gt;
            &lt;property name=&quot;queryTimeout&quot;&gt;60&lt;/property&gt;
        &lt;/runtime&gt;

    &lt;/proxy&gt;

    &lt;!-- 
        Each ConnectionManager will start as thread
        manager responsible for the Connection IO read , Death Detection
    --&gt;
    &lt;connectionManagerList&gt;
        &lt;connectionManager name=&quot;defaultManager&quot; class=&quot;com.meidusa.toolkit.net.MultiConnectionManagerWrapper&quot;&gt;
            &lt;property name=&quot;subManagerClassName&quot;&gt;com.meidusa.toolkit.net.AuthingableConnectionManager&lt;/property&gt;
        &lt;/connectionManager&gt;
    &lt;/connectionManagerList&gt;

        &lt;!-- default using file loader --&gt;
    &lt;dbServerLoader class=&quot;com.meidusa.amoeba.context.DBServerConfigFileLoader&quot;&gt;
        &lt;property name=&quot;configFile&quot;&gt;${amoeba.home}/conf/dbServers.xml&lt;/property&gt;
    &lt;/dbServerLoader&gt;

    &lt;queryRouter class=&quot;com.meidusa.amoeba.mysql.parser.MysqlQueryRouter&quot;&gt;
        &lt;property name=&quot;ruleLoader&quot;&gt;
            &lt;bean class=&quot;com.meidusa.amoeba.route.TableRuleFileLoader&quot;&gt;
                &lt;property name=&quot;ruleFile&quot;&gt;${amoeba.home}/conf/rule.xml&lt;/property&gt;
                &lt;property name=&quot;functionFile&quot;&gt;${amoeba.home}/conf/ruleFunctionMap.xml&lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name=&quot;sqlFunctionFile&quot;&gt;${amoeba.home}/conf/functionMap.xml&lt;/property&gt;
        &lt;property name=&quot;LRUMapSize&quot;&gt;1500&lt;/property&gt;
        &lt;property name=&quot;defaultPool&quot;&gt;writedb&lt;/property&gt;　　#设置amoeba默认的池，这里设置为writedb


        &lt;property name=&quot;writePool&quot;&gt;writedb&lt;/property&gt;　　#这两个选项默认是注销掉的，需要取消注释，这里用来指定前面定义好的俩个读写池
        &lt;property name=&quot;readPool&quot;&gt;myslave&lt;/property&gt;　　 #

        &lt;property name=&quot;needParse&quot;&gt;true&lt;/property&gt;
    &lt;/queryRouter&gt;
&lt;/amoeba:configuration&gt;
</code></pre><h2 id="2-5-在masterdb上创建数据库testdb"><a href="#2-5-在masterdb上创建数据库testdb" class="headerlink" title="2.5 在masterdb上创建数据库testdb"></a>2.5 在masterdb上创建数据库testdb</h2><pre><code>mysql&gt; create database testdb;
Query OK, 1 row affected (0.08 sec)

mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mydb               |
| mysql              |
| performance_schema |
| test               |
| testdb             |
+--------------------+
6 rows in set (0.00 sec)
</code></pre><p>查看slavedb是否复制成功</p>
<pre><code>mysql&gt; show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mydb               |
| mysql              |
| performance_schema |
| test               |
| testdb             |
+--------------------+
6 rows in set (0.00 sec)
</code></pre><p>分别在masterdb和slavedb上为amoedb授权</p>
<pre><code>mysql&gt; GRANT ALL ON testdb.* TO &apos;test1&apos;@&apos;192.168.2.203&apos; IDENTIFIED BY &apos;111111&apos;;
Query OK, 0 rows affected (0.05 sec)

mysql&gt; flush privileges;
Query OK, 0 rows affected (0.02 sec)
</code></pre><p>启动amoeba    </p>
<pre><code>[root@bogon amoeba]# /usr/local/amoeba/bin/launcher
Error: JAVA_HOME environment variable is not set.
[root@bogon amoeba]# vim /etc/profile^C
[root@bogon amoeba]# source /etc/profile
[root@bogon amoeba]# /usr/local/amoeba/bin/launcher
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=16m; support was removed in 8.0
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=96m; support was removed in 8.0

The stack size specified is too small, Specify at least 228k
Error: Could not create the Java Virtual Machine.
Error: A fatal exception has occurred. Program will exit.
</code></pre><p>报错:</p>
<p>Error: Could not create the Java Virtual Machine.<br>Error: A fatal exception has occurred. Program will exit.<br>从错误文字上看，应该是由于stack size太小，导致JVM启动失败，要如何修改呢？<br>其实Amoeba已经考虑到这个问题，并将JVM参数配置写在属性文件里。现在，让我们通过该属性文件修改JVM参数。<br>修改jvm.properties文件JVM_OPTIONS参数。</p>
<pre><code>[root@bogon amoeba]# vim /usr/local/amoeba/jvm.properties 
改成：JVM_OPTIONS=&quot;-server -Xms1024m -Xmx1024m -Xss256k -XX:PermSize=16m -XX:MaxPermSize=96m&quot;
原为：JVM_OPTIONS=&quot;-server -Xms256m -Xmx1024m -Xss196k -XX:PermSize=16m -XX:MaxPermSize=96m&quot;
</code></pre><p>再次启动</p>
<pre><code>[root@bogon ~]# /usr/local/amoeba/bin/launcher
    at org.codehaus.plexus.classworlds.launcher.Launcher.launchStandard(Launcher.java:329)
    at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:239)
    at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:409)
    at org.codehaus.classworlds.Launcher.mainWithExitCode(Launcher.java:127)
    at org.codehaus.classworlds.Launcher.main(Launcher.java:110)
Caused by: com.meidusa.toolkit.common.bean.util.InitialisationException: default pool required!,defaultPool=writedb invalid
    at com.meidusa.amoeba.route.AbstractQueryRouter.init(AbstractQueryRouter.java:469)
    at com.meidusa.amoeba.context.ProxyRuntimeContext.initAllInitialisableBeans(ProxyRuntimeContext.java:337)
    ... 11 more
 2016-10-24 18:46:37 [INFO] Project Name=Amoeba-MySQL, PID=1577 , System shutdown ....
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=16m; support was removed in 8.0
Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=96m; support was removed in 8.0
 2016-10-24 18:50:19 [INFO] Project Name=Amoeba-MySQL, PID=1602 , starting...
log4j:WARN log4j config load completed from file:/usr/local/amoeba/conf/log4j.xml
2016-10-24 18:50:21,668 INFO  context.MysqlRuntimeContext - Amoeba for Mysql current versoin=5.1.45-mysql-amoeba-proxy-3.0.4-BETA
log4j:WARN ip access config load completed from file:/usr/local/amoeba/conf/access_list.conf
2016-10-24 18:50:22,852 INFO  net.ServerableConnectionManager - Server listening on 0.0.0.0/0.0.0.0:8066.
</code></pre><p>查看端口</p>
<pre><code>[root@bogon ~]# netstat -unlpt | grep java
tcp        0      0 :::8066                     :::*                        LISTEN      1602/java    
</code></pre><p>由此可知Amoeba启动正常</p>
<h2 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6 测试"></a>2.6 测试</h2><p>远程登陆mysql客户端通过指定amoeba配置文件中指定的用户名、密码、和端口以及amoeba服务器ip地址链接mysql数据库</p>
<pre><code>[root@lys2 ~]# mysql -h192.168.2.203 -uroot -p -P8066
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 1364055863
Server version: 5.1.45-mysql-amoeba-proxy-3.0.4-BETA Source distribution

Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.

mysql&gt; 
</code></pre><p>在testdb中创建表test并插入数据</p>
<pre><code>mysql&gt; use testdb;
Database changed
mysql&gt; create table test_table(id int,password varchar(40) not null);
Query OK, 0 rows affected (0.19 sec)

mysql&gt; show tables;
+------------------+
| Tables_in_testdb |
+------------------+
| test_table       |
+------------------+
1 row in set (0.02 sec)

mysql&gt; insert into test_table(id,password) values(&apos;1&apos;,&apos;test1&apos;);
Query OK, 1 row affected (0.04 sec)

mysql&gt; select * from test_table;
+------+----------+
| id   | password |
+------+----------+
|    1 | test1    |
+------+----------+
1 row in set (0.02 sec)
</code></pre><p>分别登陆masterdb和slavedb查看数据</p>
<p>masterdb：</p>
<pre><code>mysql&gt; use testdb;
Database changed
mysql&gt; show tables;
+------------------+
| Tables_in_testdb |
+------------------+
| test_table       |
+------------------+
1 row in set (0.00 sec)

mysql&gt; select * from test_table;
+------+----------+
| id   | password |
+------+----------+
|    1 | test1    |
+------+----------+
1 row in set (0.03 sec)
</code></pre><p>slavedb：</p>
<pre><code>mysql&gt; use testdb;
Database changed
mysql&gt; show tables;
+------------------+
| Tables_in_testdb |
+------------------+
| test_table       |
+------------------+
1 row in set (0.00 sec)

mysql&gt; select * from test_table;
+------+----------+
| id   | password |
+------+----------+
|    1 | test1    |
+------+----------+
1 row in set (0.00 sec)
</code></pre><p>停掉masterdb，然后在客户端分别执行插入和查询功能</p>
<p>masterdb：</p>
<p>　　[root@bogon ~]# service mysqld stop<br>　　Shutting down MySQL. SUCCESS!</p>
<p>客户端：</p>
<pre><code>mysql&gt; insert into test_table(id,password) values(&apos;2&apos;,&apos;test2&apos;);
ERROR 1044 (42000): Amoeba could not connect to MySQL server[192.168.2.204:3306],拒绝连接
mysql&gt; select * from test_table;
+------+----------+
| id   | password |
+------+----------+
|    1 | test1    |
+------+----------+
1 row in set (0.01 sec)
</code></pre><p>可以看到，关掉masterdb和写入报错，读正常</p>
<p>开启masterdb上的msyql 关闭slave上的mysql</p>
<p>masterdb：</p>
<pre><code>[root@bogon ~]# service mysqld start
Starting MySQL.. SUCCESS! 
</code></pre><p>slavedb：</p>
<pre><code>[root@localhost ~]# service mysqld stop
Shutting down MySQL. SUCCESS! 
</code></pre><p>客户端再次尝试</p>
<pre><code>mysql&gt; insert into test_table(id,password) values(&apos;2&apos;,&apos;test2&apos;);
Query OK, 1 row affected (0.19 sec)

mysql&gt; select * from test_table;
ERROR 1044 (42000): poolName=myslave, no valid pools
</code></pre><p>可以看到插入成功，读取失败</p>
<p>开启slavedb上的mysql，查看数据是否自动同步</p>
<p>slavedb:</p>
<pre><code>[root@localhost ~]# service mysqld start
Starting MySQL... SUCCESS! 
</code></pre><p>客户端：</p>
<pre><code>mysql&gt; select * from test_table;
+------+----------+
| id   | password |
+------+----------+
|    1 | test1    |
|    2 | test2    |
+------+----------+
2 rows in set (0.01 sec)
</code></pre><p>接着客户端：</p>
<pre><code>mysql&gt; insert into test_table(id,password) values(&apos;3&apos;,&apos;test3&apos;);
Query OK, 1 row affected (0.03 sec)

mysql&gt; select * from test_table;
+------+----------+
| id   | password |
+------+----------+
|    1 | test1    |
|    2 | test2    |
|    3 | test3    |
+------+----------+
3 rows in set (0.02 sec)
</code></pre><p>OK 一切正常，到此全部结束</p>
<p>注：关于mysql主从同步自行查看博主之前的主从同步笔记！</p>
<ul>
<li><p>Amoeba主配置文件($AMOEBA_HOME/conf/amoeba.xml)，用来配置Amoeba服务的基本参数，如Amoeba主机地址、端口、认证方式、用于连接的用户名、密码、线程数、超时时间、其他配置文件的位置等。</p>
</li>
<li><p>数据库服务器配置文件($AMOEBA_HOME/conf/dbServers.xml)，用来存储和配置Amoeba所代理的数据库服务器的信息，如:主机IP、端口、用户名、密码等。</p>
</li>
<li><p>切分规则配置文件($AMOEBA_HOME/conf/rule.xml)，用来配置切分规则。</p>
</li>
<li><p>数据库函数配置文件($AMOEBA_HOME/conf/functionMap.xml)，用来配置数据库函数的处理方法，Amoeba将使用该配置文件中的方法解析数据库函数。</p>
</li>
<li><p>切分规则函数配置文件($AMOEBA_HOME/conf/ruleFunctionMap.xml)，用来配置切分规则中使用的用户自定义函数的处理方法。</p>
</li>
<li><p>访问规则配置文件($AMOEBA_HOME/conf/access_list.conf)，用来授权或禁止某些服务器IP访问Amoeba。</p>
</li>
<li><p>日志规格配置文件($AMOEBA_HOME/conf/log4j.xml)，用来配置Amoeba输出日志的级别和方式。</p>
</li>
</ul>
<p>转载：<a href="https://www.cnblogs.com/liuyisai/p/6009379.html" target="_blank" rel="external">Amoeba+Mysql实现数据库读写分离</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：mysql读写分离原理&quot;&gt;&lt;a href=&quot;#一：mysql读写分离原理&quot; class=&quot;headerlink&quot; title=&quot;一：mysql读写分离原理&quot;&gt;&lt;/a&gt;一：mysql读写分离原理&lt;/h1&gt;&lt;p&gt;MySQL的主从复制和MySQL的读写分离两者有着紧
    
    </summary>
    
      <category term="mysql" scheme="http://wangyuanjun.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wangyuanjun.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制详解与实践</title>
    <link href="http://wangyuanjun.cn/2018/02/09/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%A6%E8%A7%A3%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://wangyuanjun.cn/2018/02/09/MySQL主从复制详解与实践/</id>
    <published>2018-02-09T14:25:14.000Z</published>
    <updated>2018-02-11T05:53:40.428Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：mysql主从原理"><a href="#一：mysql主从原理" class="headerlink" title="一：mysql主从原理"></a>一：mysql主从原理</h1><h2 id="1-1-基本介绍"><a href="#1-1-基本介绍" class="headerlink" title="1.1 基本介绍"></a>1.1 基本介绍</h2><p>MySQL 内建的复制功能是构建大型，高性能应用程序的基础。将 MySQL 的 数亿分布到到多个系统上去，这种分步的机制，是通过将 MySQL 的某一台主机的数据复制到其它主机( Slave )上，并重新执行一遍来实现的。复制过程中一个服务器充当服务器，而一个或多个其它服务器充当从服务器。主服务器将更新写入二进制日志，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器从服务器在日志中读取的最后一次成功更新的位置，从服务器接收从那时起发生的任何更新，然后封锁等等主服务器通知新的更新。<br>请注意当你进行复制时，所有对复制中的表的更新必须在主服务器上进行。否则，你必须要小心，以避免用户对主服务器上的表进行的更新与对服务器上的表所进行的更新之间的冲突</p>
<h2 id="1-2-MySQL支持的复制类型"><a href="#1-2-MySQL支持的复制类型" class="headerlink" title="1.2 MySQL支持的复制类型"></a>1.2 MySQL支持的复制类型</h2><ol>
<li>基于语句的复制。 在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。否则，你必须要小心，以避免用户对主服务器上的表进行的更新与对服务器上的表所进行的更新之间的冲突，配置：binlog_format = ‘STATEMENT’</li>
<li>基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍，从 MySQL 5.0开始支持，配置：binlog_format = ‘ROW’</li>
<li>混合类型的复制。默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制,配置：binlog_format = ‘MIXED’</li>
</ol>
<h2 id="1-3-mysql复制解决的问题"><a href="#1-3-mysql复制解决的问题" class="headerlink" title="1.3 mysql复制解决的问题"></a>1.3 mysql复制解决的问题</h2><ul>
<li>数据分布</li>
<li>负载平衡</li>
<li>备份</li>
<li>高可用性和容错行</li>
</ul>
<h2 id="1-4-复制是如何工作的"><a href="#1-4-复制是如何工作的" class="headerlink" title="1.4 复制是如何工作的"></a>1.4 复制是如何工作的</h2><p>MySQL之间数据复制的基础是二进制日志文件（binary log file）。一台MySQL数据库一旦启用二进制日志后，其作为master，它的数据库中所有操作都会以“事件”的方式记录在二进制日志中，其他数据库作为slave通过一个I/O线程与主服务器保持通信，并监控master的二进制日志文件的变化，如果发现master二进制日志文件发生变化，则会把变化复制到自己的中继日志中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中，以此实现从数据库和主数据库的一致性，也就实现了主从复制。<br>可以简化为三个步骤(如下图)：</p>
<ol>
<li>Master 将改变记录到二进制日志中。</li>
<li>Slave 将 Master 的二进制日志拷贝到它的中继日志( Relay_log )</li>
<li>Slave 重做中继日志中的事件，将改变反映它自己的数据</li>
</ol>
<p><img src="/2018/02/09/MySQL主从复制详解与实践/主从复制.jpg" alt="主从复制"></p>
<p>说明:</p>
<ol>
<li>Master 记录二进制的日志。在每个事务更新数据之前，Master 在二进制日志记录这些改变。 MySQL 将事务日志的写入二进制日志，及时事务中的语句都市交叉执行的。在事件写入二进制日志完成后，Master 通知存储引擎提交事务。</li>
<li>Slave 将 Master 的 Binary log 拷贝到它自己的中继日志。首先 Slave 开始一个工作线程–I/O线程。I/O 线程在 Master 上打开一个连接，然后开始从二进制日志中读取事件，如果已经连上 Master，它会并等待master产生新的事件。I/O线程就这些事件写入中继日志。</li>
<li>SQL Slave Thread ( SQL从线程)处理该过程的最后一步。SQL纯种从中继日志读取事件，并重放其中的事件而更新 Slave 的数据。使其它与 Master 中的数据保持一致。只要该线程与 I/O 线程保持一致，中继日志通常会位于 OS 的缓存中，所以中继日志的开销很小。</li>
<li>此处，在 Master 中也有一个工作线程，和其他 MySQL 的连接一样，Slave 在 Master 中打开一个连接也会使得 Master 开始一个线程。复制过程有一个很重要的限制—复制在 Slave 上是串行化的，也就是说 Master 上的并行更新操作不能在 Slave 上并行操作。</li>
</ol>
<h2 id="1-5-复制实现细节分析"><a href="#1-5-复制实现细节分析" class="headerlink" title="1.5 复制实现细节分析"></a>1.5 复制实现细节分析</h2><p>MySQL主从复制功能使用<strong>三个线程实现，一个在主服务器上，两个在从服务器上</strong></p>
<h3 id="1-5-1-Binlog转储线程。"><a href="#1-5-1-Binlog转储线程。" class="headerlink" title="1.5.1 Binlog转储线程。"></a>1.5.1 Binlog转储线程。</h3><p>当从服务器与主服务器连接时，主服务器会创建一个线程将二进制日志内容发送到从服务器。<br>该线程可以使用 语句 SHOW PROCESSLIST(下面有示例介绍) 在服务器 sql 控制台输出中标识为Binlog Dump线程。</p>
<p>二进制日志转储线程获取服务器上二进制日志上的锁，用于读取要发送到从服务器的每个事件。一旦事件被读取，即使在将事件发送到从服务器之前，锁会被释放。</p>
<h3 id="1-5-2-从服务器I-O线程。"><a href="#1-5-2-从服务器I-O线程。" class="headerlink" title="1.5.2 从服务器I/O线程。"></a>1.5.2 从服务器I/O线程。</h3><p>当在从服务器sql 控制台发出 START SLAVE语句时，从服务器将创建一个I/O线程，该线程连接到主服务器，并要求它发送记录在主服务器上的二进制更新日志。</p>
<p>从机I/O线程读取主服务器Binlog Dump线程发送的更新 （参考上面 Binlog转储线程 介绍），并将它们复制到自己的本地文件二进制日志中。</p>
<p>该线程的状态显示详情 Slave_IO_running 在输出端 使用 命令SHOW SLAVE STATUS</p>
<p>使用\G语句终结符,而不是分号,是为了，易读的垂直布局</p>
<p>这个命令在上面 查看从服务器状态 用到过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW SLAVE STATUS\G</div></pre></td></tr></table></figure>
<h3 id="1-5-3-从服务器SQL线程。"><a href="#1-5-3-从服务器SQL线程。" class="headerlink" title="1.5.3 从服务器SQL线程。"></a>1.5.3 从服务器SQL线程。</h3><p>从服务器创建一条SQL线程来读取由主服务器I/O线程写入的二级制日志，并执行其中包含的事件。</p>
<p>在前面的描述中，每个主/从连接有三个线程。主服务器为每个当前连接的从服务器创建一个二进制日志转储线程，每个从服务器都有自己的I/O和SQL线程。<br>从服务器使用两个线程将读取更新与主服务器更新事件，并将其执行为独立任务。因此，如果语句执行缓慢，则读取语句的任务不会减慢。</p>
<p>例如，如果从服务器开始几分钟没有运行，或者即使SQL线程远远落后，它的I/O线程也可以从主服务器建立连接时，快速获取所有二进制日志内容。</p>
<p>如果从服务器在SQL线程执行所有获取的语句之前停止，则I/O线程至少获取已经读取到的内容，以便将语句的安全副本存储在自己的二级制日志文件中，准备下次执行主从服务器建立连接，继续同步。</p>
<p>使用命令 SHOW PROCESSLIST\G 可以查看有关复制的信息</p>
<p>命令 SHOW FULL PROCESSLISTG</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">mysql&gt;  SHOW FULL PROCESSLIST\G</div><div class="line">*************************** 1. row ***************************</div><div class="line">     Id: 22</div><div class="line">   User: repl</div><div class="line">   Host: node2:39114</div><div class="line">     db: NULL</div><div class="line">Command: Binlog Dump</div><div class="line">   Time: 4435</div><div class="line">  State: Master has sent all binlog to slave; waiting for more updates</div><div class="line">   Info: NULL</div></pre></td></tr></table></figure>
<p>Id: 22是Binlog Dump服务连接的从站的复制线程<br>Host: node2:39114 是从服务，主机名 级及端口<br>State: 信息表示所有更新都已同步发送到从服务器，并且主服务器正在等待更多更新发生。<br>如果Binlog Dump在主服务器上看不到 线程，意味着主从复制没有配置成功; 也就是说，没有从服务器连接主服务器。</p>
<p>命令 SHOW PROCESSLISTG</p>
<p>在 Slave 从服务器 ，查看两个线程的更新状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SHOW PROCESSLIST\G</div><div class="line">*************************** 1. row ***************************</div><div class="line">     Id: 6</div><div class="line">   User: system user</div><div class="line">   Host: </div><div class="line">     db: NULL</div><div class="line">Command: Connect</div><div class="line">   Time: 6810</div><div class="line">  State: Waiting for master to send event</div><div class="line">   Info: NULL</div><div class="line">*************************** 2. row ***************************</div><div class="line">     Id: 7</div><div class="line">   User: system user</div><div class="line">   Host: </div><div class="line">     db: NULL</div><div class="line">Command: Connect</div><div class="line">   Time: 3069</div><div class="line">  State: Slave has read all relay log; waiting for more updates</div><div class="line">   Info: NULL</div></pre></td></tr></table></figure>
<p>Id: 6是与主服务器通信的I/O线程<br>Id: 7是正在处理存储在中继日志中的更新的SQL线程</p>
<p>在 运行 SHOW PROCESSLIST 命令时，两个线程都空闲，等待进一步更新</p>
<p>如果在主服务器上在设置的超时，时间内 Binlog Dump线程没有活动，则主服务器会和从服务器断开连接。超时取决于的 服务器系统变量 值 net_write_timeout(在中止写入之前等待块写入连接的秒数，默认10秒)和 net_retry_count;(如果通信端口上的读取或写入中断，请在重试次数，默认10次) 设置 服务器系统变量</p>
<p>该SHOW SLAVE STATUS语句提供了有关从服务器上复制处理的附加信息。</p>
<h2 id="1-6-复制常用类型"><a href="#1-6-复制常用类型" class="headerlink" title="1.6 复制常用类型"></a>1.6 复制常用类型</h2><h3 id="1-6-1-复制的常用体系结构基本原则"><a href="#1-6-1-复制的常用体系结构基本原则" class="headerlink" title="1.6.1 复制的常用体系结构基本原则"></a>1.6.1 复制的常用体系结构基本原则</h3><ol>
<li>每个 Slave 只能有一个 Master；</li>
<li>每个 Slave 只能有一个唯一的服务器ID；</li>
<li>每个 Master 可以有很多 Slave;</li>
<li>如果你设置了 log_slave_updates，Slave 可以是其他 Slave 的 Master，从而扩散 Master 的更新</li>
<li>MySQL 不支持多主服务器复制—即一个 Slave 可以有多个 Master，但是，通过一些简单的组合，我们却可以建立灵活而强大的复制体系结构。</li>
</ol>
<h3 id="1-6-2-一主多从复制架构"><a href="#1-6-2-一主多从复制架构" class="headerlink" title="1.6.2 一主多从复制架构"></a>1.6.2 一主多从复制架构</h3><ol>
<li>场景：在主库读取请求压力非常大的场景下，可以通过配置一主多从复制架构实现读写分离，把大量对实时性要求不是特别高的读请求通过负载均衡到多个从库上，降低主库的读取压力。在主库出现异常宕机的情况下，可以把一个从库切换为主库继续提供服务；</li>
<li>建议：</li>
</ol>
<ul>
<li>当 Slave 增加到一定数量时，Slave 对 Master 的负载以及网络带宽都会成为一个严重的问题。</li>
<li>不同的 Slave 扮演不同的作用(例如使用不同的索引，或者不同的存储引擎)</li>
<li>用一个 Slave 作为备用 Master，只进行复制</li>
<li>用一个远程的 Slave，用于灾难恢复。</li>
</ul>
<h3 id="1-6-3-多级复制架构"><a href="#1-6-3-多级复制架构" class="headerlink" title="1.6.3 多级复制架构"></a>1.6.3 多级复制架构</h3><ol>
<li>场景：一主多从的架构能够解决大部分读请求压力特别大的场景需求，但主库的I/O压力和网络压力会随着从库的增加而增长，而使用多级复制架构就可以解决一主多从场景下，主库额外的I/O和网络压力。 但要注意的是，多级复制场景下主库的数据是经历两次才到达读取的从库，期间的延时比一主多从复制场景下只经历一次复制的要大。</li>
<li>建议：</li>
</ol>
<ul>
<li>可能存在延时较长的风险</li>
<li>这种方案可以与第三方软件结合使用，例如Slave+LVS+Keepalived 实现高可用。</li>
</ul>
<h3 id="1-6-4-双主复制-Dual-Master架构"><a href="#1-6-4-双主复制-Dual-Master架构" class="headerlink" title="1.6.4 双主复制/Dual Master架构"></a>1.6.4 双主复制/Dual Master架构</h3><ol>
<li>场景：双主/Dual Master架构适用于写压力比较大的场景，或者DBA做维护需要主从切换的场景，通过双主/Dual master架构避免了重复搭建从库的麻烦。</li>
<li>建议：</li>
</ol>
<ul>
<li>最大问题就是更新冲突。</li>
<li>可以采用MySQL Cluster，以及将Cluster和Replication结合起来，可以建立强大的高性能的数据库平台。</li>
</ul>
<h1 id="二：mysql主从配置实践"><a href="#二：mysql主从配置实践" class="headerlink" title="二：mysql主从配置实践"></a>二：mysql主从配置实践</h1><h2 id="2-1-实现MySQL主从复制需要进行的配置："><a href="#2-1-实现MySQL主从复制需要进行的配置：" class="headerlink" title="2.1 实现MySQL主从复制需要进行的配置："></a>2.1 实现MySQL主从复制需要进行的配置：</h2><p><strong>主服务器</strong>：</p>
<ul>
<li>开启二进制日志</li>
<li>配置唯一的server-id</li>
<li>获得master二进制日志文件名及位置</li>
<li>创建一个用于slave和master通信的用户账号</li>
</ul>
<p><strong>从服务器</strong>：</p>
<ul>
<li>配置唯一的server-id</li>
<li>使用master分配的用户账号读取master二进制日志</li>
<li>启用slave服务</li>
</ul>
<p>具体实现过程如下：</p>
<h2 id="2-2-基础环境配置"><a href="#2-2-基础环境配置" class="headerlink" title="2.2 基础环境配置"></a>2.2 基础环境配置</h2><ul>
<li>数据库版本： mysql 5.1.73 ( Slave 版本可以大于或者等于 Maste r版本)</li>
<li>操作系统： CentOS 6.7 x86_64</li>
<li>IP地址：192.168.124.10 ( Master ) 192.168.124.20 ( Slave )</li>
</ul>
<h2 id="2-3-Master-Server配置"><a href="#2-3-Master-Server配置" class="headerlink" title="2.3 Master-Server配置"></a>2.3 Master-Server配置</h2><h3 id="2-3-1-修改mysql配置"><a href="#2-3-1-修改mysql配置" class="headerlink" title="2.3.1 修改mysql配置"></a>2.3.1 修改mysql配置</h3><p>找到主数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">log-bin=mysql-bin #开启二进制日志</div><div class="line">server-id=1 #设置server-id</div></pre></td></tr></table></figure></p>
<p>重启MySQL服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># service mysqld restart</div></pre></td></tr></table></figure>
<h3 id="2-3-2-创建用于同步的用户账号-复制帐号"><a href="#2-3-2-创建用于同步的用户账号-复制帐号" class="headerlink" title="2.3.2 创建用于同步的用户账号(复制帐号)"></a>2.3.2 创建用于同步的用户账号(复制帐号)</h3><p>在主服务器上为从服务器分配一个账号，就像一把钥匙，从服务器拿着这个钥匙，才能到主服务器上来共享主服务器的日志文件。</p>
<p>在 Master 的数据库中建立一个复制账户，每个 Slave 使用该账户连接 Master 进行复制，需要 replication slave 和 replication client 权限，Master 的连接信息会存储在文本文件 master.info 文件中。(master.info文件在 Slave 的数据目录中)</p>
<pre><code>mysql&gt;grant replication slave on *.* to &apos;replication&apos;@&apos;192.168.124.20&apos; identified by &apos;123456&apos;;#创建用户和分配权限
mysql&gt;flush privileges;#刷新权限
</code></pre><p>说明：创建了一个用户名为 replication 的用户，密码为 123456 ,只允许在 192.168.124.20 这个 Slave 上登录。</p>
<h3 id="2-3-3-查询master的状态"><a href="#2-3-3-查询master的状态" class="headerlink" title="2.3.3 查询master的状态"></a>2.3.3 查询master的状态</h3><p>查看 File(日志文件名) 和 Postition(日志地址)，下面配置 Slave 的时候需要用。执行完之后记录下这两值，然后在配置完从服务器之前不要对主服务器进行任何操作，因为每次操作数据库时这两值会发生改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;show master status;</div></pre></td></tr></table></figure>
<p><img src="/2018/02/09/MySQL主从复制详解与实践/masterstatus.png" alt="masterstatus"></p>
<p>注：执行完这个步骤后不要再操作主数据库了，防止主数据库状态值变化</p>
<h2 id="2-4-Slave-Server-配置"><a href="#2-4-Slave-Server-配置" class="headerlink" title="2.4 Slave-Server 配置"></a>2.4 Slave-Server 配置</h2><h3 id="2-4-1-修改mysql配置"><a href="#2-4-1-修改mysql配置" class="headerlink" title="2.4.1 修改mysql配置"></a>2.4.1 修改mysql配置</h3><p>关闭slave（如果你以前配置过主从的话，一定要先关闭）<br>命令：stop slave;</p>
<p>找到从数据库的配置文件my.cnf(或者my.ini)，我的在/etc/mysql/my.cnf,在[mysqld]部分插入如下两行：<br>Master-Server和Slave-Server 的server-id必须不一样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[mysqld]</div><div class="line">log-bin=mysql-bin #开启二进制日志</div><div class="line">server-id=2 #设置server-id</div></pre></td></tr></table></figure>
<p>重启MySQL服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># service mysqld restart</div></pre></td></tr></table></figure>
<h3 id="2-4-2-执行同步命令"><a href="#2-4-2-执行同步命令" class="headerlink" title="2.4.2 执行同步命令"></a>2.4.2 执行同步命令</h3><p>执行同步命令，设置主数据库ip，同步帐号密码，同步位置  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; CHANGE MASTER TO</div><div class="line">    -&gt;     MASTER_HOST=&apos;192.168.124.10&apos;,</div><div class="line">    -&gt;     MASTER_USER=&apos;replication&apos;,</div><div class="line">    -&gt;     MASTER_PASSWORD=&apos;123456&apos;,</div><div class="line">    -&gt;     MASTER_LOG_FILE=&apos;mysql-bin.000060&apos;,</div><div class="line">    -&gt;     MASTER_LOG_POS=248;</div></pre></td></tr></table></figure>
<p>选项：</p>
<ul>
<li>master_host：Master 服务器IP</li>
<li>master_user：Master 服务器授权用户，也就是 Master 前面创建的那个用户</li>
<li>master_password：Master 服务器授权用户对应的密码</li>
<li>master_log_file：Master binlog 文件名</li>
<li>master_log_pos：Master binlog 文件中的 Postion 值<br>更多的选项可以看:<a href="http://dev.mysql.com/doc/refman/5.7/en/change-master-to.html" target="_blank" rel="external">http://dev.mysql.com/doc/refman/5.7/en/change-master-to.html</a><br>说明：使用刚刚在 Master 创建的用户连接，log_file 和 log_pos 就是使用刚刚在 Master 上执行 show master status; 执行出来的结果</li>
</ul>
<h3 id="2-4-3-启动slave同步进程："><a href="#2-4-3-启动slave同步进程：" class="headerlink" title="2.4.3 启动slave同步进程："></a>2.4.3 启动slave同步进程：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql&gt;start slave;</div></pre></td></tr></table></figure>
<h3 id="2-4-4-查看slave状态："><a href="#2-4-4-查看slave状态：" class="headerlink" title="2.4.4 查看slave状态："></a>2.4.4 查看slave状态：</h3><pre><code>mysql&gt; show slave status\G;
*************************** 1. row ***************************
               Slave_IO_State: Waiting for master to send event
                  Master_Host: 192.168.124.10
                  Master_User: replication
                  Master_Port: 3306
                Connect_Retry: 60
              Master_Log_File: mysql-bin.000013
          Read_Master_Log_Pos: 11662
               Relay_Log_File: mysqld-relay-bin.000022
                Relay_Log_Pos: 11765
        Relay_Master_Log_File: mysql-bin.000013
             Slave_IO_Running: Yes
            Slave_SQL_Running: Yes
              Replicate_Do_DB: 
          Replicate_Ignore_DB: 
        ...
</code></pre><p>当Slave_IO_Running和Slave_SQL_Running都为YES的时候就表示主从同步设置成功了。接下来就可以进行一些验证了，比如在主master数据库的test数据库的一张表中插入一条数据，在slave的test库的相同数据表中查看是否有新增的数据即可验证主从复制功能是否有效，还可以关闭slave（mysql&gt;stop slave;）,然后再修改master，看slave是否也相应修改（停止slave后，master的修改不会同步到slave），就可以完成主从复制功能的验证了。</p>
<p>还可以用到的其他相关参数：</p>
<p>master开启二进制日志后默认记录所有库所有表的操作，可以通过配置来指定只记录指定的数据库甚至指定的表的操作，具体请看2.5</p>
<h2 id="2-5-其他可能用到的相关参数"><a href="#2-5-其他可能用到的相关参数" class="headerlink" title="2.5 其他可能用到的相关参数"></a>2.5 其他可能用到的相关参数</h2><ol>
<li><p>master端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># 不同步哪些数据库  </div><div class="line">binlog-ignore-db = mysql  </div><div class="line">binlog-ignore-db = test  </div><div class="line">binlog-ignore-db = information_schema  </div><div class="line">  </div><div class="line"># 只同步哪些数据库，除此之外，其他不同步  </div><div class="line">binlog-do-db = game  </div><div class="line">  </div><div class="line"># 日志保留时间  </div><div class="line">expire_logs_days = 10  </div><div class="line">  </div><div class="line"># 控制binlog的写入频率。每执行多少次事务写入一次  </div><div class="line"># 这个参数性能消耗很大，但可减小MySQL崩溃造成的损失  </div><div class="line">sync_binlog = 5  </div><div class="line">  </div><div class="line"># 日志格式，建议mixed  </div><div class="line"># statement 保存SQL语句  </div><div class="line"># row 保存影响记录数据  </div><div class="line"># mixed 前面两种的结合  </div><div class="line">binlog_format = mixed</div></pre></td></tr></table></figure>
</li>
<li><p>slave端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># 停止主从同步  </div><div class="line">mysql&gt; stop slave;  </div><div class="line">  </div><div class="line"># 连接断开时，重新连接超时时间  </div><div class="line">mysql&gt; change master to master_connect_retry=50;  </div><div class="line">  </div><div class="line"># 开启主从同步  </div><div class="line">mysql&gt; start slave;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6 测试"></a>2.6 测试</h2><p>在 Master 数据库中执行sql语句操作，观察 Slave 是否同步，如果同步则说明配置成功。</p>
<h2 id="2-7-注意事项"><a href="#2-7-注意事项" class="headerlink" title="2.7 注意事项"></a>2.7 注意事项</h2><ol>
<li>主库和从库的数据库名必须相同；</li>
<li>主库和从库的复制可以精确到表，但是在需要更改主库或从库的数据结构时需要立刻重启slave；</li>
<li>不能在mysql配置文件里直接写入master的配置信息，需要用change master命令来完成；</li>
<li>指定replicate_do_db必须在my.cnf里配置，不能用change master命令来完成；</li>
<li>如果不及时清理，日积月累二进制日志文件可能会把磁盘空间占满，可以在配置文件里加上expire_logs_days=7，只保留最近7天的日志，建议当slave不再使用时，通过reset slave来取消relaylog；</li>
<li>写一个监控脚本，用来监控 Slave 中的两个”yes”，如果只有一个”yes”或者零个，就表明主从有问题。</li>
</ol>
<h1 id="三：MySQL-主从错误处理"><a href="#三：MySQL-主从错误处理" class="headerlink" title="三：MySQL 主从错误处理"></a>三：MySQL 主从错误处理</h1><p>解决和处理主从错误这个是最重要的，比配置更更要。提高处理问题的能力，要熟悉原理，多处理积累，多学习其他网友的处理方式。出现错误都会在 Last_SQL_Error 中显示错误，一般根据错误提示进行处理，如果不太清楚，可以谷歌查询一下，不过操作完之后，同步正常后，一定要核对一下数据是否一致。<br>以下是收集的几个处理主从问题的链接：</p>
<ul>
<li><a href="http://hzcsky.blog.51cto.com/1560073/479476/" target="_blank" rel="external">http://hzcsky.blog.51cto.com/1560073/479476/</a></li>
<li><a href="http://storysky.blog.51cto.com/628458/259280" target="_blank" rel="external">http://storysky.blog.51cto.com/628458/259280</a></li>
<li><a href="http://outofmemory.cn/code-snippet/3177/mysql-zhucong-library-clock-error-%EF%BC%9A-1062-Error-Duplicate-entry-1438019-for-key-PRIMARY-on-query" target="_blank" rel="external">http://outofmemory.cn/code-snippet/3177/mysql-zhucong-library-clock-error-%EF%BC%9A-1062-Error-Duplicate-entry-1438019-for-key-PRIMARY-on-query</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/faqs-replication.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/faqs-replication.html</a></li>
</ul>
<p>参考：<br><a href="http://blog.csdn.net/mycwq/article/details/17136001" target="_blank" rel="external">MySQL数据库设置主从同步</a><br><a href="http://heylinux.com/archives/1004.html" target="_blank" rel="external">MySQL主从复制（Master-Slave）与读写分离（MySQL-Proxy）实践</a><br><a href="http://blog.csdn.net/u010098331/article/details/50828820" target="_blank" rel="external">MySQL 主从复制详解（详细）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：mysql主从原理&quot;&gt;&lt;a href=&quot;#一：mysql主从原理&quot; class=&quot;headerlink&quot; title=&quot;一：mysql主从原理&quot;&gt;&lt;/a&gt;一：mysql主从原理&lt;/h1&gt;&lt;h2 id=&quot;1-1-基本介绍&quot;&gt;&lt;a href=&quot;#1-1-基本介绍&quot;
    
    </summary>
    
      <category term="mysql" scheme="http://wangyuanjun.cn/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://wangyuanjun.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机学习——垃圾收集器与内存分配策略</title>
    <link href="http://wangyuanjun.cn/2018/02/08/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://wangyuanjun.cn/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/</id>
    <published>2018-02-08T07:24:49.000Z</published>
    <updated>2018-02-11T05:52:08.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：Java中是如何管理对象的"><a href="#一：Java中是如何管理对象的" class="headerlink" title="一：Java中是如何管理对象的"></a>一：Java中是如何管理对象的</h1><p>垃圾收集（Garbage Collection，GC），要设计一个GC，需要考虑解决下面三件事情：<br>（1）哪些内存需要回收？<br>（2）什么时候回收？<br>（3）如何回收？</p>
<h2 id="1-1-哪些内存需要回收？"><a href="#1-1-哪些内存需要回收？" class="headerlink" title="1.1 哪些内存需要回收？"></a>1.1 哪些内存需要回收？</h2><p>根据《Java虚拟机学习——Java内存区域与内存溢出异常》中介绍的java内存模型，其中，程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，故这几个区域就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。<br>对于java堆和方法区则不一样，java堆是存放实例对象的地方，我们只有在程序运行期间才能知道会创建哪些对象，这部分内存的分配和回收是动态的，因此，垃圾收集器所关注的就是这一部分。<br>对于方法区（或者说HotSpot虚拟机中的永久代），垃圾回收主要是回收这两部分内容：废弃常量和无用的类。对于废弃常量，主要是判断当前系统中有没有对象引用这个常量；对于无用类则比较严格，需要满足下面三个条件：<br>（1）该类的所有实例都已经被回收，即堆中不存在该类任何势力；<br>（2）加载该类的ClassLoader已经被回收；<br>（3）对类对应的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法；<br>满足了上面三个条件也仅仅是“可以”进行回收了，还要根据HotSpot的一些配置参数综合考虑。</p>
<h2 id="1-2-什么时候回收？"><a href="#1-2-什么时候回收？" class="headerlink" title="1.2 什么时候回收？"></a>1.2 什么时候回收？</h2><p>垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”，对于这些已经“死去”的对象我们需要进行回收。判断对象是否存活的算法：</p>
<h3 id="1-2-1-引用计数算法"><a href="#1-2-1-引用计数算法" class="headerlink" title="1.2.1 引用计数算法"></a>1.2.1 引用计数算法</h3><p>算法过程如下：【给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的】。<br>引用计数算法实现简单，判定效率也很高，大部分情况下是一个不错的算法。但有一个比较重要的缺点：很难解决对象之间相互循环引用的问题。比如：j假设变量objA、objB为某个类的对象实例，objA中持有一个指向objB的成员，此时objB的引用计数为1；在objB中持有一个指向objA的成员，此时objA的引用计数值也为1；此时，即使把objA、objB都置为null，此时两个对象都不能被回收，因为这两个对象虽然为null了，但是它们的引用计数值都还为1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class ReferenceCountingGC &#123;</div><div class="line"></div><div class="line">    public Object instance = null;</div><div class="line">    private static final int_1MB=1024*1024；</div><div class="line">    private byte[]bigSize=new byte[2*_1MB]；//这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否被回收过</div><div class="line">    public static void testGC()&#123;</div><div class="line">        ReferenceCountingGC objA = new ReferenceCountingGC();</div><div class="line">        ReferenceCountingGC objB = new ReferenceCountingGC();</div><div class="line">        </div><div class="line">        objA.instance = objB;</div><div class="line">        objB.instance = objA;</div><div class="line">        </div><div class="line">        objA = null;</div><div class="line">        objB = null;</div><div class="line">        //假设在这行发生GC,objA和objB是否能被回收？</div><div class="line">        System.gc();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[F u l l G C（S y s t e m）[T e n u r e d：0 K-＞2 1 0 K（1 0 2 4 0 K），0.0 1 4 9 1 4 2 s e c s]4603K-＞210K（19456K），[Perm：2999K-＞2999K（21248K）]，0.0150007 secs][Times：user=0.01 sys=0.00，real=0.02 secs]</div><div class="line">Heap</div><div class="line">def new generation total 9216K,used 82K[0x00000000055e0000，0x0000000005fe0000，0x0000000005fe0000）</div><div class="line">Eden space 8192K，1%used[0x00000000055e00000x00000000055f4850，0x0000000005de0000）</div><div class="line">from space 1024K，0%used[0x0000000005de0000，0x0000000005de0000，0x0000000005ee0000）</div><div class="line">to space 1024K，0%used[0x0000000005ee0000，0x0000000005ee0000，0x0000000005fe0000）</div><div class="line">tenured generation total 10240K,used 210K[0x0000000005fe0000，0x00000000069e0000，0x00000000069e0000）</div><div class="line">the space 10240K，2%used[0x0000000005fe0000，0x0000000006014a18，0x0000000006014c00，0x00000000069e0000）</div><div class="line">compacting perm gen total 21248K,used 3016K[0x00000000069e0000，0x0000000007ea0000，0x000000000bde0000）</div><div class="line">the space 21248K，14%used[0x00000000069e0000，0x0000000006cd2398，0x0000000006cd2400，0x0000000007ea0000）</div><div class="line">No shared spaces configured.</div></pre></td></tr></table></figure>
<p>从运行结果中可以清楚看到，GC日志中包含“4603K-＞210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的</p>
<h3 id="1-2-2-可达性分析算法"><a href="#1-2-2-可达性分析算法" class="headerlink" title="1.2.2 可达性分析算法"></a>1.2.2 可达性分析算法</h3><p>目前主流的虚拟机，如java默认虚拟机HotSpot就是用的这种方式。算法基本思路为：【通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时（或者说从GC Roots到这个对象不可达），则证明此对象是不可用的】。如下图所示：<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/可达性分析算法.png" alt="可达性分析算法"><br>对象Object5、Object6、Object7相互虽然有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中类静态static属性引用的对象；</li>
<li>方法区中常量final引用的对象；</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li>
</ul>
<h2 id="1-3-再谈引用"><a href="#1-3-再谈引用" class="headerlink" title="1.3 再谈引用"></a>1.3 再谈引用</h2><p>无论是引用计数法还是可达性分析算法，都用到了引用的概念，从JDK1.2开始，Java对引用的概念进行了扩充，讲引用分为强引用（Strong Reference）、软引用（Softe Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，增强引用的适用性。</p>
<ul>
<li>强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只有强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</li>
<li>软引用也是用来描述一些有用但并非必要的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li>
<li>弱引用也是用来描述非必要对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。但垃圾收集工作时，无论当前内存是否足够，都会回收掉只内弱引用关联的对象。</li>
<li>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。因为finalize函数（后续会讲）被调用的不确定性，所以无法预知对象是否被回收，所在这里虚引用就起作用了。</li>
</ul>
<h2 id="1-4-生存还是死亡"><a href="#1-4-生存还是死亡" class="headerlink" title="1.4 生存还是死亡"></a>1.4 生存还是死亡</h2><p>需要注意的是，即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过（也就是说对象的finalize()方法只能被调用一次），虚拟机将这两种情况都视为“没有必要执行”。<br>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。从以下代码中我们可以看到一个对象的finalize()被<br>执行，但是它仍然可以存活。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">*此代码演示了两点：</div><div class="line">*1.对象可以在被GC时自我拯救。</div><div class="line">*2.这种自救的机会只有一次，因为一个对象的finalize（）方法最多只会被系统自动调用一次</div><div class="line">*/</div><div class="line">public class FinalizeEscapeGC&#123;</div><div class="line"></div><div class="line">	public static FinalizeEscapeGC SAVE_HOOK=null；</div><div class="line"></div><div class="line">	public void isAlive()&#123;</div><div class="line">		System.out.println(&quot;yes,i am still alive：)&quot;)；</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	protected void finalize()throws Throwable&#123;</div><div class="line">		super.finalize()；</div><div class="line">		System.out.println(&quot;finalize mehtod executed！&quot;)；</div><div class="line">		FinalizeEscapeGC.SAVE_HOOK=this；</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static void main(String[]args)throws Throwable&#123;</div><div class="line"></div><div class="line">		SAVE_HOOK=new FinalizeEscapeGC()；</div><div class="line"></div><div class="line">		//对象第一次成功拯救自己</div><div class="line">		SAVE_HOOK=null；</div><div class="line"></div><div class="line">		System.gc()；</div><div class="line"></div><div class="line">		//因为finalize方法优先级很低，所以暂停0.5秒以等待它</div><div class="line">		Thread.sleep(500）；</div><div class="line"></div><div class="line">		if(SAVE_HOOK！=null）&#123;</div><div class="line">			SAVE_HOOK.isAlive()；</div><div class="line">		&#125;else&#123;</div><div class="line">			System.out.println(&quot;no,i am dead：(&quot;)；</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//下面这段代码与上面的完全相同，但是这次自救却失败了</div><div class="line">		SAVE_HOOK=null；</div><div class="line"></div><div class="line">		System.gc()；</div><div class="line"></div><div class="line">		//因为finalize方法优先级很低，所以暂停0.5秒以等待它</div><div class="line">		Thread.sleep(500）；</div><div class="line"></div><div class="line">		if（SAVE_HOOK！=null）&#123;</div><div class="line">			SAVE_HOOK.isAlive()；</div><div class="line">		&#125;else&#123;</div><div class="line">			System.out.println(&quot;no,i am dead：(&quot;)；</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">finalize mehtod executed！</div><div class="line">yes,i am still alive：)</div><div class="line">no,i am dead：(</div></pre></td></tr></table></figure>
<p>因此对于不可达对象判定真正死亡的过程小结如下：<br>（1）GC进行第一次标记并进行一次筛选（筛选那些覆盖了finalize方法并且finalize方法是第一次调用的对象）；<br>（2）另一个低优先级的线程去调用那些被筛选出来的对象的finalize方法；<br>（3）GC进行第二次标记，如果在前一步中那些筛选出来的对象没有在finalize拯救自己，此时，那些未被筛选到的和这些这些筛选到的但是没有拯救自己的对象都将会回收。</p>
<h2 id="1-5-方法区收回"><a href="#1-5-方法区收回" class="headerlink" title="1.5 方法区收回"></a>1.5 方法区收回</h2><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。可能永久代的效果不理想，在JDK8中，已经没有永久代的概念了，原先这块区域被放置到本地内存了。</p>
<h1 id="二：垃圾收集算法"><a href="#二：垃圾收集算法" class="headerlink" title="二：垃圾收集算法"></a>二：垃圾收集算法</h1><h2 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h2><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程就是上面可达性分析算法中所讲的二次标记过程。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。<br>标记-清除算法的执行过程如下图所示：<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/标记清除算法.png" alt="标记清除算法"></p>
<p>缺点：<br>（1）效率问题：标记和清除的两个过程效率都不高；<br>（2）空间问题：标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作；</p>
<h2 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h2><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。复制算法的执行过程如图<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/复制算法.png" alt="复制算法"><br>复制算法的优点：<br>（1）每次都是对整个半区进行内存回收，实现简单、运行也高效；<br>（2）在那块使用内存上进行内存分配时，不用考虑内存碎片的问题，只要移动堆顶指针，按顺序分配内存即可；<br>缺点：使用内存比原来缩小了一半。</p>
<p>按照新生代的特点，新生代中的对象98%是“朝生夕死”的，因此，可以改进上面的复制算法，目前商业虚拟机正是用这种改进的收集算法来回收新生代。<br>改进的收集算法：<br>根据新生代的特点，我们并不需要按照1:1的比例来划分内存空间，而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是<br>8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<p>这种改进的收集算法也有一个问题，就是在回收时，那块空的Survivor空间能否放得下Eden和使用的Survivor空间中还存活的对象，如果Survivor空间不够存放上一次新生代收集下来的存活对象，此时就需要向老年代“借”内存，那些剩余未放下的对象就通过分配担保机制进入老年代。</p>
<h2 id="2-4-标记-整理算法"><a href="#2-4-标记-整理算法" class="headerlink" title="2.4 标记-整理算法"></a>2.4 标记-整理算法</h2><p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/标记-整理算法.png" alt="标记-整理算法"></p>
<h2 id="2-5-分代收集算法"><a href="#2-5-分代收集算法" class="headerlink" title="2.5 分代收集算法"></a>2.5 分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<h1 id="三：垃圾收集器"><a href="#三：垃圾收集器" class="headerlink" title="三：垃圾收集器"></a>三：垃圾收集器</h1><p>如果说上面介绍的收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现，按照上面的介绍，目前垃圾收集器基本都采用分代收集，因此一个垃圾收集器中一般都存在多种垃圾回收算法。不同的虚拟机提供的垃圾收集器也有很大差异，如下是HotSpot虚拟机基于JDK1.7版本所包含的所有垃圾收集器：<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/垃圾收集器.png" alt="垃圾收集器"><br>HotSpot中共有7中不同的垃圾收集器，如果两个收集器之间存在连线，说明它们之间可以搭配使用，其中，Serial、ParNew、Parallel Scavenge属于新生代收集器，CMS、Serial Old、Parallel Old属于老年代收集器，G1是最新的一种收集器，在新生代和老年代中都可使用。</p>
<h2 id="3-1-Serial（串行）收集器"><a href="#3-1-Serial（串行）收集器" class="headerlink" title="3.1 Serial（串行）收集器"></a>3.1 Serial（串行）收集器</h2><p>最基本、发展历史最悠久的一种收集器。看名字就知道，这个收集器是一个单线程的收集器，只使用一个CPU或一条收集线程去完成垃圾收集工作，最重要的是，在它进行垃圾收集的时候，必须暂停其他所有的工作线程，知道它收集结束。虽然有这个缺点，但是依然是虚拟机运行在Client模式下的默认新生代收集器。优点是：简单而高效，没有线程交互的开销。运行过程如图：<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/Serial（串行）收集器.png" alt="Serial（串行）收集器"><br>新生代采用的是“复制算法”，老年代采用的是“标记-整理”算法。</p>
<h2 id="3-2-ParNew收集器"><a href="#3-2-ParNew收集器" class="headerlink" title="3.2 ParNew收集器"></a>3.2 ParNew收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其他行为和Serial收集器一样。ParNew是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关的重要原因，除了Serial收集器外，目前只有ParNew能与老年代的CMS收集器配合使用。ParNew是一种并行的收集器。在垃圾回收中，并行是指：多条垃圾收集线程并行工作，用户线程处于等待状态；并发是指：用户线程和垃圾收集线程同时执行（不一定并行，可能交替执行）。<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/ParNew收集器.png" alt="ParNew收集器"></p>
<h2 id="3-3-Parallel-Scavenge收集器"><a href="#3-3-Parallel-Scavenge收集器" class="headerlink" title="3.3 Parallel Scavenge收集器"></a>3.3 Parallel Scavenge收集器</h2><p>Parallel Scavenge收集器使用的是复制算法，也是一个并行的多线程收集器。和ParNew相似，但是Parallel Scavenge的关注点不同，CMS收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。</p>
<p><strong>上面三种都是新生代收集器，下面介绍老年代收集器。</strong></p>
<h2 id="3-4-Serial-Old收集器"><a href="#3-4-Serial-Old收集器" class="headerlink" title="3.4 Serial Old收集器"></a>3.4 Serial Old收集器</h2><p>Serial Old收集器是新生代Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法，Serial Old的主要意义也是在于给Client模式下的虚拟机使用。</p>
<p><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/Serial Old收集器.png" alt="Serial Old收集器"></p>
<h2 id="3-5-Parallel-Old收集器"><a href="#3-5-Parallel-Old收集器" class="headerlink" title="3.5 Parallel Old收集器"></a>3.5 Parallel Old收集器</h2><p>Parallel Old是新生代收集器Prarllel Scavenge的老年代版本，使用多线程和“标记-整理”算法。运行流程如下：<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/Parallel Old收集器.png" alt="Parallel Old收集器"></p>
<h2 id="3-6-CMS收集器"><a href="#3-6-CMS收集器" class="headerlink" title="3.6 CMS收集器"></a>3.6 CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。对于互联网站或者B/S系统的这种注重响应速度的服务端来说，CMS是很好的选择。从名字Mark Sweep可以看出，CMS是基于“标记-清除”算法实现的，分为四个步骤：<br>（1）初始标记（CMS initial mark）：仅仅标记一GC Roots能直接关联到的对象，这个步骤需要“stop the world”；<br>（2）并发标记（CMS concurrent mark）：就是GC Roots进行可达性分析阶段，可并发执行；<br>（3）重新标记（CMS remark）：修正并发标记期间发生变动的那一部分对象，这个步骤需要“stop the world”；<br>（4）并发清除（CMS concurrent sweep）：执行清除阶段。<br>执行过程如下：<br><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/CMS收集器.png" alt="CMS收集器"><br>可以看到，初始标记和重新标记阶段都是并行的，需要暂停用户线程（过程比较短）；在并发标记和并发清除阶段是并发的，可以和用户线程一起工作。</p>
<p>CMS的优点：并发收集、低停顿。<br>CMS的缺点：<br>（1）对CPU资源非常敏感，面向并发设计程序的通病，虽然不至于导致用户线程停顿，但是会降低吞吐率；<br>（2）无法清理“浮动垃圾”，由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断出现，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次的GC；<br>（3）会产生大量空间碎片，因为CMS是基于“标记-清除”算法，这种算法的最大缺点就是会产生大量空间碎片，给分配大对象带来麻烦，不得不提前触发Full GC。为了解决这个问题，CMS提供了一个“-XX:+UseCMSCompaceAtFullCollection”的开关参数（默认开启），用于在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程。</p>
<h2 id="3-7-G1收集器"><a href="#3-7-G1收集器" class="headerlink" title="3.7 G1收集器"></a>3.7 G1收集器</h2><p>G1收集器是最新的一款收集器，JDK1.7才发布，是一种面向服务端应用的垃圾收集器，有如下特点：<br>（1）并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间；<br>（2）分代收集：分代概念在G1中依然得以保留。虽然G1可以不需其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果；<br>（3）空间整合：与CMS的“标记-清理”算法不同，G1从整体看来是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上看是基于“复制”算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存；<br>（4）可预测的停顿时间；</p>
<p>使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>G1的收集过程分为以下几个步骤：<br>（1）初始标记（Initial Marking）<br>（2）并发标记（Concurrent Marking）<br>（3）最终标记（Final Marking）<br>（4）筛选回收（Live Data Counting and Evacuation）<br>前几个步骤和CMS有很多相似之处。运行示意图如下：</p>
<p><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/G1收集器.png" alt="G1收集器"></p>
<h1 id="四：总结"><a href="#四：总结" class="headerlink" title="四：总结"></a>四：总结</h1><p><img src="/2018/02/08/Java虚拟机学习——垃圾收集器与内存分配策略/堆细化.png" alt="堆细化"><br>JVM内存模型中分两大块，一块是New Generation, 另一块是Old Generation. 在New Generation中，有一个叫Eden的空间，主要是用来存放新生的对象，还有两个Survivor Spaces（from,to）, 它们用来存放每次垃圾回收后存活下来的对象。在Old Generation中，主要存放应用程序中生命周期长的内存对象，还有个Permanent Generation，主要用来放JVM自己的反射对象，比如类对象和方法对象等。<br>1) 在New Generation块中，垃圾回收一般用复制算法，速度快。每次GC的时候，存活下来的对象首先由Eden拷贝到某个Survivor Space, 当Survivor Space空间满了后, 剩下的live对象就被直接拷贝到Old Generation中去。因此，每次GC后，Eden内存块会被清空</p>
<p>2) 在Old Generation块中，垃圾回收一般用标记整理的算法，速度慢些，但减少内存要求.</p>
<p>垃圾回收分多级，0级为全部(Full)的垃圾回收，会回收Old段中的垃圾；1级或以上为部分垃圾回收，只会回收New中的垃圾，内存溢出通常发生于Old段或Perm段垃圾回收后，仍然无内存空间容纳新的Java对象的情况。</p>
<p>Out Of Memory 只发生在jvm对old和perm generation 回收后还不能获足够内存的情况.<br>当生成一个新对象时，内存申请过程如下：<br>A. JVM会试图为相关Java对象在Eden中初始化一块内存区域<br>B. 当Eden空间足够时，内存申请结束。否则到下一步<br>C. JVM试图释放在Eden中所有不活跃的对象（这属于1或更高级的垃圾回收）, 释放后若Eden空间仍然不足以放入新对象，则试图将部分Eden中活跃对象放入Survivor区<br>D. Survivor区被用来作为Eden及Old的中间交换区域，当Old区空间足够时，Survivor区的对象会被移到Old区，否则会被保留在Survivor区<br>E. 当Old区空间不够时，JVM会在Old区进行完全的垃圾收集（0级）<br>F. 完全垃圾收集后，若Survivor及Old区仍然无法存放从Eden复制过来的部分对象，导致JVM无法在Eden区为新对象创建内存区域，则出现”out of memory错误”</p>
<p>造成full gc的原因<br>new了很多对象,没有即时在主动释放掉-&gt;Eden内存不够用-&gt;不断把对象往old迁移-&gt;old满了-&gt;full gc</p>
<p>总结：上面的内容就介绍了Java虚拟机如何管理对象的，我们也看到了上面主要就是收集算法和堆空间的从新划分，这样做的目的都是在于垃圾回收的高效执行，但是总归看来，如果对象交给系统来管理，在系统运行的过程效率肯定会有影响的，但是这有一点比较好，就是不需要手动管理，给程序猿带来方便。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：Java中是如何管理对象的&quot;&gt;&lt;a href=&quot;#一：Java中是如何管理对象的&quot; class=&quot;headerlink&quot; title=&quot;一：Java中是如何管理对象的&quot;&gt;&lt;/a&gt;一：Java中是如何管理对象的&lt;/h1&gt;&lt;p&gt;垃圾收集（Garbage Colle
    
    </summary>
    
      <category term="JVM" scheme="http://wangyuanjun.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://wangyuanjun.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机学习——Java内存区域与内存溢出异常</title>
    <link href="http://wangyuanjun.cn/2018/02/01/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://wangyuanjun.cn/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/</id>
    <published>2018-02-01T02:50:54.000Z</published>
    <updated>2018-02-11T05:52:30.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：运行时数据区域"><a href="#一：运行时数据区域" class="headerlink" title="一：运行时数据区域"></a>一：运行时数据区域</h1><p><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/MemoryArea.jpg" alt="MemoryArea"></p>
<h2 id="1-1-程序计数器（Program-Counter-Register）"><a href="#1-1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.1 程序计数器（Program Counter Register）"></a>1.1 程序计数器（Program Counter Register）</h2><p>程序计数器（Program Counter Register），也有称作为PC寄存器。在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。<br>虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示 执行哪条指令的。程序计数器（ Program Counter Register）是一块较小的内存空间，<font color="red">它的作用可以看做是当前线程所执行的字节码的行号指示器。</font>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序,此时程序计数器需要记录当前线程执行到哪一步了，以便下一次CPU可以在这个记录点上继续执行。因此，可以这么说，<font color="red">程序计数器是每个线程所私有的。</font></p>
<p>在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址,如果线程执行的是native方法，则程序计数器中的值是undefined。</p>
<p>由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于<font color="red">程序计数器是不会发生内存溢出现象(OutOfMemory)的。</font></p>
<h2 id="1-2-java虚拟机栈"><a href="#1-2-java虚拟机栈" class="headerlink" title="1.2 java虚拟机栈"></a>1.2 java虚拟机栈</h2><p>与程序计时器一样,<font color="red">虚拟机栈也是线程私有的，</font>它的生命周期与线程相同，虚拟机中描述的是Java方法执行的内存模型，<font color="red">每个方法在执行的同时都会创建一个栈帧（Stack Frame）(Java栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法)，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</font>每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈道出栈的过程。当线程执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。其中局部变量表中存放了编译器可知的各种基本数据类型、对象引用类型（不是对象本身）。</p>
<p>局部变量表，就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。局部变量表中存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用（ reference 类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。<font color="red">局部变量表所需的内存空间在编译期完成分配</font>，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期不会改变局部变量大小。</p>
<p>操作数栈，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的以及参数的传递。</p>
<p>指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。</p>
<p>方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。<br>由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。<br> 对于java虚拟机栈，有两种异常情况：<br><strong>1)如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常 。</strong><br><strong>2)如果虚拟机栈扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</strong><br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/java虚拟机栈.png" alt="java虚拟机栈"></p>
<h2 id="1-3-本地方法栈（Native-Method-Stack）"><a href="#1-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.3 本地方法栈（Native Method Stack）"></a>1.3 本地方法栈（Native Method Stack）</h2><p><font color="red">线程私有。</font>本地方法栈与Java栈的作用和原理非常相似。区别只不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，<font color="red">而本地方法栈则是为虚拟机使用到的 Native方法服务</font>。有的虚拟机（譬如 Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。<br>与虚拟机栈一样，本地方法栈也会抛出StackOverflowError和OutMemoryError错误。</p>
<h2 id="1-4-java堆-Java-Heap"><a href="#1-4-java堆-Java-Heap" class="headerlink" title="1.4 java堆(Java Heap)"></a>1.4 java堆(Java Heap)</h2><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。<font color="red">Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</font></p>
<p><font color="red">Java 堆是垃圾收集器管理的主要区域</font>，因此很多时候也被称做“GC 堆”（Garbage Collected Heap）。如果从内存回收的角度看，由于<font color="red">现在收集器基本采用分代回收算法，所以Java堆还可细分为：新生代（Young Generation）与老生代(Old Generation)；再细致一点的有Eden空间,From Survivor空间,To Survivor空间等。</font><strong>值得注意的是，从JKD1.7开始，永久代Perm逐渐被移除，最新的JDK1.8中已经使用元空间（MetaSpace）代替永久代。</strong>如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。但无论怎么去划分，无论那个区域，java堆中存储的依然是对象的实例。进一步划分的目的是为了更好地回收内存，或者更快地分配内存。<br>当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果堆中没有内存完成实例分配，并且对也无法再扩展时，将会抛出OutOfMemoryError异常。<br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/java堆.jpg" alt="java堆"><br>如图，新生代还可以分为Eden空间、From Survivor空间、To Survivor空间。<br>永久代(Permanent Generation)用于存储静态类型数据，与垃圾收集器关系不大。<br>注意：本图展示的是JVM堆的内存模型，JVM堆内存包括Java堆区域 和 永久代区域。因此，永久代不属于Java堆。</p>
<h2 id="1-5-方法区（Method-Area）"><a href="#1-5-方法区（Method-Area）" class="headerlink" title="1.5 方法区（Method Area）"></a>1.5 方法区（Method Area）</h2><p><font color="red">方法区是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 </font>。</p>
<p>方法区与堆一样，是各个线程共享的内存区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。<br>在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。<font color="red">不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。<br>相对而言，垃圾收集行为在这个区域比较少出现，但并非数据进了方法区就永久的存在了，<font color="red">这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</font><br><strong>JDK1.7中，已经把放在永久代的字符串常量池移到堆中。JDK1.8撤销永久代，引入元空间。</strong></font></p>
<p>根据java虚拟机规范的规定：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h2 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6 运行时常量池"></a>1.6 运行时常量池</h2><p>运行时常量池是方法区的一部分，在Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。这部分内容将<font color="red">在类加载后进入方法区的运行时常量池中存放</font>。</p>
<p><font color="red">同时运行时常量池具备动态性</font>，并非预置入Class文件中常量池的内存才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，例如String类的intern()方法(方法返回s1在常量池中的引用，没有则创建)。<br>既然运行时常量池是方法区的一部分，自然受到方法区内存限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h2 id="1-7-直接内存（Direct-Memory）"><a href="#1-7-直接内存（Direct-Memory）" class="headerlink" title="1.7 直接内存（Direct Memory）"></a>1.7 直接内存（Direct Memory）</h2><p><font color="red">直接内存（Direct memory）并不是JVM运行时数据区的一部分</font>，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁使用，而且它也可能导致OutOfMemoryError异常出现。</p>
<p>直接内存不是虚拟机运行时数据区的一部分，在NIO类中引入一种基于通道与缓冲区的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因此避免了在java堆和Native堆中来回复制数据。</p>
<p>本机直接内存的分配不会受到Java堆大小的限制，但是，还是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制，从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h1 id="二：hotspot虚拟机对象奥秘"><a href="#二：hotspot虚拟机对象奥秘" class="headerlink" title="二：hotspot虚拟机对象奥秘"></a>二：hotspot虚拟机对象奥秘</h1><h2 id="2-1-对象的创建过程"><a href="#2-1-对象的创建过程" class="headerlink" title="2.1 对象的创建过程"></a>2.1 对象的创建过程</h2><p>Java在语言层面，通过一个关键字new来创建对象。在虚拟机中，当遇到一条new指令后，将开始如下创建过程：</p>
<h3 id="2-1-1-判断类是否加载、解析、初始化"><a href="#2-1-1-判断类是否加载、解析、初始化" class="headerlink" title="2.1.1 判断类是否加载、解析、初始化"></a>2.1.1 判断类是否加载、解析、初始化</h3><p>虚拟机遇到一条new指令时，先去检查这个指定的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那先执行相应的类加载过程。</p>
<h3 id="2-1-2-为新对象分配内存"><a href="#2-1-2-为新对象分配内存" class="headerlink" title="2.1.2 为新对象分配内存"></a>2.1.2 为新对象分配内存</h3><p>前面说到，对象的内存分配是在Java堆中的，对象所需内存的大小在类加载完便可确实。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来，此时Java堆中的情况有两种可能，一种是Java堆中内存是绝对规整的，一种是Java堆中的内存并不是规整的。因此有两种分配方式：</p>
<ol>
<li>Java堆内存是规整的，即所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，此时，分配内存仅需要把这个指针向空闲空间那边挪动一段与对象大小相等的距离，这种方式也称为“指针碰撞”（Bump the Pointer）；</li>
<li>Java堆内存不是规整的，即已使用的内存和空闲的内存相互交错，就没有办法简单地进行指针的移动，此时的分配方案是，虚拟机必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的控件划分给对象实例，并更新列表上的记录，这种方式也称为“空闲列表”（Free List）；</li>
</ol>
<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，对于Serial、ParNew等带Compact过程的垃圾收集器，系统采用的是指针碰撞算法；对于CMS这种基于Mark-Sweep算法的收集器，通常采用空闲列表算法。</p>
<h3 id="2-1-3-解决并发安全问题"><a href="#2-1-3-解决并发安全问题" class="headerlink" title="2.1.3 解决并发安全问题"></a>2.1.3 解决并发安全问题</h3><p>确定了如何划分内存空间之后，还有一个问题就是，对象的创建在虚拟机中是非常频繁的行为，比如，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，解决这种并发问题，一般有两种方案：</p>
<ol>
<li>对分配内存空间的动作进行同步处理，比如，虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；</li>
<li>另一种方式是，把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的TLAB上分配。只有TLAB用完并分配新的TLAB时，才需要同步锁定，虚拟机是否使用TLAB，可以通过-XX:+/-UserTLAB参数来设定。</li>
</ol>
<h3 id="2-1-4-初始化分配到的内存空间"><a href="#2-1-4-初始化分配到的内存空间" class="headerlink" title="2.1.4 初始化分配到的内存空间"></a>2.1.4 初始化分配到的内存空间</h3><p>内存分配完成后，虚拟机将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作也可以提前至TLAB分配时进行。也正是这一步操作，才保证了我们对象的实例字段在Java代码中可以不赋初值就直接使用。注意，此时对象的实例字段全部为零值，并没有按照程序中的初值进行初始化。</p>
<h3 id="2-1-5-设置对象实例的对象头"><a href="#2-1-5-设置对象实例的对象头" class="headerlink" title="2.1.5 设置对象实例的对象头"></a>2.1.5 设置对象实例的对象头</h3><p>上面工作完成后，虚拟机对对象进行必要的设置，主要是设置对象的对象头信息，比如，这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等…</p>
<h3 id="2-1-6-初始化对象方法"><a href="#2-1-6-初始化对象方法" class="headerlink" title="2.1.6 初始化对象方法"></a>2.1.6 初始化对象<init>方法</init></h3><p>其实，上面工作完成后，从虚拟机角度来看，一个新的对象已经产生了，但从Java程序的角度来看，对象创建才刚刚开始，对象实例中的字段仅仅都为零值，还需要通过<init>方法进行初始化，把对象按照程序员的意愿进行初始化。此时，一个真正可用的对象才算完全产生出来。</init></p>
<h2 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h2><p>经过前面的创建工作，一个对象已经成功产生，也已经在Java堆中分配好了内存。那这个对象在Java堆内存中到底是什么形态呢？又包括哪些部分呢？这就涉及到了对象的内存布局了。<br>不同的虚拟机实现中，对象的内存布局有差别，以最常用的HotSpot虚拟机为例，对象在内存中存储的布局分为3块区域：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）。</p>
<ul>
<li>对象头：包含两部分信息，一部分是用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志等；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，对象头中还有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组大小。</li>
<li>实例数据：真正存储对象有效信息的部分。也就是在程序中定义的各种类型的字段内容，包括从父类继承下来的，以及子类中定义的，都会在实例数据中记录。</li>
<li>对齐填充：不是必然存在的，仅起着占位符的作用，对于HotSpot来说，虚拟机的自动内存管理系统要求对象其实地址必须是8字节的整数倍，因此，如果对象实例数据部分没有对齐时，就需要通过对齐填充的方式来补全。</li>
</ul>
<h2 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h2><p>建立了对象是为了使用对象，我们对数据的使用是通过栈上的reference数据来操作堆上的具体对象，对于不同的虚拟机实现，reference数据类型有不同的定义，主要是如下两种访问方式：</p>
<h3 id="2-3-1-使用句柄访问"><a href="#2-3-1-使用句柄访问" class="headerlink" title="2.3.1 使用句柄访问"></a>2.3.1 使用句柄访问</h3><p>此时，Java堆中将会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图：<br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/句柄访问.png" alt="句柄访问"></p>
<h3 id="2-3-2-使用直接指针访问"><a href="#2-3-2-使用直接指针访问" class="headerlink" title="2.3.2 使用直接指针访问"></a>2.3.2 使用直接指针访问</h3><p>此时reference中存储的就是对象的地址。如下图：<br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/直接指针访问.png" alt="直接指针访问"></p>
<p>上面所说的，所谓对象类型，其实就是指，对象所属的哪个类。</p>
<p>上面两种对象访问方式各有优势，使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时，只会改变句柄中的实例数据指针，而reference本身不需要修改；使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销（根据上图，节省的是对象实例数据的指针定位），由于对象的访问在Java中非常频繁，因此，这类开销积少成多后也是一项非常可观的执行成本。对于HotSpot而言，选择的是第二种方式。</p>
<h1 id="三：内存溢出"><a href="#三：内存溢出" class="headerlink" title="三：内存溢出"></a>三：内存溢出</h1><p><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/内存溢出测试.png" alt="内存溢出测试"><br><img src="/2018/02/01/Java虚拟机学习——Java内存区域与内存溢出异常/内存区域报错.png" alt="内存区域报错"><br>OOM分为两种情况：内存溢出（Memory Overflow）和内存泄漏（Memory Leak）。</p>
<h2 id="3-1-OutOfMemoryError"><a href="#3-1-OutOfMemoryError" class="headerlink" title="3.1 OutOfMemoryError"></a>3.1 OutOfMemoryError</h2><p>是指程序在申请内存时，没有足够的空间供其使用，出现了Out Of Memory，也就是要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。<br>内存溢出分为上溢和下溢，比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。</p>
<h3 id="3-1-1-java堆溢出-OutOfMemoryError：Java-heap-space"><a href="#3-1-1-java堆溢出-OutOfMemoryError：Java-heap-space" class="headerlink" title="3.1.1 java堆溢出(OutOfMemoryError：Java heap space)"></a>3.1.1 java堆溢出(OutOfMemoryError：Java heap space)</h3><p>是被所有线程共享的一块内存区域，该内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配创建。由于他是虚拟机中管理的最大一块内存，所以是主要的收集区域。如果还需要再堆上分配实例，但是无法扩展出足够的内存空间，将会抛出OutOfMemoryError异常。<br><strong>Java堆用于存储对象实例，我们只要不断的创建对象，而又没有及时回收这些对象（即内存泄漏），就会在对象数量达到最大堆容量限制后产生内存溢出异常。</strong><br>如下代码限制java堆的大小为1m，不可扩展（就堆的最小值-Xms参数与最大值-Xmx参数设置为一样的即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出时Dump出当前的转储快照以便事后进行分析。<br>    /**</p>
<pre><code> * VM Args: -Xms1m -Xmx1m -XX:+HeapDumpOnOutOfMemoryError
 * java堆溢出
 * 
 * @author：WangYuanJun
 * @date：2018年2月7日 下午2:22:42
 */
public class HeapOOM {

    static class OOMObejct {
    }

    public static void main(String[] args) {
        List&lt;OOMObejct&gt; list = new ArrayList&lt;&gt;();

        while (true) {
            list.add(new OOMObejct());
        }
    }
}

java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid4008.hprof ...
Heap dump file created [2760158 bytes in 0.013 secs]
Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
    at com.example.demo.test3.HeapOOM.main(HeapOOM.java:21)
</code></pre><h3 id="3-1-2-虚拟机栈和本地方法栈溢出-OutOfMemoryError：Java-heap-space"><a href="#3-1-2-虚拟机栈和本地方法栈溢出-OutOfMemoryError：Java-heap-space" class="headerlink" title="3.1.2 虚拟机栈和本地方法栈溢出(OutOfMemoryError：Java heap space)"></a>3.1.2 虚拟机栈和本地方法栈溢出(OutOfMemoryError：Java heap space)</h3><p>虚拟机栈：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表（基本数据类型和对象引用）、操作数栈、方法出口等信息。栈的大小可以固定也可以动态扩展。当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError的错误，不过这个深度范围不是一个恒定的值，我们通过下面这段程序可以测试一下这个结果<br>当应用程序递归太深而发生堆栈溢出时，抛出该错误。因为栈一般默认为1-2m，一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过1m而导致溢出。<br>栈溢出的原因：<br>（1）递归调用<br>（2）大量循环或死循环<br>（3）全局变量是否过多<br>（4）数组、List、Map数据过大<br><strong>1)如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常 。</strong></p>
<pre><code>/**
 * VM Args: -Xss160k
 * 
 * 
 * @author：WangYuanJun
 * @date：2018年2月7日 下午2:45:03
 */
public class JavaVMStackSOF {
    private int stackLen = 1;

    public void stackLeak() {
        stackLen++;
        stackLeak();
    }

    public static void main(String[] args) throws Throwable {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println(&quot;stack length:&quot; + oom.stackLen);
            throw e;
        }
    }
}

stack length:771Exception in thread &quot;main&quot; 
java.lang.StackOverflowError
    at com.wdm.mem.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:11)
    at com.wdm.mem.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
    at com.wdm.mem.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
    at com.wdm.mem.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:12)
</code></pre><p><strong>2)如果虚拟机栈扩展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。</strong></p>
<pre><code> /**
 * VM Args: -Xss2m
 * 
 * 
 * @author：WangYuanJun
 * @date：2018年2月7日 下午3:04:59
 */
public class JavaVMStackOOM {

    private void dontStop() {
        while (true) {

        }
    }

    public void stackLeakByThread() {
        while (true) {
            Thread thread = new Thread(new Runnable() {

                @Override
                public void run() {
                    dontStop();
                }
            });
            thread.start();
        }

    }

    public static void main(String[] args) {
        JavaVMStackOOM javaVMStackOOM = new JavaVMStackOOM();
        javaVMStackOOM.stackLeakByThread();
    }
}

Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread
</code></pre><h3 id="3-1-3-方法区和运行常量池溢出"><a href="#3-1-3-方法区和运行常量池溢出" class="headerlink" title="3.1.3 方法区和运行常量池溢出"></a>3.1.3 方法区和运行常量池溢出</h3><p>1.方法区溢出<br>绝大部分 Java 程序员应该都见过 “java.lang.OutOfMemoryError: PermGen space “这个异常。这里的 “PermGen space”其实指的就是方法区。不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。我们现在通过动态生成类来模拟 “PermGen space”的内存溢出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">  * jdk1.7</div><div class="line">  * VM Args: -XX:PermSize=8M -XX:MaxPermSize=8M</div><div class="line">  *</div><div class="line">  * @author：WangYuanJun</div><div class="line">  * @date：2018年2月2日 下午1:42:48</div><div class="line">  */</div><div class="line">public class PermGenOomMock&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        URL url = null;</div><div class="line">        List&lt;ClassLoader&gt; classLoaderList = new ArrayList&lt;ClassLoader&gt;();</div><div class="line">        try &#123;</div><div class="line">            url = new File(&quot;/tmp&quot;).toURI().toURL();</div><div class="line">            URL[] urls = &#123;url&#125;;</div><div class="line">            while (true)&#123;</div><div class="line">                ClassLoader loader = new URLClassLoader(urls);</div><div class="line">                classLoaderList.add(loader);</div><div class="line">                loader.loadClass(&quot;com.example.demo.test2.test&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: PermGen space</div></pre></td></tr></table></figure></p>
<p>本例中使用的 JDK 版本是 1.7，指定的 PermGen 区的大小为 8M。通过每次生成不同URLClassLoader对象来加载Test类，从而生成不同的类对象，这样就能看到我们熟悉的 “java.lang.OutOfMemoryError: PermGen space “ 异常了。这里之所以采用 JDK 1.7，是因为在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间） 的东西。下面我们就来看看 Metaspace 与 PermGen space 的区别。可参考<a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p>
<p>2.运行常量池溢出 </p>
<p>其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。我们可以通过一段程序来比较 JDK 1.6 与 JDK 1.7及 JDK 1.8 的区别，以字符串常量为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">运行常量池溢出(jdk1.6及jdk1.6之前)</div><div class="line">/**</div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M -Xmx16m</div><div class="line"> * 使用jdk1.6及jdk1.6之前</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年2月2日 下午2:10:12</div><div class="line"> */</div><div class="line">public class RuntimeConsPoolOOM &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        int i = 0;</div><div class="line">        while (true) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError： PermGen space</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M -Xmx16m</div><div class="line"> * 使用jdk1.7</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年2月2日 下午2:10:12</div><div class="line"> */</div><div class="line">public class RuntimeConsPoolOOM &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        int i = 0;</div><div class="line">        while (true) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError： Java heap space</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * VM Args: -Xmx16m</div><div class="line"> * 使用jdk1.8</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年2月2日 下午2:10:12</div><div class="line"> */</div><div class="line">public class RuntimeConsPoolOOM &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">        int i = 0;</div><div class="line">        while (true) &#123;</div><div class="line">            list.add(String.valueOf(i++).intern());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError： Java heap space</div></pre></td></tr></table></figure>
<p>　　从上述结果可以看出，JDK 1.6下，会出现“PermGen Space”的内存溢出，而在 JDK 1.7和 JDK 1.8 中，会出现堆内存溢出，并且 JDK 1.8中 PermSize 和 MaxPermGen 已经无效。因此，可以大致验证 JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中，并且 JDK 1.8 中已经不存在永久代的结论。现在我们看看元空间到底是一个什么东西？</p>
<p>　　元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p>
<p>　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。<br>　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</p>
<p>　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：<br>　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集<br>　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集</p>
<p>现在我们在 JDK 8下重新运行一下代码段 ，不过这次不再指定 PermSize 和 MaxPermSize。而是指定 MetaSpaceSize 和 MaxMetaSpaceSize的大小。输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line">  * jdk1.8</div><div class="line">  * -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m</div><div class="line">  * 1.8无PermGen space，取而代之是一个叫做 Metaspace（元空间）</div><div class="line">  * Metaspace（元空间）内存溢出</div><div class="line">  * 解决：增大perm区，允许class回收 </div><div class="line">  * </div><div class="line">  * @author：WangYuanJun</div><div class="line">  * @date：2018年2月2日 下午1:42:48</div><div class="line">  */</div><div class="line">public class PermGenOomMock&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        URL url = null;</div><div class="line">        List&lt;ClassLoader&gt; classLoaderList = new ArrayList&lt;ClassLoader&gt;();</div><div class="line">        try &#123;</div><div class="line">            url = new File(&quot;/tmp&quot;).toURI().toURL();</div><div class="line">            URL[] urls = &#123;url&#125;;</div><div class="line">            while (true)&#123;</div><div class="line">                ClassLoader loader = new URLClassLoader(urls);</div><div class="line">                classLoaderList.add(loader);</div><div class="line">                loader.loadClass(&quot;com.example.demo.test2.test&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError： Metaspace</div></pre></td></tr></table></figure></p>
<h3 id="3-1-4-本机直接内存溢出"><a href="#3-1-4-本机直接内存溢出" class="headerlink" title="3.1.4 本机直接内存溢出"></a>3.1.4 本机直接内存溢出</h3><p>通过参数-XX:MaxDirectMemorySize指定DirectMemory容量，若不指定则与Java堆最大值一样。可以直接通过反射获取Unsafe实例并进行内存分配，使用unsafe.allocateMemory()申请分配内存。不足时会出现OutOfMemoryError。</p>
<h2 id="3-2-内存泄露（memory-leak）"><a href="#3-2-内存泄露（memory-leak）" class="headerlink" title="3.2 内存泄露（memory leak）"></a>3.2 内存泄露（memory leak）</h2><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光，举个例子，就是说系统的篮子（内存）是有限的，而你申请了一个篮子，拿到之后没有归还（忘记还了或是丢了），于是造成一次内存泄漏。在你需要用篮子的时候，又去申请，如此反复，最终系统的篮子无法满足你的需求，最终会由内存泄漏造成内存溢出。</p>
<h1 id="四：总结"><a href="#四：总结" class="headerlink" title="四：总结"></a>四：总结</h1><h2 id="4-1-内存区域模型小结："><a href="#4-1-内存区域模型小结：" class="headerlink" title="4.1 内存区域模型小结："></a>4.1 内存区域模型小结：</h2><pre><code>（1）线程私有的区域：程序计数器、虚拟机栈、本地方法栈；
（2）所有线程共享的区域：Java堆、方法区；（注：直接内存不属于虚拟机内存模型的部分）
（3）没有异常的区域：程序计数器；
（4）StackOverflowError异常：Java虚拟机栈、本地方法栈；
（5）OutOfMemoryError异常：除程序计数器外的其他四个区域，Java虚拟机栈、本地方法栈、Java堆、方法区；直接内存也会出现OutOfMemoryError。
</code></pre><h2 id="4-2-类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？"><a href="#4-2-类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？" class="headerlink" title="4.2 类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？"></a>4.2 类和对象在运行时的内存里是怎么样的？以及各类型变量、方法在运行时是怎么交互的？</h2><pre><code>- 在程序运行时类是在方法区，实例对象本身在堆里面。
- 方法字节码在方法区。
- 线程调用方法执行时创建栈帧并压栈，方法的参数和局部变量在栈帧的局部变量表。
- 对象的实例变量和对象一起在堆里，所以各个线程都可以共享访问对象的实例变量。
- 静态变量在方法区，所有对象共享。字符串常量等常量在运行时常量池。
- 各线程调用的方法，通过堆内的对象，方法区的静态数据，可以共享交互信息。
</code></pre><p>对于JVM的内存管理， 最重要的还是与OS内存管理知识进行类比以及结合实践来学习。理解JVM内存区域的目的也是为了在工程中出现内存相关异常时能够准确的定位所在区域，及时处理。</p>
<p>参考:<br>周志明:《深入理解Java虚拟机：JVM高级特性与最佳实践》<br><!-- [http://blog.csdn.net/qq_36859415/article/details/53407439](http://blog.csdn.net/qq_36859415/article/details/53407439)
[https://www.cnblogs.com/ACFLOOD/p/5608292.html](https://www.cnblogs.com/ACFLOOD/p/5608292.html)
[http://www.cnblogs.com/paddix/p/5309550.html](http://www.cnblogs.com/paddix/p/5309550.html)
[https://www.cnblogs.com/hawk-whu/p/6731260.html](https://www.cnblogs.com/hawk-whu/p/6731260.html)
[http://blog.csdn.net/jiyiqinlovexx/article/details/51171452](http://blog.csdn.net/jiyiqinlovexx/article/details/51171452)
[http://blog.csdn.net/u011080472/article/details/51320300](http://blog.csdn.net/u011080472/article/details/51320300) --></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：运行时数据区域&quot;&gt;&lt;a href=&quot;#一：运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;一：运行时数据区域&quot;&gt;&lt;/a&gt;一：运行时数据区域&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/2018/02/01/Java虚拟机学习——Java内存区域与
    
    </summary>
    
      <category term="JVM" scheme="http://wangyuanjun.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://wangyuanjun.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>IntelliJ IDEA 2017.3激活</title>
    <link href="http://wangyuanjun.cn/2018/01/31/IntelliJ-IDEA-2017-3%E6%BF%80%E6%B4%BB/"/>
    <id>http://wangyuanjun.cn/2018/01/31/IntelliJ-IDEA-2017-3激活/</id>
    <published>2018-01-31T15:42:34.000Z</published>
    <updated>2018-02-01T13:21:04.866Z</updated>
    
    <content type="html"><![CDATA[<p>最新的IDEA激活方式，博主使用的是3.4的版本</p>
<h1 id="方法一：使用激活服务器激活方法-博主使用此方法"><a href="#方法一：使用激活服务器激活方法-博主使用此方法" class="headerlink" title="方法一：使用激活服务器激活方法(博主使用此方法)"></a>方法一：使用激活服务器激活方法(博主使用此方法)</h1><p>由于JetBrains封杀，大部分激活服务器已经不能使用，目前可用的网址有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://idea.java.sx</div></pre></td></tr></table></figure>
<p><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/1.png" alt="1"></p>
<p>步骤<br>1、打开注册/激活窗口；</p>
<p>2、选择 License server；</p>
<p>3、填入上述其中一个网址；</p>
<p>4、点击Activate即可完美激活!</p>
<h1 id="方法二：注册码激活方法"><a href="#方法二：注册码激活方法" class="headerlink" title="方法二：注册码激活方法"></a>方法二：注册码激活方法</h1><p>1、进入hosts文件中：C:\Windows\System32\drivers\etc\hosts<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/2.png" alt="2"><br>2、将“0.0.0.0 account.jetbrains.com”添加到hosts文件中<br>注意：添加只有重新打开hosts文件进行确认之后在进行下一步操作。<br>修改成功后如图所示：<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/3.png" alt="3"><br>注：将这条数据加入之后会提示保存，然后确认之后，重新打开hosts文件确认是否添加成功，有时候会提示确认两次。<br>3、点击获得注册码，<a href="http://idea.lanyus.com/" target="_blank" rel="external">点我</a>，然后将注册码复制，粘贴到IDEA中<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/4.png" alt="4"><br>4、点击获得注册码即可获得IDEA激活码。<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/5.png" alt="5"></p>
<h1 id="方法三：本地搭建激活服务器激活方法"><a href="#方法三：本地搭建激活服务器激活方法" class="headerlink" title="方法三：本地搭建激活服务器激活方法"></a>方法三：本地搭建激活服务器激活方法</h1><p>1、下载IDEA本地服务器，<a href="https://pan.baidu.com/s/1qZAnpF2" target="_blank" rel="external">点我下载(密码jx0m)</a></p>
<p>2、解压到本地硬盘任意位置，运行相应程序，32位操作系统请双击运行32位程序，64位操作系统请双击运行64位程序，如下图：<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/6.png" alt="6"><br>3、运行结果如图：<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/7.png" alt="7"><br>4、打开IDEA，在激活框内输入上图标示的网址即可。</p>
<p>注：在新版本IDEA2017.3中可能会出现无法激活的情况，此时将网址改为<a href="http://0.0.0.0:1017即可。" target="_blank" rel="external">http://0.0.0.0:1017即可。</a></p>
<h1 id="方法四：破解补丁激活方法"><a href="#方法四：破解补丁激活方法" class="headerlink" title="方法四：破解补丁激活方法"></a>方法四：破解补丁激活方法</h1><p>（1）破解补丁下载<br><a href="https://pan.baidu.com/s/1pM6l95h" target="_blank" rel="external">点我下载(密码jilt)</a><br>将下载的破解补丁放在你的安装IDEA下面的bin的目录下面（如图），本文示例为E:\develop-tools\toolsInstall\idea\IntelliJ IDEA 2017.3.4\bin<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/8.png" alt="8"><br>（2）修改配置文件</p>
<p>在安装的IDEA下面的bin目录下面有2个文件 ： idea.exe.vmoptions和idea64.exe.vmoptions。<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/10.png" alt="10"><br>用记事本打开，在上述两个文件的最后一行均加上下面这段代码（红色字体部分为你的IDEA安装目录）：</p>
<p>-javaagent:E:\develop-tools\toolsInstall\idea\IntelliJ IDEA 2017.3.4\bin\JetbrainsCrack-2.6.10-release-enc.jar</p>
<p>（3）输入激活码</p>
<p>启动IDEA，第一次进入会提示激活，选择Activation Code，并输入如下激活码：</p>
<pre><code>BIG3CLIK6F-eyJsaWNlbnNlSWQiOiJCSUczQ0xJSzZGIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiQUMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJSQyIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDE3LTExLTIzIn0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMTctMTEtMjMifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxNy0xMS0yMyJ9XSwiaGFzaCI6IjQ3NzU1MTcvMCIsImdyYWNlUGVyaW9kRGF5cyI6MCwiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-iygsIMXTVeSyYkUxAqpHmymrgwN5InkOfeRhhPIPa88FO9FRuZosIBTY18tflChACznk3qferT7iMGKm7pumDTR4FbVVlK/3n1ER0eMKu2NcaXb7m10xT6kLW1Xb3LtuZEnuis5pYuEwT1zR7GskeNWdYZ0dAJpNDLFrqPyAPo5s1KLDHKpw+VfVd4uf7RMjOIzuJhAAYAG+amyivQt61I9aYiwpHQvUphvTwi0X0qL/oDJHAQbIv4Qwscyo4aYZJBKutYioZH9rgOP6Yw/sCltpoPWlJtDOcw/iEWYiCVG1pH9AWjCYXZ9AbbEBOWV71IQr5VWrsqFZ7cg7hLEJ3A==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==
</code></pre><p>（4）软件启动，进入Help，选择About，页面显示December 31，2099到期，完成激活。如下图：<br><img src="/2018/01/31/IntelliJ-IDEA-2017-3激活/9.png" alt="9"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最新的IDEA激活方式，博主使用的是3.4的版本&lt;/p&gt;
&lt;h1 id=&quot;方法一：使用激活服务器激活方法-博主使用此方法&quot;&gt;&lt;a href=&quot;#方法一：使用激活服务器激活方法-博主使用此方法&quot; class=&quot;headerlink&quot; title=&quot;方法一：使用激活服务器激活方
    
    </summary>
    
      <category term="IDEA" scheme="http://wangyuanjun.cn/categories/IDEA/"/>
    
    
      <category term="工具" scheme="http://wangyuanjun.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="IDEA" scheme="http://wangyuanjun.cn/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机学习——类加载机制</title>
    <link href="http://wangyuanjun.cn/2018/01/31/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://wangyuanjun.cn/2018/01/31/Java虚拟机学习——类加载机制/</id>
    <published>2018-01-31T09:28:16.000Z</published>
    <updated>2018-02-11T05:52:39.755Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：类加载机制概述"><a href="#一：类加载机制概述" class="headerlink" title="一：类加载机制概述"></a>一：类加载机制概述</h1><p><strong>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</strong><br>在java中，<font color="red">类型的加载、连接和初始化过程都是在程序运行期间完成的</font>，这种策略虽然会带来一些性能开销，但是却为java应用程序提供了高度的灵活性，java动态扩展的语言特性就是依赖运行期动态加载和动态链接这个特点形成的，所谓java动态扩展，比如，如果编写了一个面向接口的应用程序，可以等到运行时再指定其实际的实现类。</p>
<h1 id="二：类加载时机"><a href="#二：类加载时机" class="headerlink" title="二：类加载时机"></a>二：类加载时机</h1><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载，共七个阶段。其中，验证、准备、解析3个阶段称为连接（Linking），7个过程发生顺序如下：<br><img src="/2018/01/31/Java虚拟机学习——类加载机制/类加载过程.png" alt="类加载过程"><br>上面这七个过程，除了解析这个过程外，其余过程必须按部就班地执行，即顺序是确定的，而解析过程不一定，在某些情况下可以在初始化阶段之后再执行，这是为了支持java语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<p>java虚拟机规范中，并没有规定类加载过程中的第一个阶段（即加载阶段）的执行时机，但是对于初始化阶段，虚拟机规范中严格规定了<font color="red">“有且只有”下面5种情况下必须立即对类进行初始化</font>（而这时，加载、验证、准备自然需要在此之前开始）：<br>（1）遇到new、getstatic、putstatic、invokestatic这四条指令时，必须触发其初始化。这四条指令最常见的场景是：使用new关键字实例化对象、读取或设置一个类的静态字段（被final修饰、已经在编译期把结果放入常量池的静态字段除外，即常量除外）、调用一个类的静态方法的时候；<br>（2）进行反射调用的时候；<br>（3）初始化一个类的时候，如果其父类还没有初始化，则需要先触发其父类的初始化；<br>（4）当虚拟机启动时，需要先初始化那个包含main方法的要执行的主类；<br>（5）当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic 、REF_putStatic、REF_invokeStatic的方法句柄，句柄对应的类会被初始化；</p>
<p>上面五种场景触发类进行初始化的行为称为对一个类进行“主动引用”，除此之外，所有其他引用类的方式都不会触发初始化步骤（注意，此时已经是引用了，只不过不会触发初始化，其他阶段是否触发要看具体虚拟机的实现），这些引用称为“被动引用”。<br><strong>被动引用的几个例子</strong>：<br>（1）对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。至于是否要出发子类的加载、验证需要看具体虚拟机实现；如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class SuperClass&#123;  </div><div class="line">    static&#123;  </div><div class="line">        System.out.println(&quot;SuperClass init!&quot;);  </div><div class="line">    &#125;  </div><div class="line">    public static int value = 123;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">class SubClass extends SuperClass&#123;  </div><div class="line">    static&#123;  </div><div class="line">        System.out.println(&quot;SubClass init!&quot;);//子类中引用父类的静态字段，不会导致类初始化  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">public class Test &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        System.out.println(SubClass.value);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init!</div><div class="line">123</div></pre></td></tr></table></figure></p>
<p>可以看到，只会打印出父类的初始化语句。</p>
<p>（2）通过数组定义来引用类，不会触发此类的初始化。如 A[] ints = new A[10] ，  不会触发A 类的初始化。而是会触发名为 LA的类初始化。它是一个由虚拟机自动生成的、直接继承于Object 的子类，创建动作由字节码指令 newarray 触发。这个类代表了一个元素类型为 A 的一位数组，数组中的属性和方法都实现在这个类中。Java 语言中数组的访问比C/C++ 安全是因为这个类封装了数组元素的访问方法。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SuperClass[] sca = new SuperClass[10];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SuperClass类为上面的那个，运行后发现并没有打印出SuperClass init!，说明没有触发SuperClass类的初始化阶段。</p>
<p>（3）常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class ConstClass&#123;  </div><div class="line">    static&#123;  </div><div class="line">        System.out.println(&quot;ConstClass init!&quot;);  </div><div class="line">    &#125;  </div><div class="line">    public static final String HELLOWORLD = &quot;hello world&quot;;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line">public class Test &#123;  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        System.out.println(ConstClass.HELLOWORLD);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hello world</div></pre></td></tr></table></figure></p>
<p>只是输出了hello world，并没有输出ConstClass init!，可见ConstClass类并没有被初始化。</p>
<p>注意：<br>上面讲的三个例子是被动引用的情况，很多情况下我们会通过new来初始化一个类，这个情形它属于上面提到的5种主动引用的场景，因此会触发这个类的初始化，如果这个类有父类的话，会先触发父类的初始化。注意不要和上面的被动引用搞混了。</p>
<p>接口的初始化<br>上面代码中用static语句块进行初始化，而结构中不能使用static语句块，但是编译器仍然回味接口生成&lt;clinit&gt;()类构造器来初始化接口中的成员变量（常量）；接口与类初始化的区别主要是在上面五种主动引用中的第三种：当一个类在初始化时，要求其父类全部已经初始化过了，但是对于接口的初始化来说，并不要求其父接口全部都完成了初始化，只有在真正使用到付接口的时候（如引用接口中定义的常量）才会初始化。</p>
<h1 id="三：类加载过程"><a href="#三：类加载过程" class="headerlink" title="三：类加载过程"></a>三：类加载过程</h1><h2 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h2><p>在加载阶段，需要完成三件事情：<br>（1）通过一个类的全限定名来获取其定义的二进制字节流。(<font color="red">获取.class文件的二进制流</font>)</p>
<p>（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。(<font color="red">将类信息、静态变量、字节码、常量这些.class文件中的内容放入方法区中</font>)</p>
<p>（3）在内存中生成一个代表这个类的java.lang.Class对象（并没有明确规定是在java堆中，对于HotSpot虚拟机来说，Class对象比较特殊，它虽然是对象，但是存放在方法区里面），作为对方法区中这些数据的访问入口。(<font color="red">在内存中生成一个代表这个.class文件的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机比较特殊，这个Class对象是放在方法区中的</font>)</p>
<p>对于（1），并没有指明二进制字节流的获取途径，也即不一定都是从一个Class文件中获取，还可以从如下方式获取：</p>
<p>1）从压缩包中获取，比如 JAR包、EAR、WAR包等<br>2）从网络中获取，比如红极一时的Applet技术<br>3）从运行过程中动态生成，最出名的便是动态代理技术，在java.lang.reflect.Proxy 中，就是用了 ProxyGenerator.generateProxyClass 来为特定接口生成形式为“$Proxy”的代理类的二进制流<br>4）从其它文件生成，如JSP文件生成Class 类<br>5）从数据库中读取，比如说有些中间件服务器，通过数据库完成程序代码在集群之间的分发</p>
<p>相对于类加载过程的其他阶段，加载这一步骤是开发人员可控的，即可以通过自定义类加载器来控制加载过程。</p>
<p>对于数组来说，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但是数组的元素类型，最终是要靠类加载器去创建。</p>
<h2 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h2><p>验证阶段的目的是<font color="red">为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</font><br>Java语言本身是相对安全的，因为使用纯粹的java代码无法做到诸如访问数组边界意外的数据、讲一个对象转型为它并未实现的类型、跳转到不存在的代码行之类的事情，如果我们这样做了，那编译器将拒绝编译，也就保证了安全。但是前面说过，Class文件并不一定要用Java源码编译而来，它还可以从很多途径产生，在字节码层面，其他方式可能能做到java代码无法做到的事情，因此虚拟机需要对加载尽量的字节流进行验证。验证过程分为四步：<br>（1）文件格式验证<br>这一阶段是要<font color="red">验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</font>包括以下这些验证点：</p>
<ul>
<li>是否以魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_Utf8_info 型的常量中是否有不符合UTF8 编码的数据</li>
<li>Class 文件中各个部分以及文件本身是否有被删除的或被附加的其它信息<br>…</li>
</ul>
<p>这一阶段验证的目的是<font color="red">保证输入的字节流能正确的解析并存储到方法区中，这阶段是基于二进制字节流进行的</font>，通过验证后，字节流才会进入到内存的方法区中进行存储。因此，后面的3个验证阶段是基于方法区的存储结构进行分析的，不会再直接操作字节流了。</p>
<p>（2）元数据验证<br>对字节码描述的信息进行语义分析，以<font color="red">保证其描述的信息符合Java语言规范的要求</font>，主要是验证类的继承关系、数据类型是否符合，验证点包括：</p>
<ul>
<li>这个类是否有父类（除Object类外，其他所有类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（final 修饰的类）</li>
<li>这个类如果不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>类中的字段、方法是否和父类产生矛盾（如覆盖了父类final 字段，出现了非法的方法重载，如方法参数一致，但返回类型却不同）</li>
</ul>
<p>（3）字节码验证<br>最复杂的一个阶段，主要目的是<font color="red">通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的</font>。在元数据验证阶段对数据类型做完校验后，这个阶段将对类的方法体进行校验分析，以保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，有如下一些验证点：</p>
<ul>
<li>保证任何时候，操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似这样的情况：在操作栈放入了一个int类型数据，使用时却按 long 类型加载到本地变量表中</li>
<li>保证跳转指令不会跳转到方法体外的字节码指令上</li>
<li>保证方法体中类型转换是有效的</li>
</ul>
<p>（4）符号引用验证<br>这一阶段发生在虚拟机将符号引用转化为直接引用的时候，而这个转化动作发生在解析阶段，符号引用可以看做是<font color="red">对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验</font>，验证点如下：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到相应的类</li>
<li>在指定类中对否存在符合方法的字段描述符以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问<br>这一阶段验证的目的是确保解析动作能正常执行。</li>
</ul>
<p>对于虚拟机来说，验证阶段是一个非常重要的，但不是一定必要（因为对程序运行期没有影响）的的阶段。</p>
<h2 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。有两点需要注意：<br>（1）这阶段进行内存分配的仅包括类变量（即被static修饰的变量），不包括实例变量，实例变量会在对象实例化时随着对象一起分配在Java堆中；<br>（2）这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义如下：<br>    public static int value = 123;<br>那变量value在准备阶段过后的零值为0而不是123，因为这时候并未执行任何Java方法，把value赋值为123的动作是在初始化阶段才会进行。对于“非通常情况”，是指定义为常量的那些变量（即final修饰的），会在这一阶段就被赋值，如：<br>    public static final int value = 123;<br>此时在准备阶段过后，value的值将会被赋值为123。</p>
<h2 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h2><p>解析阶段是<font color="red">虚拟机将常量池中的符号引用转化为直接引用的过程。</font></p>
<ul>
<li>符号引用（Symbolic References）：即用一组符号来描述所引用的目标。它与虚拟机的内存布局无关，引用的目标不一定已经加载到内存中。</li>
<li>直接引用（Direct References）：直接引用可以是指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。它是和虚拟机内存布局相关的，如果有了直接引用，那引用的目标必定已经在内存中存在了。<br>解析动作主要针对 类或接口、字段、类方法、接口方法、方法类型、方法句柄 和 调用限定符 7类符号引用进行。<br>（1）类或接口的解析<br>判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。<br>（2）字段解析<br>在对字段进行解析前，会先查看该字段所属的类或接口的符号引用是否已经解析过，没有就先对字段所属的接口或类进行解析。在对字段进行解析的时候，先查找本类或接口中是否有该字段，有就直接返回；否则，再对实现的接口进行遍历，会按照继承关系从下往上递归（也就是说，每个父接口都会走一遍）搜索各个接口和它的父接口，返回最近一个接口的直接引用；再对继承的父类进行遍历，会按照继承关系从下往上递归（也就是说，每个父类都会走一遍）搜索各个父类，返回最近一个父类的直接引用。<br>（3）类方法解析<br>和字段解析搜索步骤差不多，只不过是先搜索父类，再搜索接口。<br>（4）接口方法解析<br>和类方法解析差不多，只不过接口中不会有父类，因此只需要对父接口进行搜索即可。</li>
</ul>
<h2 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h2><p>初始化是类加载过程的最后一步，此阶段才开始真正执行类中定义的Java程序代码（或者说字节码，也仅限与执行&lt;clinit&gt;()方法）。在准备阶段，我们已经给变量付过一次系统要求的初始值（零值），而<font color="red">在初始化阶段，则会根据程序员的意愿给类变量和其他资源赋值。</font>主要是通过&lt;clinit&gt;()方法来执行的：<br> （1）&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;  </div><div class="line">    static&#123;  </div><div class="line">        i = 0;//可以给变量赋值，编译通过  </div><div class="line">        System.out.println(i);//编译不通过！！不能进行访问后面的静态变量  </div><div class="line">    &#125;  </div><div class="line">    static int i =1;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有点与我们平常的认知相反，这里是可以下赋值，却不能访问…</p>
<p> （2）&lt;clinit&gt;()方法与实例构造器&lt;init&gt;()方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。因此，在虚拟机中第一个被执行的&lt;clinit&gt;()方法的类肯定是java.lang.Object。</p>
<p> （3）&lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</p>
<p> （4）接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成&lt;clinit&gt;()方法。但是接口与类不同的是：执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。</p>
<p> （5）虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</p>
<h1 id="四：类加载器"><a href="#四：类加载器" class="headerlink" title="四：类加载器"></a>四：类加载器</h1><p>前面说过，在类加载过程的第一个阶段：加载阶段，除了可以使用系统提供的引导类加载器外，还可以使用用户自定义的类加载器，以便让用户决定如何去获取所需要的类（是从Class文件中？还是从jar、或者其他方式…可以自由决定）。</p>
<h2 id="4-1-类和类加载器"><a href="#4-1-类和类加载器" class="headerlink" title="4.1 类和类加载器"></a>4.1 类和类加载器</h2><p>任意一个类，都需要由加载它的类加载器和这个类本身共同确定其在Java 虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达的更通俗一些：<font color="red">比较两个类是否相等，只有在这两个类是同一个类加载器加载的前提下才意义。</font>否则，即使这两个类来自同一个Class文件，被同一个虚拟机加载，但只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p>这里的“相等”，包括代表类的 Class 对象的equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括 instanceof 关键字对对象所属关系判定等情况。下面代码演示了不同类加载器对 instanceof 关键字运算的结果的影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTest &#123;    </div><div class="line">    public static void main(String[] args) throws Exception &#123;    </div><div class="line">        ClassLoader myLoader = new ClassLoader() &#123;    </div><div class="line">            @Override    </div><div class="line">            public Class&lt;?&gt; loadClass(String name)    </div><div class="line">                    throws ClassNotFoundException &#123;    </div><div class="line">                try &#123;    </div><div class="line">                    String fileName = name.substring(name.lastIndexOf(&quot;.&quot;) + 1)    </div><div class="line">                            + &quot;.class&quot;;    </div><div class="line">                    InputStream is = getClass().getResourceAsStream(fileName);    </div><div class="line">                    if (is == null) &#123;    </div><div class="line">                        return super.loadClass(name);    </div><div class="line">                    &#125;    </div><div class="line">                    byte[] b = new byte[is.available()];    </div><div class="line">                    is.read(b);    </div><div class="line">                    return defineClass(name, b, 0, b.length);    </div><div class="line">                &#125; catch (IOException e) &#123;    </div><div class="line">                    throw new ClassNotFoundException(name);    </div><div class="line">                &#125;    </div><div class="line">            &#125;    </div><div class="line">        &#125;;    </div><div class="line">  </div><div class="line">        Class c = myLoader.loadClass(&quot;org.bupt.xiaoye.blog.ClassLoaderTest&quot;);    </div><div class="line">        Object obj = c.newInstance();    </div><div class="line">        System.out.println(obj.getClass());    </div><div class="line">        System.out.println(ClassLoaderTest.class);    </div><div class="line">        System.out.println(obj instanceof ClassLoaderTest);    </div><div class="line">  </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class org.bupt.xiaoye.blog.ClassLoaderTest  </div><div class="line">class org.bupt.xiaoye.blog.ClassLoaderTest  </div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>我们使用了一个自定义的类加载器去加载ClassLoaderTest，由第一句也可以看出这个对象也的确是ClassLoaderTest实例化出来的对象，但是这个对象在与类class org.bupt.xiaoye.blog.ClassLoaderTest 做属性检查的时候却反悔了false，这就是因为虚拟机中存在了两个ClassLoaderTest类，一个由系统应用程序类加载器加载，一个由我们自定义的类加载器加载，虽然是 来自同一个Class文件，但依然是两个独立的类。</p>
<p>因此，<font color="red">类是否相等，取决于类本身和加载该类的类加载器是否是同一个类加载器。</font></p>
<h2 id="4-2-双亲委派模型"><a href="#4-2-双亲委派模型" class="headerlink" title="4.2 双亲委派模型"></a>4.2 双亲委派模型</h2><p>从虚拟机的角度来讲，只存在两种不同的类加载器：</p>
<p>一种是启动类加载器（Bootstrap ClassLoader），这个类加载器用 C++  语言实现， 是虚拟机自身的一部分：<br>另一种就是所有其它的类加载器， 这些类加载器用Java 语言实现，独立于虚拟机外部，并且全都继承与抽象类 java.lang.ClassLoader。</p>
<p>从Java 开发人员的角度来看，类加载器还可以划分的更细致一些，绝大多数Java 程序都会用到以下3种系统提供的类加载器：</p>
<p>（1）启动类加载器（Bootstrap ClassLoader） ： 这个类加载器负责将存放在 &lt;JAVA_HOME&gt;\lib 目录中的，或者被 -Xbootclasspath 参数指定的路径中的，并且是虚拟机识别的(仅按照文件名识别,如rt.jar ，名字不符合类库不会加载) 类库加载到虚拟机内存中。启动类加载器无法被 java 程序直接引用，如需要，直接使用 null 代替即可。<br>（2）扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader 实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。<br>（3）应用程序类加载器(Application ClassLoader)：这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。这个这个类加载器是 ClassLoader 中的getSystemClassLoader() 方法的返回值，所以一般称它为系统类加载器。它负责加载用户路径(ClassPath)上所指定的类库，开发者可以使用这个类加载器，如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>我们的应用程序都是由这3中类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般如下图所示：</p>
<p>!双亲委派](Java虚拟机学习——类加载机制/双亲委派.png)</p>
<p>图中的类加载器之间的这种层次关系，称为类加载器的双亲委派模型。双亲委派模型要求除了顶层的启动类加载器，其余的类加载器都应该有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是使用组合关系来复用父加载器的代码。<br>双亲委派模型的工作过程是：<font color="red">如果一个类加载器收到了类加载器的请求，它首先不会自己尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类时），子加载类才会尝试自己去加载。</font></p>
<p>使用双亲委派模型的好处：就是<font color="red">Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</font>比如对于类Object来说，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器去加载，因此Object类在程序中的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类自己去加载的话，按照我们前面说的，如果用户自己编写了一个Object类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，此时Java类型提醒中最基础的行为也就无法保证了，应用程序也将变得混乱。</p>
<p>因此，双亲委派模型对于保证Java程序的稳定运作很重要，但是他的实现其实很简单，实现双亲委派模型的代码几种在java.lang.ClassLoader的loadClass()方法之中，逻辑清晰易懂：先检查类是否被加载过，若没有则调用父加载器的loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载器失败，抛出 ClassNotFoundException 异常后，再调用自己的 finClass() 方法进行加载，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)    </div><div class="line">        throws ClassNotFoundException &#123;    </div><div class="line">    synchronized (getClassLoadingLock(name)) &#123;    </div><div class="line">        // 首先检查类是否已经被加载过    </div><div class="line">        Class c = findLoadedClass(name);    </div><div class="line">        if (c == null) &#123;    </div><div class="line">            long t0 = System.nanoTime();    </div><div class="line">            try &#123;    </div><div class="line">                if (parent != null) &#123;    </div><div class="line">                    // 调用父类加载器加载    </div><div class="line">                    c = parent.loadClass(name, false);    </div><div class="line">                &#125; else &#123;    </div><div class="line">                    c = findBootstrapClassOrNull(name);    </div><div class="line">                &#125;    </div><div class="line">            &#125; catch (ClassNotFoundException e) &#123;    </div><div class="line">                // ClassNotFoundException thrown if class not found    </div><div class="line">                // from the non-null parent class loader    </div><div class="line">            &#125;    </div><div class="line">  </div><div class="line">            if (c == null) &#123;    </div><div class="line">                // If still not found, then invoke findClass in order    </div><div class="line">                // to find the class.    </div><div class="line">                //父类加载器无法完成加载，调用本身的加载器加载  </div><div class="line">                long t1 = System.nanoTime();    </div><div class="line">                c = findClass(name);    </div><div class="line">  </div><div class="line">                // this is the defining class loader; record the stats    </div><div class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(    </div><div class="line">                        t1 - t0);    </div><div class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(    </div><div class="line">                        t1);    </div><div class="line">                sun.misc.PerfCounter.getFindClasses().increment();    </div><div class="line">            &#125;    </div><div class="line">        &#125;    </div><div class="line">        if (resolve) &#123;    </div><div class="line">            resolveClass(c);    </div><div class="line">        &#125;    </div><div class="line">        return c;    </div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考:<br>周志明:《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：类加载机制概述&quot;&gt;&lt;a href=&quot;#一：类加载机制概述&quot; class=&quot;headerlink&quot; title=&quot;一：类加载机制概述&quot;&gt;&lt;/a&gt;一：类加载机制概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转
    
    </summary>
    
      <category term="JVM" scheme="http://wangyuanjun.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://wangyuanjun.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8源码解析——String</title>
    <link href="http://wangyuanjun.cn/2018/01/30/JDK1.8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94String/"/>
    <id>http://wangyuanjun.cn/2018/01/30/JDK1.8源码解析——String/</id>
    <published>2018-01-30T14:32:49.000Z</published>
    <updated>2018-02-01T02:52:33.769Z</updated>
    
    <content type="html"><![CDATA[<p>String源码分析 </p>
<h1 id="一：类的声明"><a href="#一：类的声明" class="headerlink" title="一：类的声明"></a>一：类的声明</h1><p>在java.lang包中，此类被final修饰，表示String的对象是不可变量，不可继承。<br>String类实现了Serizlizable，Comparable, CharSequence接口。<br>Serizlizable接口没有任何方法和域，仅用于标识序列化的语意，实现此接口的类是可序列化的，是java提供的通用数据保存和读取的接口。<br>Comparable接口只有一个compareTo(To)方法。<br><img src="/2018/01/30/JDK1.8源码解析——String/Comparable接口.png" alt="Comparable接口"><br>CharSequence接口如下图<br><img src="/2018/01/30/JDK1.8源码解析——String/CharSequence接口.png" alt="CharSequence接口"></p>
<h1 id="类的成员变量"><a href="#类的成员变量" class="headerlink" title="类的成员变量"></a>类的成员变量</h1><pre><code>/** The value is used for character storage. */
private final char value[]; //使用字符数组存放字符串

/** Cache the hash code for the string */
private int hash; // Default to 0  存放哈希值
</code></pre><h1 id="类的构造方法"><a href="#类的构造方法" class="headerlink" title="类的构造方法"></a>类的构造方法</h1><h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><pre><code>// 无参构造方法 因为String对象内容不可变，所以没有必要调用此方法。
public String() {
    this.value = &quot;&quot;.value;
}
</code></pre><h2 id="String-参数"><a href="#String-参数" class="headerlink" title="String 参数"></a>String 参数</h2><pre><code>//初始化一个新创建的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。
public String(String original) {
    this.value = original.value;
    this.hash = original.hash;
}
</code></pre><p>可以看到只是将value引用指向original中的value数组，因为两者都是final的，所以这个看来也没那么必要。因为String s1=new String(“s1s1”); String s2=new String(s1);这种用法完全没有必要，而不如直接引用，s2=s1;</p>
<h2 id="char-参数"><a href="#char-参数" class="headerlink" title="char[]参数"></a>char[]参数</h2><pre><code>// 分配一个新的 String，使其表示字符数组参数中当前包含的字符序列。
public String(char value[]) {
    this.value = Arrays.copyOf(value, value.length);
}
//可以发现当通过char数组构建时，只是将char数组复制到value中，而且是复制，而不是简单的引用相等。

// 分配一个新的 String，它包含取自字符数组参数一个子数组的字符。
// offset是起始位置，count是字符数量
public String(char value[], int offset, int count) {    
    if (offset &lt; 0) { // 如果起始位置小于0
        throw new StringIndexOutOfBoundsException(offset);
    }
    if (count &lt;= 0) { // 如果字符数量小于1
        if (count &lt; 0) { // 如果字符数量小于0
            throw new StringIndexOutOfBoundsException(count);
        }
        if (offset &lt;= value.length) { // 如果起始位置不超过参数中字符数组长度
            this.value = &quot;&quot;.value; // 设置为空字符串
            return;
        }
    }
    // Note: offset or count might be near -1&gt;&gt;&gt;1.
    if (offset &gt; value.length - count) { // 如果起始位置与字符数量不符合逻辑
        throw new StringIndexOutOfBoundsException(offset + count);
    }

    // 创建字符数组副本
    this.value = Arrays.copyOfRange(value, offset, offset+count);
}
与上面的区别是，这里只是利用char数组中的一部分来构建String，其中offset代表起始下标，count是所有构建的长度。
</code></pre><h2 id="int-参数"><a href="#int-参数" class="headerlink" title="int[]参数"></a>int[]参数</h2><pre><code>//分配一个新的 String，它包含 Unicode 代码点数组参数一个子数组的字符。
public String(int[] codePoints, int offset, int count) {
    if (offset &lt; 0) {
        throw new StringIndexOutOfBoundsException(offset);
    }
    if (count &lt;= 0) {
        if (count &lt; 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        if (offset &lt;= codePoints.length) {
            this.value = &quot;&quot;.value;
            return;
        }
    }
    // Note: offset or count might be near -1&gt;&gt;&gt;1.
    if (offset &gt; codePoints.length - count) {
        throw new StringIndexOutOfBoundsException(offset + count);
    }

    final int end = offset + count;

    // Pass 1: Compute precise size of char[]
    int n = count;
    for (int i = offset; i &lt; end; i++) {
        int c = codePoints[i];
        if (Character.isBmpCodePoint(c))
            continue;
        else if (Character.isValidCodePoint(c))
            n++;
        else throw new IllegalArgumentException(Integer.toString(c));
    }

    // Pass 2: Allocate and fill in char[]
    final char[] v = new char[n];

    for (int i = offset, j = 0; i &lt; end; i++, j++) {
        int c = codePoints[i];
        if (Character.isBmpCodePoint(c))
            v[j] = (char)c;
        else
            Character.toSurrogates(c, v, j++);
    }

    this.value = v;
}
</code></pre><h2 id="byte-参数"><a href="#byte-参数" class="headerlink" title="byte[]参数"></a>byte[]参数</h2><p>所谓好的适用性模块，一定是能有一坨坨的各种适应代码的。下面是一系列的利用byte[]数组来构建String对象的构造器，主要差别是可能需要指定特殊的字符集来解码，但是这一点其实在web编程，网络编程中还是很重要的</p>
<pre><code>//通过使用指定的字符集解码指定的 byte 子数组，构造一个新的 String。
public String(byte bytes[], int offset, int length, String charsetName)
        throws UnsupportedEncodingException {
    if (charsetName == null)
        throw new NullPointerException(&quot;charsetName&quot;);
    checkBounds(bytes, offset, length);
    this.value = StringCoding.decode(charsetName, bytes, offset, length);
}

//通过使用指定的 charset 解码指定的 byte 子数组，构造一个新的 String。
public String(byte bytes[], int offset, int length, Charset charset) {
    if (charset == null)
        throw new NullPointerException(&quot;charset&quot;);
    checkBounds(bytes, offset, length);
    this.value =  StringCoding.decode(charset, bytes, offset, length);
}

// 通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。
public String(byte bytes[], String charsetName)
        throws UnsupportedEncodingException {
    this(bytes, 0, bytes.length, charsetName);
}

//通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String。
public String(byte bytes[], Charset charset) {
    this(bytes, 0, bytes.length, charset);
}

//通过使用平台的默认字符集解码指定的 byte 子数组，构造一个新的 String。
public String(byte bytes[], int offset, int length) {
    checkBounds(bytes, offset, length);
    this.value = StringCoding.decode(bytes, offset, length);
}

//通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的 String。
public String(byte bytes[]) {
    this(bytes, 0, bytes.length);
}
</code></pre><h2 id="基于StringBuilder-StringBuffer参数"><a href="#基于StringBuilder-StringBuffer参数" class="headerlink" title="基于StringBuilder,StringBuffer参数"></a>基于StringBuilder,StringBuffer参数</h2><pre><code>//分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列。
public String(StringBuffer buffer) {
    synchronized(buffer) {
        this.value = Arrays.copyOf(buffer.getValue(), buffer.length());
    }
}

//分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列。
public String(StringBuilder builder) {
    this.value = Arrays.copyOf(builder.getValue(), builder.length());
}

String(char[] value, boolean share) {
    // assert share : &quot;unshared not supported&quot;;
    this.value = value;
}
</code></pre><h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><pre><code>//获取字符串长度
//返回字符串中所包含的字符数目，即value数组的长度
public int length() {
    return value.length;
}
</code></pre><h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty"></a>isEmpty</h2><pre><code>// 判断字符串是否为空
// 判断字符串是否为空，即判断value数组的长度为0即可
public boolean isEmpty() {
    return value.length == 0;
}
</code></pre><h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h2><pre><code>//按下标获取单个字符
//返回指定索引处的 char 值。索引范围为从 0 到 length() - 1。序列的第一个 char 值位于索引 0 处，第二个位于索引 1 处，依此类推，这类似于数组索引。 
public char charAt(int index) {
    if ((index &lt; 0) || (index &gt;= value.length)) {
        throw new StringIndexOutOfBoundsException(index);
    }
    return value[index];
}
</code></pre><h2 id="getChars"><a href="#getChars" class="headerlink" title="getChars"></a>getChars</h2><pre><code>//将字符串拷贝到目标字符数组
void getChars(char dst[], int dstBegin) {
    System.arraycopy(value, 0, dst, dstBegin, value.length);
}

// 获取子串，把它拷贝到目标字符数组
public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) {
    if (srcBegin &lt; 0) { // 如果源数组开始位置&lt;0
        throw new StringIndexOutOfBoundsException(srcBegin);
    }
    if (srcEnd &gt; value.length) { // 如果源数组结束位置&gt;字符数组长度
        throw new StringIndexOutOfBoundsException(srcEnd);
    }
    if (srcBegin &gt; srcEnd) { // 如果源数组开始位置&gt;源数组结束位置
        throw new StringIndexOutOfBoundsException(srcEnd - srcBegin);
    }
    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);
}
</code></pre><h2 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes"></a>getBytes</h2><pre><code>//使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 
public byte[] getBytes(String charsetName)
        throws UnsupportedEncodingException {
    if (charsetName == null) throw new NullPointerException();
    return StringCoding.encode(charsetName, value, 0, value.length);
}

//使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组。 
public byte[] getBytes(Charset charset) {
    if (charset == null) throw new NullPointerException();
    return StringCoding.encode(charset, value, 0, value.length);
}

//使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。 
public byte[] getBytes() {
    return StringCoding.encode(value, 0, value.length);
}
</code></pre><h2 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h2><pre><code>//将此字符串与指定的对象比较。当且仅当该参数不为 null，并且是与此对象表示相同字符序列的 String 对象时，结果才为 true。 
//比较两个引用指向的String对象内容是否相同
public boolean equals(Object anObject) {
    if (this == anObject) { // 如果两个引用指向的是同一个String对象
        return true;
    }
    if (anObject instanceof String) { // 如果第2个引用指向的对象是String实例
        String anotherString = (String)anObject; // 强制类型转换
        int n = value.length; // 获取第1个引用指向的String对象的字符串长度
        if (n == anotherString.value.length) { // 如果两个字符串长度相等
            // 定义字符数组指针
            char v1[] = value; 
            char v2[] = anotherString.value;

            // 字符依次比较
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
</code></pre><p>可以看到equals方法重写了，会判断两个字符串的每一个字符是否相等。    </p>
<h2 id="equalsIgnoreCase"><a href="#equalsIgnoreCase" class="headerlink" title="equalsIgnoreCase"></a>equalsIgnoreCase</h2><pre><code>//将此 String 与另一个 String 比较，不考虑大小写。如果两个字符串的长度相同，并且其中的相应字符都相等（忽略大小写），则认为这两个字符串是相等的。
public boolean equalsIgnoreCase(String anotherString) {
        return (this == anotherString) ? true
                : (anotherString != null)
                &amp;&amp; (anotherString.value.length == value.length)
                &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length);
    }
    判断两个字符串在忽略大小写的情况下是否相等，主要调用regionMatches方法

    public boolean regionMatches(boolean ignoreCase, int toffset,
            String other, int ooffset, int len) {
        char ta[] = value;
        int to = toffset;
        char pa[] = other.value;
        int po = ooffset;
        // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1.
        if ((ooffset &lt; 0) || (toffset &lt; 0)
                || (toffset &gt; (long)value.length - len)
                || (ooffset &gt; (long)other.value.length - len)) {
            return false;
        }
        while (len-- &gt; 0) {
            char c1 = ta[to++];
            char c2 = pa[po++];
            //在这里先行判断，如果相等就直接跳过后面即可，可以提高效率
            if (c1 == c2) {
                continue;
            }
            if (ignoreCase) {
                // If characters don&apos;t match but case may be ignored,
                // try converting both characters to uppercase.
                // If the results match, then the comparison scan should
                // continue.
                char u1 = Character.toUpperCase(c1);
                char u2 = Character.toUpperCase(c2);
                //都转换成大写的形式，如果相等，则跳过
                if (u1 == u2) {
                    continue;
                }
                // Unfortunately, conversion to uppercase does not work properly
                // for the Georgian alphabet, which has strange rules about case
                // conversion.  So we need to make one last check before
                // exiting.
                if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) {
                    continue;
                }
            }
            return false;
        }
        return true;
    }
</code></pre><h2 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h2><pre><code>// 比较两个String对象的大小
public int compareTo(String anotherString) {
    // 获取字符数组长度
    int len1 = value.length;
    int len2 = anotherString.value.length;
    // 获取最小长度
    int lim = Math.min(len1, len2);
    // 定义字符数组指针
    char v1[] = value;
    char v2[] = anotherString.value;

    int k = 0;
    while (k &lt; lim) {
        char c1 = v1[k];
        char c2 = v2[k];
        if (c1 != c2) { // 如果两个字符不相等
            return c1 - c2;
        }
        k++;
    }

    // 根据长度比较大小
    return len1 - len2;
}
</code></pre><p>比较两个字符串的大小。如果两个字符串的字符序列相等，则返回0；不相等时，从两个字符串第0个字符开始比较，返回第一个不相等的字符差。另一种情况，较长的字符串的前面部分恰好是较短的字符串，则返回他们的长度差。</p>
<h2 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h2><pre><code>//测试此字符串从指定索引开始的子字符串是否以指定前缀开始。
public boolean startsWith(String prefix, int toffset) {
    char ta[] = value;
    int to = toffset;
    char pa[] = prefix.value;
    int po = 0;
    int pc = prefix.value.length;
    // Note: toffset might be near -1&gt;&gt;&gt;1.
    if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) {
        return false;
    }
    while (--pc &gt;= 0) {
        if (ta[to++] != pa[po++]) {
            return false;
        }
    }
    return true;
}

//测试此字符串是否以指定的前缀开始。 
public boolean startsWith(String prefix) {
    return startsWith(prefix, 0);
}
</code></pre><h2 id="endsWith"><a href="#endsWith" class="headerlink" title="endsWith"></a>endsWith</h2><pre><code>//测试此字符串是否以指定的后缀结束。
public boolean endsWith(String suffix) {
    return startsWith(suffix, value.length - suffix.value.length);
}
</code></pre><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h2><pre><code>//返回此字符串的哈希码。String 对象的哈希码根据以下公式计算： s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] 使用 int 算法，这里 s[i] 是字符串的第 i 个字符，n 是字符串的长度，^ 表示求幂。（空字符串的哈希值为 0。） 
// 获取散列码方法
public int hashCode() {
    // 获取字符串缓存散列码
    int h = hash;
    if (h == 0 &amp;&amp; value.length &gt; 0) { // 如果字符串缓存散列码为0并且字符串数组长度大于0
        // 定义字符数组指针
        char val[] = value;

        // 遍历每个字符
        for (int i = 0; i &lt; value.length; i++) {
            h = 31 * h + val[i]; // 31 * h会被JVM优化成(h &lt;&lt; 5) - h
        }
        hash = h; // 修改字符串缓存散列码
    }
    return h;
}
</code></pre><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><pre><code>// 获取指定字符在此字符串中第一次出现处的索引
public int indexOf(int ch) {
    return indexOf(ch, 0); // 从0开始查找
}

// 获取在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。
// Unicode指统一码（采用双字节对字符进行编码）
public int indexOf(int ch, int fromIndex) {
    // 获取字符数组长度
    final int max = value.length;
    if (fromIndex &lt; 0) { // 如果起始位置&lt;0
        fromIndex = 0; // 起始位置置0
    } else if (fromIndex &gt;= max) { // 如果起始位置&gt;=字符数组长度
        // Note: fromIndex might be near -1&gt;&gt;&gt;1.
        return -1;
    }

    // Character.MIN_SUPPLEMENTARY_CODE_POINT是BmpCode代码点
    // 值是2的16次方，是2个字节最大值+1
    // 如果ch是非辅助代码点或者负值（无效代码点）
    if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) { 
        // handle most cases here (ch is a BMP code point or a
        // negative value (invalid code point))
        final char[] value = this.value; // 创建字符数组的指针
        for (int i = fromIndex; i &lt; max; i++) { // 从fromIndex开始遍历每个字符
            if (value[i] == ch) { // 如果找到ch字符
                return i;
            }
        }
        return -1;
    } else { // 寻找ch在辅助部分中的索引
        return indexOfSupplementary(ch, fromIndex);
    }
}

//返回指定字符在此字符串中最后一次出现处的索引。
public int lastIndexOf(int ch) {
    return lastIndexOf(ch, value.length - 1);
}

//返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。
public int lastIndexOf(int ch, int fromIndex) {
    if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) {
        // handle most cases here (ch is a BMP code point or a
        // negative value (invalid code point))
        final char[] value = this.value;
        int i = Math.min(fromIndex, value.length - 1);
        for (; i &gt;= 0; i--) {
            if (value[i] == ch) {
                return i;
            }
        }
        return -1;
    } else {
        return lastIndexOfSupplementary(ch, fromIndex);
    }
}

//返回指定子字符串在此字符串中第一次出现处的索引。
public int indexOf(String str) {
    return indexOf(str, 0);
}

//返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。
public int indexOf(String str, int fromIndex) {
    return indexOf(value, 0, value.length,
            str.value, 0, str.value.length, fromIndex);
}


// 获取参数子串在该字符串中从起始位置开始第一次出现的位置
static int indexOf(char[] source, int sourceOffset, int sourceCount,
        String target, int fromIndex) {
    return indexOf(source, sourceOffset, sourceCount,
                   target.value, 0, target.value.length,
                   fromIndex);
}

/* @param   source       the characters being searched.//这里就是value数组
     * @param   sourceOffset offset of the source string./ //源字符串的偏移量
     * @param   sourceCount  count of the source string.    //这里是value数组的长度
     * @param   target       the characters being searched for.  //待搜索目标字符串
     * @param   targetOffset offset of the target string.   //待搜索目标字符串的偏移量
     * @param   targetCount  count of the target string.   //待搜索目标字符串的长度
     * @param   fromIndex    the index to begin searching from. //起始位置
     */
    // 获取参数子串在该字符串中从起始位置开始第一次出现的位置
    // source是目标串（该字符串），target是模式串（子串）
    static int indexOf(char[] source, int sourceOffset, int sourceCount,
        char[] target, int targetOffset, int targetCount,
        int fromIndex) {
        if (fromIndex &gt;= sourceCount) {//越界了
            return (targetCount == 0 ? sourceCount : -1);
        }
        if (fromIndex &lt; 0) {
            fromIndex = 0;
        }
        if (targetCount == 0) {
            return fromIndex;
        }

        char first = target[targetOffset];//待搜索字符串第一个字符
        int max = sourceOffset + (sourceCount - targetCount);//搜索第一个匹配的字符时所能达到的最大值，因为要保证后面的长度&gt;=targetCount

        // 朴素匹配算法
        //下面这里就是核心搜索算法了，会先匹配第一个字符，然后依次向后移，直到完全匹配
        //或者是匹配到max仍然没有匹配成功
        for (int i = sourceOffset + fromIndex; i &lt;= max; i++) {
            /* Look for first character. */
            if (source[i] != first) {// 如果第一个字符不匹配
                while (++i &lt;= max &amp;&amp; source[i] != first);// 寻找第一个匹配上的字符
            }

            /* Found first character, now look at the rest of v2 */
            //可以注意这里i下标只是用来匹配第一个字符，因为有可能部分匹配时，需要从先在匹配
            //所以这里重新应用下标j
            if (i &lt;= max) {// 匹配除了第一个字符的其他部分
                int j = i + 1;
                int end = j + targetCount - 1;
                for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j]
                        == target[k]; j++, k++);

                if (j == end) {
                    /* Found whole string. */
                    return i - sourceOffset;
                }
            }
        }
        return -1;
    }//当匹配失败时，返回-1

//返回指定子字符串在此字符串中最右边出现处的索引。
public int lastIndexOf(String str) {
    return lastIndexOf(str, value.length);
}


public int lastIndexOf(String str, int fromIndex) {
    return lastIndexOf(value, 0, value.length,
            str.value, 0, str.value.length, fromIndex);
}
</code></pre><p>static int lastIndexOf(char[] source, int sourceOffset, int sourceCount,<br>            char[] target, int targetOffset, int targetCount,<br>            int fromIndex) {<br>                /*</p>
<pre><code>     * Check arguments; return immediately where possible. For
     * consistency, don&apos;t check for null str.
     */
    //第一个字符所能匹配的最大位置，类似于上面的max
    int rightIndex = sourceCount - targetCount;
    if (fromIndex &lt; 0) {
        return -1;
    }
    if (fromIndex &gt; rightIndex) {
        fromIndex = rightIndex;
    }
    /* Empty string always matches. */
    if (targetCount == 0) {
        return fromIndex;
    }

    int strLastIndex = targetOffset + targetCount - 1;//目标字符串最后一个字符下标
    char strLastChar = target[strLastIndex];//最后一个字符
    int min = sourceOffset + targetCount - 1;//目标字符串最后一个字符所能匹配的源字符串最小下标
    int i = min + fromIndex;//这里i下标永远是最后一个字符匹配的下标索引

startSearchForLastChar:
    while (true) {
        while (i &gt;= min &amp;&amp; source[i] != strLastChar) {
            i--;
        }
        //小于min则不可能在搜索到了
        if (i &lt; min) {
            return -1;
        }
        int j = i - 1;
        int start = j - (targetCount - 1);
        int k = strLastIndex - 1;

        while (j &gt; start) {
            if (source[j--] != target[k--]) {
                //当存在部分匹配，而前半部分不匹配时，跳出当前查找，整体向前窗移
                i--;
                continue startSearchForLastChar;//直接跳到顶层while循环
            }
        }
        return start - sourceOffset + 1;
    }
}
</code></pre><p>可以看到与indexOf方法是对应的，只不过是反向搜索。</p>
<h2 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h2><pre><code>//返回一个新的字符串，它是此字符串的一个子字符串。该子字符串从指定索引处的字符开始，直到此字符串末尾。
public String substring(int beginIndex) {
    if (beginIndex &lt; 0) { // 如果起始下标&lt;0
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    int subLen = value.length - beginIndex; // 获取截取长度
    if (subLen &lt; 0) { // 如果截取长度&lt;0
        throw new StringIndexOutOfBoundsException(subLen);
    }
    return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
}

//返回一个新字符串，它是此字符串的一个子字符串。该子字符串从指定的 beginIndex 处开始，直到索引 endIndex - 1 处的字符。因此，该子字符串的长度为 endIndex-beginIndex。 
public String substring(int beginIndex, int endIndex) {
    if (beginIndex &lt; 0) { // 如果起始下标&lt;0
        throw new StringIndexOutOfBoundsException(beginIndex);
    }
    if (endIndex &gt; value.length) { // 如果末尾下标&gt;字符数组长度
        throw new StringIndexOutOfBoundsException(endIndex);
    }
    int subLen = endIndex - beginIndex; // 获取截取长度
    if (subLen &lt; 0) { // 如果截取长度&lt;0
        throw new StringIndexOutOfBoundsException(subLen);
    }
    return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this
            : new String(value, beginIndex, subLen);
}
</code></pre><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><pre><code>//将指定字符串连接到此字符串的结尾。 
//如果参数字符串的长度为 0，则返回此 String 对象。否则，创建一个新的 String 对象，用来表示由此 String 对象表示的字符序列和参数字符串表示的字符序列连接而成的字符序列。
public String concat(String str) {
    int otherLen = str.length();
    if (otherLen == 0) {
        return this;
    }
    int len = value.length;
    char buf[] = Arrays.copyOf(value, len + otherLen);
    str.getChars(buf, len);
    return new String(buf, true);
}

void getChars(char dst[], int dstBegin) {
            System.arraycopy(value, 0, dst, dstBegin, value.length);
    }
</code></pre><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><pre><code>public String replace(char oldChar, char newChar) {
    if (oldChar != newChar) {
        int len = value.length;
        int i = -1;
        char[] val = value; /* avoid getfield opcode */

        while (++i &lt; len) {
            if (val[i] == oldChar) {
                break;
            }
        }
        if (i &lt; len) {
            char buf[] = new char[len];
            for (int j = 0; j &lt; i; j++) {
                buf[j] = val[j];
            }
            while (i &lt; len) {
                char c = val[i];
                buf[i] = (c == oldChar) ? newChar : c;
                i++;
            }
            return new String(buf, true);
        }
    }
    return this;
}
</code></pre><h2 id="matches"><a href="#matches" class="headerlink" title="matches"></a>matches</h2><pre><code>//告知此字符串是否匹配给定的正则表达式。
public boolean matches(String regex) {
    return Pattern.matches(regex, this);
}
</code></pre><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><pre><code>//根据给定正则表达式的匹配拆分此字符串。 
public String[] split(String regex, int limit) {
    /* fastpath if the regex is a
     (1)one-char String and this character is not one of the
        RegEx&apos;s meta characters &quot;.$|()[{^?*+\\&quot;, or
     (2)two-char String and the first char is the backslash and
        the second is not the ascii digit or ascii letter.
     */
    char ch = 0;
    if (((regex.value.length == 1 &amp;&amp;
         &quot;.$|()[{^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||
         (regex.length() == 2 &amp;&amp;
          regex.charAt(0) == &apos;\\&apos; &amp;&amp;
          (((ch = regex.charAt(1))-&apos;0&apos;)|(&apos;9&apos;-ch)) &lt; 0 &amp;&amp;
          ((ch-&apos;a&apos;)|(&apos;z&apos;-ch)) &lt; 0 &amp;&amp;
          ((ch-&apos;A&apos;)|(&apos;Z&apos;-ch)) &lt; 0)) &amp;&amp;
        (ch &lt; Character.MIN_HIGH_SURROGATE ||
         ch &gt; Character.MAX_LOW_SURROGATE))
    {
        int off = 0;
        int next = 0;
        boolean limited = limit &gt; 0;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        while ((next = indexOf(ch, off)) != -1) {
            if (!limited || list.size() &lt; limit - 1) {
                list.add(substring(off, next));
                off = next + 1;
            } else {    // last one
                //assert (list.size() == limit - 1);
                list.add(substring(off, value.length));
                off = value.length;
                break;
            }
        }
        // If no match was found, return this
        if (off == 0)
            return new String[]{this};

        // Add remaining segment
        if (!limited || list.size() &lt; limit)
            list.add(substring(off, value.length));

        // Construct result
        int resultSize = list.size();
        if (limit == 0) {
            while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) {
                resultSize--;
            }
        }
        String[] result = new String[resultSize];
        return list.subList(0, resultSize).toArray(result);
    }
    return Pattern.compile(regex).split(this, limit);
}

public String[] split(String regex) {
    return split(regex, 0);
}
</code></pre><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><pre><code>//返回字符串的副本，忽略前导空白和尾部空白。
public String trim() {
    int len = value.length;
    int st = 0;
    char[] val = value;    /* avoid getfield opcode */

    while ((st &lt; len) &amp;&amp; (val[st] &lt;= &apos; &apos;)) {
        st++;
    }
    while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= &apos; &apos;)) {
        len--;
    }
    return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;
}
</code></pre><p>这个trim()是去掉首尾的空格，而实现方式也非常简单，分别找到第一个非空格字符的下标，与最后一个非空格字符的下标<br>然后返回之间的子字符串。注意这里由于应用了substring方法，所以len变量的控制要小心</p>
<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><pre><code>//获取当前String对象
public String toString() {
    return this;
}
</code></pre><h2 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray"></a>toCharArray</h2><pre><code>//将此字符串转换为一个新的字符数组。 
public char[] toCharArray() {
    // Cannot use Arrays.copyOf because of class initialization order issues
    char result[] = new char[value.length];
    System.arraycopy(value, 0, result, 0, value.length);
    return result;
}
</code></pre><h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><pre><code>//使用指定的格式字符串和参数返回一个格式化字符串。
public static String format(String format, Object... args) {
    return new Formatter().format(format, args).toString();
}

//使用指定的语言环境、格式字符串和参数返回一个格式化字符串。 
public static String format(Locale l, String format, Object... args) {
    return new Formatter(l).format(format, args).toString();
}
</code></pre><h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h2><pre><code>//返回 Object 参数的字符串表示形式。
public static String valueOf(Object obj) {
    return (obj == null) ? &quot;null&quot; : obj.toString();
}

//返回 char 数组参数的字符串表示形式。字符数组的内容已被复制，后续修改不会影响新创建的字符串。 
public static String valueOf(char data[]) {
    return new String(data);
}

//返回 char 数组参数的特定子数组的字符串表示形式。 
//offset 参数是子数组的第一个字符的索引。count 参数指定子数组的长度。字符数组的内容已被复制，后续修改不会影响新创建的字符串。 
public static String valueOf(char data[], int offset, int count) {
    return new String(data, offset, count);
}

//返回指定数组中表示该字符序列的 String。 
public static String copyValueOf(char data[], int offset, int count) {
    return new String(data, offset, count);
}

//返回指定数组中表示该字符序列的 String。 
public static String copyValueOf(char data[]) {
    return new String(data);
}

//返回 boolean 参数的字符串表示形式。 
public static String valueOf(boolean b) {
    return b ? &quot;true&quot; : &quot;false&quot;;
}

//返回 char 参数的字符串表示形式。 
public static String valueOf(char c) {
    char data[] = {c};
    return new String(data, true);
}

//返回 int 参数的字符串表示形式。 
public static String valueOf(int i) {
    return Integer.toString(i);
}

//返回 long 参数的字符串表示形式。 
public static String valueOf(long l) {
    return Long.toString(l);
}

//返回 float 参数的字符串表示形式。 
public static String valueOf(float f) {
    return Float.toString(f);
}

//返回 double 参数的字符串表示形式。 
public static String valueOf(double d) {
    return Double.toString(d);
}

//本地方法，把该字符串存入常量池，返回此字符串的引用
public native String intern();
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;String源码分析 &lt;/p&gt;
&lt;h1 id=&quot;一：类的声明&quot;&gt;&lt;a href=&quot;#一：类的声明&quot; class=&quot;headerlink&quot; title=&quot;一：类的声明&quot;&gt;&lt;/a&gt;一：类的声明&lt;/h1&gt;&lt;p&gt;在java.lang包中，此类被final修饰，表示String的对象
    
    </summary>
    
      <category term="JDK1.8源码" scheme="http://wangyuanjun.cn/categories/JDK1-8%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="JDK1.8源码" scheme="http://wangyuanjun.cn/tags/JDK1-8%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>成为Java顶尖程序员 ，看这11本书就够了</title>
    <link href="http://wangyuanjun.cn/2018/01/30/%E6%88%90%E4%B8%BAJava%E9%A1%B6%E5%B0%96%E7%A8%8B%E5%BA%8F%E5%91%98-%EF%BC%8C%E7%9C%8B%E8%BF%9911%E6%9C%AC%E4%B9%A6%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://wangyuanjun.cn/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/</id>
    <published>2018-01-30T09:40:17.000Z</published>
    <updated>2018-02-01T02:56:11.943Z</updated>
    
    <content type="html"><![CDATA[<p>“学习的最好途径就是看书”，这是我自己学习并且小有了一定的积累之后的第一体会。个人认为看书有两点好处：<br><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/1.jpg" alt="1"><br>1.能出版出来的书一定是经过反复的思考、雕琢和审核的，因此从专业性的角度来说，一本好书的价值远超其他资料</p>
<p>2.对着书上的代码自己敲的时候方便</p>
<p>“看完书之后再次提升自我的最好途径是看一些相关的好博文”，我个人认为这是学习的第二步，因为一本书往往有好几百页，好的博文是自己看书学习之后的一些总结和提炼，对于梳理学习的内容很有好处，当然这里不是说自己的学习方法，就不再扯下去了。</p>
<p>很多程序员们往往有看书的冲动，但不知道看哪些书，下面我就给各位Java程序猿们推荐一些好书（每本书的作者会加粗标红），其中绝大多数都是我自己平时在看的书，也算是我对于平时读的书做一个小总结和读后感吧。</p>
<p>首先推荐的不是一本书，而是一个博客，也是我们博客园另外一位博友java_my_life。</p>
<p>目前市面上讲解设计模式的书很多，虽然我前面讲了看书是最好的，但是对设计模式感兴趣的朋友们，我推荐的是这个博客。这位博友的设计模式讲得非常非常好，我认为90%的内容都是没有问题且很值得学习的，其讲解设计模式的大体路线是：</p>
<p>1、随便开篇点明该设计模式的定义</p>
<p>2、图文并茂讲解该设计模式中的结构</p>
<p>3、以详细的代码形式写一下该种设计模式的实现</p>
<p>4、补充内容</p>
<p>5、讲解该设计模式的优缺点</p>
<p>对于一个设计模式我们关注、学习的知识点，不就是上面这些吗？</p>
<p>不 过我要重点提醒一下网友们，同一种设计模式的写法有多种，并不是说只有按某种写法来写才是这种设计模式。比方说适配器模式，我们关注适配器模式一定要关注 的是什么是适配器模式不是怎么写适配器模式，不要认为某段代码不是按照适配器模式的写法写下来的它就不是适配器模式了，记住这一点，你在学习设计模式的时 候一定会对代码中用到的设计模式有更深入的理解。</p>
<h2 id="《深入理解Java虚拟机：JVM高级特性与最佳实践》"><a href="#《深入理解Java虚拟机：JVM高级特性与最佳实践》" class="headerlink" title="《深入理解Java虚拟机：JVM高级特性与最佳实践》"></a>《深入理解Java虚拟机：JVM高级特性与最佳实践》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/深入理解Java虚拟机：JVM高级特性与最佳实践.jpeg" alt="深入理解Java虚拟机：JVM高级特性与最佳实践"></p>
<p>如果你不满足于做一个只会写if…else…的Java程序员，而是希望更进一步，我随便举几个例子吧：</p>
<p>1、了解Java代码的底层运行机制</p>
<p>2、定位性能问题</p>
<p>3、对整个系统进行性能调优</p>
<p>4、解决各种奇奇怪怪的线上线下问题</p>
<p>5、更加高级别的，为自己的项目量身定做一款适合自己项目的虚拟机</p>
<p>那 么Java虚拟机是你必学的一门技术。《深入理解Java虚拟机：JVM高级特性与最佳实践》作者是周志明，这本书可以说是国内写得最好的有关Java虚 拟机的书籍，近半年，前前后后这本书我起码看了有5遍。国内写虚拟机的书除了这本，其实还有一些其他的，我也买过，不过粗略看下来，很多内容也是《深入理 解Java虚拟机：JVM高级特性与最佳实践》此书里面的。</p>
<p>另外值得一提的是，《深入理解Java虚拟机：JVM高级特性与最佳实践》这本 书，有电子版的，网上搜一下就能下载到了。不过建议有兴趣的朋友还是去买书看，电子版本下载到的一般是比较老的版本，相比最新修订版的《深入理解Java 虚拟机：JVM高级特性与最佳实践》，有很多作者新补充的知识点是没有的。</p>
<h2 id="《HotSpot实战》"><a href="#《HotSpot实战》" class="headerlink" title="《HotSpot实战》"></a>《HotSpot实战》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/HotSpot实战.jpeg" alt="HotSpot实战"><br>所有的Java虚拟机都是遵循着Java虚拟机规范来的，市面上的Java虚拟机几十款，《深入理解Java虚拟机：JVM高级特性与最佳实践》一书里面讲的虚拟机并不针对某种特定的虚拟机，而是从Java虚拟机规范的角度来讲解Java虚拟机。</p>
<p>我们平时使用的乃至商用的大多数Java虚拟机都是Sun公司的HotSpot，大家cmd进入命令行，使用”java -version”命令就可以看到了。如果希望在Java虚拟机规范的基础上更加深入地去理解虚拟机的一些细节是怎么实现的，就可以看一下《HotSpot实战》一书，作者是陈涛。不过由于HotSpot的源码都是C/C++写的，所以要求读者有非常好的C/C++基础，如果对这两门语言不是很熟悉的朋友，看这本书可能对你帮助不是很大。</p>
<p>最后提一句，如果有兴趣的朋友，不妨先去网上下载一个openJDK，HotSpot的源码就在里面。</p>
<h2 id="《Java并发编程实战》"><a href="#《Java并发编程实战》" class="headerlink" title="《Java并发编程实战》"></a>《Java并发编程实战》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/Java并发编程实战.jpeg" alt="Java并发编程实战"><br>这本书常常被列入Java程序员必读十大书籍排行榜前几位，不过个人不是很推荐这本书。</p>
<p>《Java并发编程实战》作者是Brian Goetz，怎么说呢，这本书前前后后我也看了两遍左右，个人感受是：</p>
<p>1、文字多代码少</p>
<p>2、讲解多实践少</p>
<p>我 觉得这可能就是老外写书的特点吧，因为Java是北美国家（加拿大、美国）开发和维护的，所以老外对Java方方面面的理论知识体系都掌握得是非常清楚和 透彻的。翻开这本书看，多线程什么用、什么是死锁、什么是竞争、什么是线程安全等等，方方面面的知识点都用大量的文字篇幅讲解，不免让人感觉十分枯燥，也 难让读者有实质性的进步。我这本书看了两遍也属于一目十行意思，有兴趣的地方就重点看一下。</p>
<p>无论如何，作为一本常常位于Jva程序员必读十大书籍排行榜前几名的书，还是一定要推荐给大家的。</p>
<h2 id="《java多线程编程核心技术》"><a href="#《java多线程编程核心技术》" class="headerlink" title="《java多线程编程核心技术》"></a>《java多线程编程核心技术》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/java多线程编程核心技术.jpeg" alt="java多线程编程核心技术"><br>《Java多线程编程核心技术》作者高洪岩。想要学习多线程的朋友，这本书是我大力推荐的，我的个人博客里面二十多篇的多线程博文都是基于此书，并且在这本书的基础上进行提炼和总结而写出来的。</p>
<p>此书和《Java并发编程实战》 相反，这本书的特点是大篇幅的代码+小篇幅的精讲解，可能这和中国人写的书比较偏向实用主义的风格有关。本书关于线程安全、synchronized、 Reentrant、Timer等等都用详细的代码进行了讲解，而且每个大知识点下的多个小知识点都会详细讲解到，非常有实践价值。</p>
<p>有兴趣的朋友们，我相信只要你们跟着这本书里面的代码敲、运行、思考，三步走，对于多线程的使用与理解一定会进几大步。</p>
<p>不 过这本书的缺点就是对于Java并发包下的一些类像CountDownLatch、Semphore、CyclicBarrier、Future、 Callable等都没有讲到，重点的CAS和AQS也没有触及，重点类的实现原理也没有提。当然，这很深入了，在学习了这本书之后如果能再去对这些知识 进行一些学习、研究的话，你一定会慢慢成长为一个很厉害的多线程高手。</p>
<h2 id="《Effective-Java中文版》"><a href="#《Effective-Java中文版》" class="headerlink" title="《Effective Java中文版》"></a>《Effective Java中文版》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/Effective Java中文版.jpeg" alt="Effective Java中文版"><br>这是唯一一本我没有买的书。初识这本书，是在我的博文Java代码优化（长期更新）里面，底下评论的时候有朋友提到了这本书，当时我说要去买，不过这两个月一直都没时间去逛书店，甚是遗憾，之后肯定会找时间去买这本书的。</p>
<p>《Effective Java中文版》的作者是Joshua Bloch，这个人就很厉害了，他是谷歌的首席架构师，属于超级技术大牛级别了吧，呵呵。由于没有看过这本书，所以我不好发表评论，但是从这本书的知名度 以及其作者的来头来看（多提一句，这本书也是Java之父James Gosling博士推崇的一本书），我相信这一定是一本值得一看的好书。</p>
<p>好 的代码是每个Java程序员都应该去追求的，不是说我今天写一段好代码相比写一段烂代码对性能会有多大的提升，更多的应该是提升了代码的可读性以及可以规 避许多潜在的、未知的问题，避免代码上线之后出问题而花时间去维护—-无论从时间成本、人力成本还是风险成本来说，这都是非常高的。</p>
<h2 id="《深入分析Java-Web技术内幕》"><a href="#《深入分析Java-Web技术内幕》" class="headerlink" title="《深入分析Java Web技术内幕》"></a>《深入分析Java Web技术内幕》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/深入分析Java Web技术内幕.jpeg" alt="深入分析Java Web技术内幕"><br>《深入分析Java Web技术内幕》，作者许令波，淘宝工程师。</p>
<p>这本书我用一个字概括就是：全。真的非常全，HTTP、DNS、CDN、静态化、Jetty、Tomcat、Servlet、Spring、MyBatis等等，什么都有，涉及知识面非常广，但又不像专门精讲某个知识点的书籍一样讲得非常深入，感觉这本书就是尽量去用短的篇幅讲清楚一些Java Web使用到的技术的内幕，让读者对这些知识点的技术内幕有一个理性的认识。</p>
<p>不过，尽管每个知识点的篇幅都不多，但是重点都基本讲到了，是一本让人真正有收获的书。如果想进一步了解这些技术的技术内幕，就要自己去买相关书籍或者自己上网查资料了，有种抛砖引玉，或者说师傅领进门、修行在个人的感觉。</p>
<h2 id="《大型网站技术架构-核心原理与案例分析》"><a href="#《大型网站技术架构-核心原理与案例分析》" class="headerlink" title="《大型网站技术架构 核心原理与案例分析》"></a>《大型网站技术架构 核心原理与案例分析》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/大型网站技术架构 核心原理与案例分析.jpeg" alt="大型网站技术架构 核心原理与案例分析"></p>
<p>一个字评价这本书，屌；两个字评价这本书，很屌；三个字评价这本书，非常屌。呵呵，好了，再说下去可能别人以为我是水军了。</p>
<p>《大型网站技术架构 核心原理与案例分析》的作者是李智慧，原阿里巴巴技术专家。</p>
<p>Java 的大多数应用都是用在Web上的，现在只要稍微大型一点的Web应用，都一定是一个分布式系统，那么一个分布式系统用到了哪些技术？一个大型网站是如何从 一个小型网站成长起来的？如何保证你的网站安全？分布式系统使用到了缓存，有哪些缓存？缓存的使用有哪些值得注意的事项？</p>
<p>关 于分布式的知识点，都在这本书里面有体现，只有你想不到，没有他写不到，而且写得非常易懂，基本属于看一两遍，再记一些笔记就知道是怎么一回事儿了。多看 几遍，对分布式的理解一定会加深不少。而且里面不仅仅是分布式的知识，还非常接地气地写了如何做一个好的架构师，其实我认为这不仅仅是写给想做架构师的读 者看的，就是给读者一些建议，如何更好地提出意见、如何更让别人关注你的声音、如何看到他人的优点，入木三分，让人获益匪浅。</p>
<h2 id="《大型网站系统与Java中间件实践》"><a href="#《大型网站系统与Java中间件实践》" class="headerlink" title="《大型网站系统与Java中间件实践》"></a>《大型网站系统与Java中间件实践》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/大型网站系统与Java中间件实践.jpeg" alt="大型网站系统与Java中间件实践"><br>《大型网站系统与Java中间件实践》作者曾宪杰，是淘宝的技术总监，算起来应该在阿里有至少P8的级别了吧。</p>
<p>这本书的部分内容和上面一本李智慧的《大型网站技术架构 核心原理与案例分析》有所重合，像分布式系统的演化、CDN、CAP理论和BASE理论等等，这也更说明这些都是分布式系统或者说是一个大型网站重点关注的内容，当作一次再学习也不错。</p>
<p>本书要突出的重点是中间件三个字，中间件是分布式系统中一个非常重要的东西，其最重要的作用应该就是解耦，降低模块与模块之间的强依赖，不同的模块之间的依赖度降低，便可以各自独立地开发自己的功能，这也可以说是软件工程发展的目标和驱动力。</p>
<p>因此，本书有一部分的内容就是基于中间件，详细讲解了中间件与JMS的各种知识，适合对分布式系统比较熟悉并且想要往中间件方面有一定研究的读者。</p>
<h2 id="《从Paxos到ZooKeeper-分布式一致性原理与实践》"><a href="#《从Paxos到ZooKeeper-分布式一致性原理与实践》" class="headerlink" title="《从Paxos到ZooKeeper 分布式一致性原理与实践》"></a>《从Paxos到ZooKeeper 分布式一致性原理与实践》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/从Paxos到ZooKeeper 分布式一致性原理与实践.jpeg" alt="从Paxos到ZooKeeper 分布式一致性原理与实践"></p>
<p>《从Paxos到ZooKeeper 分布式一致性原理与实践》，作者倪超，阿里巴巴工程师。</p>
<p>这本书是我最近在研读的一本书，和上面的《大型网站系统与Java中间件实践》一样，属于分布式组件的范畴，属于有些深入的内容，当然也是我自己的个人兴趣。当然，如果有志向做一个出色的大型网站架构师、公司的技术总监之类，这些知识当然是必须掌握的。</p>
<p>本书从分布式系统基本理论开始讲起，讲到Paxos算法，最后慢慢引入到Zookeeper，循序渐进。当然，更多的我目前还不方便发表什么看法，因为这本书的第二张Paxos算法我都还没有弄懂（Paxos算法确实有些难以理解和不太易懂），接下来的章节还没有看下去。</p>
<p>如果网友们所在的公司在使用Zookeeper，并且你又对Zookeeper感兴趣想要研究一下它的原理的，这本书将是不二之选。</p>
<h2 id="《MySQL5-6从零开始学》"><a href="#《MySQL5-6从零开始学》" class="headerlink" title="《MySQL5.6从零开始学》"></a>《MySQL5.6从零开始学》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/MySQL5.6从零开始学.jpeg" alt="MySQL5.6从零开始学"><br>《MySQL5.6从零开始学》，作者刘增杰和李坤。</p>
<p>作为一名Java程序员，我认为我们千万不要觉得数据库是DBA的事情，数据库对一个Java程序员来说也是必须掌握的一门知识，丰富的数据库性能优化经验是一个顶尖程序员必备技能。</p>
<p>目前主流的数据库有Oracle和MySQL，当然推荐大家的是MySQL，主要原因我认为有两点：</p>
<p>1、MySQL相比Oracle更轻量级、更小、安装和卸载更方便，SQL其实都是差不多的，如果想学数据库，学MySQL就可以了，在家里面可以自己方便地研究，如果你的公司使用Oracle，只要再用对比学习法，关注一下Oracle和MySQL的差别即可</p>
<p>2、随着2009年阿里巴巴去IOE的运动的进行，目前国内的很多互联网公司都会选择MySQL作为它们使用的数据库，因为MySQL免费，所以既省钱又不需要出了问题就依赖甲骨文公司</p>
<p>MySQL学习我推荐的是这本我自己学习看的《MySQL5.6从零开始学》，我是觉得挺好的这本书，书里面的知识点很细致、很全面，读者选择书籍的标准大多不就是这两点吗？</p>
<h2 id="《Spring源码深度解析》"><a href="#《Spring源码深度解析》" class="headerlink" title="《Spring源码深度解析》"></a>《Spring源码深度解析》</h2><p><img src="/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/Spring源码深度解析.jpeg" alt="Spring源码深度解析"><br>《Spring源码深度解析》，作者郝佳。</p>
<p>Spring 这个框架做得太好了，功能太强大了，以至于很多开发者都只知Spring，不知什么是工厂、什么是单例、什么是代理（我面试别人的真实体会）。这种功能强 大的框架内部一定是很复杂的实现，这就导致一旦你的程序使用Spring，出了问题，可能是Error、可能是Exception、可能是程序运行结果不 是你的预期的，出现诸如此类问题的时候，将会让你感到困惑，除了上网查资料或者问别人似乎没有更好的解决办法。</p>
<p>研读Spring的源代码不失为一种很好的学习方法，我个人认为这有很多好处：</p>
<p>1、理解框架内部的实现之后，可以主动去解决问题，而不需要依赖别人</p>
<p>2、Spring框架内部实现用到了很多设计模式，很好的代码设计思路，这将会对你写代码、对你理解设计模式有很大的提高</p>
<p>3、研究Spring框架将会大大增强你读代码的能力，我相信只要你能研究清楚Spring内部是如何实现的，其他任何一个框架的源代码都难不倒你</p>
<p>总而言之，我认为读代码的能力是一个普通的程序员和一个好的程序员之间最大的差别之一，前者只会把别人写好的东西拿来用，后者不仅能用好，还清楚知道别人写好的东西底层是如何实现的，在出现问题的时候可以轻松解决。</p>
<p>Spring源代码，个人推荐《Spring源码深度解析》一书，真要研究透并且写清楚Spring源代码，恐怕三四本书都不够，作者在近400页的篇幅中尽量去讲解Spring源代码是如何实现的，殊为不易，尽管无法讲得完全，但是相信作者的讲解配合上读者自己的研究，一定可以对Spring的实现有更深度的理解。</p>
<p>后记</p>
<p>以 上就是我推荐给Java开发者们的一些值得一看的好书。但是这些书里面并没有Java基础、Java教程之类的书，不是我不推荐，而是离我自己学习 Java基础技术也过去好几年了，我学习的时候看的什么也忘了，所以我不能不负责任地推荐一些我自己都没有看过的书给大家。对于Java基础知识的学习， 我提两点建议吧：</p>
<p>1、多写多敲代码，好的代码与扎实的基础知识一定是实践出来的</p>
<p>2、可以去尚学堂下载一下马士兵的视频来学习一下Java基础，还挺不错的，如果尚学堂官网上下载不了可以底下回复，我的电脑里有</p>
<p>最后，每一位读到这里的网友，感谢你们能耐心地看完。希望在成为一名更优秀的Java程序员的道路上，我们可以一起学习、一起进步。</p>
<p>转载：<a href="http://developer.51cto.com/art/201512/503095.htm" target="_blank" rel="external">http://developer.51cto.com/art/201512/503095.htm</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“学习的最好途径就是看书”，这是我自己学习并且小有了一定的积累之后的第一体会。个人认为看书有两点好处：&lt;br&gt;&lt;img src=&quot;/2018/01/30/成为Java顶尖程序员-，看这11本书就够了/1.jpg&quot; alt=&quot;1&quot;&gt;&lt;br&gt;1.能出版出来的书一定是经过反复的思
    
    </summary>
    
      <category term="学习" scheme="http://wangyuanjun.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习" scheme="http://wangyuanjun.cn/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>解决微信公共号开发出现 redirect_uri域名与后台配置不一致，错误码10003 错误</title>
    <link href="http://wangyuanjun.cn/2018/01/27/%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7%E5%BC%80%E5%8F%91%E5%87%BA%E7%8E%B0-redirect-uri%E5%9F%9F%E5%90%8D%E4%B8%8E%E5%90%8E%E5%8F%B0%E9%85%8D%E7%BD%AE%E4%B8%8D%E4%B8%80%E8%87%B4%EF%BC%8C%E9%94%99%E8%AF%AF%E7%A0%8110003-%E9%94%99%E8%AF%AF/"/>
    <id>http://wangyuanjun.cn/2018/01/27/解决微信公共号开发出现-redirect-uri域名与后台配置不一致，错误码10003-错误/</id>
    <published>2018-01-27T15:27:54.000Z</published>
    <updated>2018-02-01T02:51:47.008Z</updated>
    
    <content type="html"><![CDATA[<p>做微信网页OAuth2.0 授权开发，进入授权页面是报错，redirect_uri域名与后台配置不一致，错误码10003<br><img src="/2018/01/27/解决微信公共号开发出现-redirect-uri域名与后台配置不一致，错误码10003-错误/报错.png" alt="报错"></p>
<p>问题原因：<font color="red">可能OAuth2.0网页授权页面没有填写授权回调页面域名，或者域名前面加了 http://</font></p>
<p>解决方法： 到 微信公共平台-&gt;测试号管理-&gt;体验接口权限表-&gt;网页服务-&gt;网页帐号-&gt;修改 ，填写域名<br><img src="/2018/01/27/解决微信公共号开发出现-redirect-uri域名与后台配置不一致，错误码10003-错误/b.png" alt="b"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做微信网页OAuth2.0 授权开发，进入授权页面是报错，redirect_uri域名与后台配置不一致，错误码10003&lt;br&gt;&lt;img src=&quot;/2018/01/27/解决微信公共号开发出现-redirect-uri域名与后台配置不一致，错误码10003-错误/报错.p
    
    </summary>
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>微信公共号开发教程java版——微信网页授权(八)</title>
    <link href="http://wangyuanjun.cn/2018/01/27/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8Bjava%E7%89%88%E2%80%94%E2%80%94%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83-%E5%85%AB/"/>
    <id>http://wangyuanjun.cn/2018/01/27/微信公共号开发教程java版——微信网页授权-八/</id>
    <published>2018-01-27T08:17:17.000Z</published>
    <updated>2018-01-27T14:34:24.532Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：微信网页授权介绍"><a href="#一：微信网页授权介绍" class="headerlink" title="一：微信网页授权介绍"></a>一：微信网页授权介绍</h1><p>官网详细介绍:<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140839" target="_blank" rel="external">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140839</a><br>如果用户在微信客户端中访问第三方网页，公众号可以通过微信网页授权机制，来获取用户基本信息，进而实现业务逻辑。</p>
<h2 id="关于网页授权回调域名的说明"><a href="#关于网页授权回调域名的说明" class="headerlink" title="关于网页授权回调域名的说明"></a>关于网页授权回调域名的说明</h2><p>1、在微信公众号请求用户网页授权之前，开发者需要先到公众平台官网中的“开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息”的配置选项中，修改授权回调域名。请注意，这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头；</p>
<p>2、授权回调域名配置规范为全域名，比如需要网页授权的域名为：www.qq.com，配置以后此域名下面的页面<a href="http://www.qq.com/music.html" target="_blank" rel="external">http://www.qq.com/music.html</a> 、 <a href="http://www.qq.com/login.html" target="_blank" rel="external">http://www.qq.com/login.html</a> 都可以进行OAuth2.0鉴权。但<a href="http://pay.qq.com" target="_blank" rel="external">http://pay.qq.com</a> 、 <a href="http://music.qq.com" target="_blank" rel="external">http://music.qq.com</a> 、 <a href="http://qq.com无法进行OAuth2.0鉴权" target="_blank" rel="external">http://qq.com无法进行OAuth2.0鉴权</a></p>
<p>3、如果公众号登录授权给了第三方开发者来进行管理，则不必做任何设置，由第三方代替公众号实现网页授权即可</p>
<h2 id="关于网页授权的两种scope的区别说明"><a href="#关于网页授权的两种scope的区别说明" class="headerlink" title="关于网页授权的两种scope的区别说明"></a>关于网页授权的两种scope的区别说明</h2><p>1、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
<p>2、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。</p>
<p>3、用户管理类接口中的“获取用户基本信息接口”，是在用户和公众号产生消息交互或关注后事件推送后，才能根据用户OpenID来获取用户基本信息。这个接口，包括其他微信接口，都是需要该用户（即openid）关注了公众号后，才能调用成功的。</p>
<h2 id="关于网页授权access-token和普通access-token的区别"><a href="#关于网页授权access-token和普通access-token的区别" class="headerlink" title="关于网页授权access_token和普通access_token的区别"></a>关于网页授权access_token和普通access_token的区别</h2><p>1、微信网页授权是通过OAuth2.0机制实现的，在用户授权给公众号后，公众号可以获取到一个网页授权特有的接口调用凭证（网页授权access_token），通过网页授权access_token可以进行授权后接口调用，如获取用户基本信息；</p>
<p>2、其他微信接口，需要通过基础支持中的“获取access_token”接口来获取到的普通access_token调用。</p>
<h2 id="关于UnionID机制"><a href="#关于UnionID机制" class="headerlink" title="关于UnionID机制"></a>关于UnionID机制</h2><p>1、请注意，网页授权获取用户基本信息也遵循UnionID机制。即如果开发者有在多个公众号，或在公众号、移动应用之间统一用户帐号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</p>
<p>2、UnionID机制的作用说明：如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为同一用户，对同一个微信开放平台下的不同应用（移动应用、网站应用和公众帐号），unionid是相同的。</p>
<h2 id="关于特殊场景下的静默授权"><a href="#关于特殊场景下的静默授权" class="headerlink" title="关于特殊场景下的静默授权"></a>关于特殊场景下的静默授权</h2><p>1、上面已经提到，对于以snsapi_base为scope的网页授权，就静默授权的，用户无感知；</p>
<p>2、对于已关注公众号的用户，如果用户从公众号的会话或者自定义菜单进入本公众号的网页授权页，即使是scope为snsapi_userinfo，也是静默授权，用户无感知。</p>
<p><strong>具体而言，网页授权流程分为四步：</strong></p>
<p>1、引导用户进入授权页面同意授权，获取code</p>
<p>2、通过code换取网页授权access_token（与基础支持中的access_token不同）</p>
<p>3、如果需要，开发者可以刷新网页授权access_token，避免过期</p>
<p>4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</p>
<h1 id="二：网页授权的实现"><a href="#二：网页授权的实现" class="headerlink" title="二：网页授权的实现"></a>二：网页授权的实现</h1><h2 id="1-用户同意授权，获取code"><a href="#1-用户同意授权，获取code" class="headerlink" title="1.用户同意授权，获取code"></a>1.用户同意授权，获取code</h2><p>在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。</div></pre></td></tr></table></figure>
<p>尤其注意：由于授权操作安全等级较高，所以在发起授权请求时，微信会对授权链接做正则强匹配校验，如果链接的参数顺序不对，授权页面将无法正常访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">参考链接(请在微信客户端中打开此链接体验):</div><div class="line">scope为snsapi_base</div><div class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx520c15f417810387&amp;redirect_uri=https%3A%2F%2Fchong.qq.com%2Fphp%2Findex.php%3Fd%3D%26c%3DwxAdapter%26m%3DmobileDeal%26showwxpaytitle%3D1%26vb2ctag%3D4_2030_5_1194_60&amp;response_type=code&amp;scope=snsapi_base&amp;state=123#wechat_redirect</div><div class="line">scope为snsapi_userinfo</div><div class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxf0e81c3bee622d60&amp;redirect_uri=http%3A%2F%2Fnba.bluewebgame.com%2Foauth_response.php&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=STATE#wechat_redirect</div></pre></td></tr></table></figure>
<p>尤其注意：跳转回调redirect_uri，应当使用https链接来确保授权code的安全性。</p>
<p><strong>参数说明</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:right">是否必须</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>appid</td>
<td style="text-align:right">是</td>
<td style="text-align:center">公众号的唯一标识</td>
</tr>
<tr>
<td>redirect_uri</td>
<td style="text-align:right">是</td>
<td style="text-align:center">授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理</td>
</tr>
<tr>
<td>response_type</td>
<td style="text-align:right">是</td>
<td style="text-align:center">返回类型，请填写code</td>
</tr>
<tr>
<td>scope</td>
<td style="text-align:right">是</td>
<td style="text-align:center">应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ）</td>
</tr>
<tr>
<td>state</td>
<td style="text-align:right">否</td>
<td style="text-align:center">重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节</td>
</tr>
<tr>
<td>#wechat_redirect</td>
<td style="text-align:right">是</td>
<td style="text-align:center">无论直接打开还是做页面302重定向时候，必须带此参数</td>
</tr>
</tbody>
</table>
<p>下图为scope等于snsapi_userinfo时的授权页面：<br><img src="/2018/01/27/微信公共号开发教程java版——微信网页授权-八/授权页面.jpg" alt="授权页面"></p>
<p><strong>用户同意授权后</strong><br>如果用户同意授权，页面将跳转至 redirect_uri/?code=CODE&amp;state=STATE。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">code说明 ： code作为换取access_token的票据，每次用户授权带上的code将不一样，code只能使用一次，5分钟未被使用自动过期。</div></pre></td></tr></table></figure>
<p><strong>错误返回码说明如下：</strong></p>
<table>
<thead>
<tr>
<th>返回码</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>10003</td>
<td style="text-align:center">redirect_uri域名与后台配置不一致</td>
</tr>
<tr>
<td>10004</td>
<td style="text-align:center">此公众号被封禁</td>
</tr>
<tr>
<td>10005</td>
<td style="text-align:center">此公众号并没有这些scope的权限</td>
</tr>
<tr>
<td>10006</td>
<td style="text-align:center">必须关注此测试号</td>
</tr>
<tr>
<td>10009</td>
<td style="text-align:center">操作太频繁了，请稍后重试</td>
</tr>
<tr>
<td>10010</td>
<td style="text-align:center">scope不能为空</td>
</tr>
<tr>
<td>10011</td>
<td style="text-align:center">redirect_uri不能为空</td>
</tr>
<tr>
<td>10012</td>
<td style="text-align:center">appid不能为空</td>
</tr>
<tr>
<td>10013</td>
<td style="text-align:center">state不能为空</td>
</tr>
<tr>
<td>10015</td>
<td style="text-align:center">公众号未授权第三方平台，请检查授权状态</td>
</tr>
<tr>
<td>10016</td>
<td style="text-align:center">不支持微信开放平台的Appid，请使用公众号Appid</td>
</tr>
</tbody>
</table>
<h2 id="2-通过网页授权获取的用户信息"><a href="#2-通过网页授权获取的用户信息" class="headerlink" title="2. 通过网页授权获取的用户信息"></a>2. 通过网页授权获取的用户信息</h2><p><strong>用户信息类：SNSUserInfo类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.pojo;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通过网页授权获取的用户信息</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月24日 下午3:09:02</div><div class="line"> */</div><div class="line">public class SNSUserInfo &#123;</div><div class="line"></div><div class="line">    // 用户标识</div><div class="line">    private String openId;</div><div class="line"></div><div class="line">    // 用户昵称</div><div class="line">    private String nickname;</div><div class="line"></div><div class="line">    // 性别（1是男性，2是女性，0是未知）</div><div class="line">    private int sex;</div><div class="line"></div><div class="line">    // 国家</div><div class="line">    private String country;</div><div class="line"></div><div class="line">    // 省份</div><div class="line">    private String province;</div><div class="line"></div><div class="line">    // 城市</div><div class="line">    private String city;</div><div class="line"></div><div class="line">    // 用户头像链接</div><div class="line">    private String headImgUrl;</div><div class="line"></div><div class="line">    // 用户特权信息</div><div class="line">    private List&lt;String&gt; privilegeList;</div><div class="line"></div><div class="line">    public String getOpenId() &#123;</div><div class="line">        return openId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setOpenId(String openId) &#123;</div><div class="line">        this.openId = openId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getNickname() &#123;</div><div class="line">        return nickname;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setNickname(String nickname) &#123;</div><div class="line">        this.nickname = nickname;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getSex() &#123;</div><div class="line">        return sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSex(int sex) &#123;</div><div class="line">        this.sex = sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCountry() &#123;</div><div class="line">        return country;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCountry(String country) &#123;</div><div class="line">        this.country = country;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getProvince() &#123;</div><div class="line">        return province;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setProvince(String province) &#123;</div><div class="line">        this.province = province;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCity() &#123;</div><div class="line">        return city;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCity(String city) &#123;</div><div class="line">        this.city = city;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getHeadImgUrl() &#123;</div><div class="line">        return headImgUrl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setHeadImgUrl(String headImgUrl) &#123;</div><div class="line">        this.headImgUrl = headImgUrl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public List&lt;String&gt; getPrivilegeList() &#123;</div><div class="line">        return privilegeList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setPrivilegeList(List&lt;String&gt; privilegeList) &#123;</div><div class="line">        this.privilegeList = privilegeList;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-凭证实体类"><a href="#3-凭证实体类" class="headerlink" title="3.凭证实体类"></a>3.凭证实体类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.pojo;</div><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * 凭证</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:19:14</div><div class="line"> */</div><div class="line">public class Token &#123;</div><div class="line"></div><div class="line">    // 接口访问凭证</div><div class="line">    private String accessToken;</div><div class="line"></div><div class="line">    // 凭证有效期，单位：秒</div><div class="line">    private int expiresIn;</div><div class="line"></div><div class="line">    public String getAccessToken() &#123;</div><div class="line">        return accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAccessToken(String accessToken) &#123;</div><div class="line">        this.accessToken = accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getExpiresIn() &#123;</div><div class="line">        return expiresIn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setExpiresIn(int expiresIn) &#123;</div><div class="line">        this.expiresIn = expiresIn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-网页授权信息-WeixinOauth2Token类"><a href="#4-网页授权信息-WeixinOauth2Token类" class="headerlink" title="4.网页授权信息 WeixinOauth2Token类"></a>4.网页授权信息 WeixinOauth2Token类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.pojo;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 网页授权信息</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月24日 下午3:10:03</div><div class="line"> */</div><div class="line">public class WeixinOauth2Token &#123;</div><div class="line"></div><div class="line">    // 网页授权接口调用凭证</div><div class="line">    private String accessToken;</div><div class="line"></div><div class="line">    // 凭证有效时长</div><div class="line">    private int expiresIn;</div><div class="line"></div><div class="line">    // 用于刷新凭证</div><div class="line">    private String refreshToken;</div><div class="line"></div><div class="line">    // 用户标识</div><div class="line">    private String openId;</div><div class="line"></div><div class="line">    // 用户授权作用域</div><div class="line">    private String scope;</div><div class="line"></div><div class="line">    public String getAccessToken() &#123;</div><div class="line">        return accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAccessToken(String accessToken) &#123;</div><div class="line">        this.accessToken = accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getExpiresIn() &#123;</div><div class="line">        return expiresIn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setExpiresIn(int expiresIn) &#123;</div><div class="line">        this.expiresIn = expiresIn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getRefreshToken() &#123;</div><div class="line">        return refreshToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setRefreshToken(String refreshToken) &#123;</div><div class="line">        this.refreshToken = refreshToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getOpenId() &#123;</div><div class="line">        return openId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setOpenId(String openId) &#123;</div><div class="line">        this.openId = openId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getScope() &#123;</div><div class="line">        return scope;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setScope(String scope) &#123;</div><div class="line">        this.scope = scope;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="5-微信用户的基本信息WeixinUserInfo类"><a href="#5-微信用户的基本信息WeixinUserInfo类" class="headerlink" title="5.微信用户的基本信息WeixinUserInfo类"></a>5.微信用户的基本信息WeixinUserInfo类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.pojo;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 微信用户的基本信息</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月24日 上午10:05:42</div><div class="line"> */</div><div class="line">public class WeixinUserInfo &#123;</div><div class="line"></div><div class="line">    // 用户的标识</div><div class="line">    private String openId;</div><div class="line"></div><div class="line">    // 关注状态（1是关注，0是未关注），未关注时获取不到其余信息</div><div class="line">    private int subscribe;</div><div class="line"></div><div class="line">    // 用户关注时间，为时间戳。如果用户曾多次关注，则取最后关注时间</div><div class="line">    private String subscribeTime;</div><div class="line"></div><div class="line">    // 昵称</div><div class="line">    private String nickname;</div><div class="line"></div><div class="line">    // 用户的性别（1是男性，2是女性，0是未知）</div><div class="line">    private int sex;</div><div class="line"></div><div class="line">    // 用户所在国家</div><div class="line">    private String country;</div><div class="line"></div><div class="line">    // 用户所在省份</div><div class="line">    private String province;</div><div class="line"></div><div class="line">    // 用户所在城市</div><div class="line">    private String city;</div><div class="line"></div><div class="line">    // 用户的语言，简体中文为zh_CN</div><div class="line">    private String language;</div><div class="line"></div><div class="line">    // 用户头像</div><div class="line">    private String headImgUrl;</div><div class="line"></div><div class="line">    public String getOpenId() &#123;</div><div class="line">        return openId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setOpenId(String openId) &#123;</div><div class="line">        this.openId = openId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getSubscribe() &#123;</div><div class="line">        return subscribe;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSubscribe(int subscribe) &#123;</div><div class="line">        this.subscribe = subscribe;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getSubscribeTime() &#123;</div><div class="line">        return subscribeTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSubscribeTime(String subscribeTime) &#123;</div><div class="line">        this.subscribeTime = subscribeTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getNickname() &#123;</div><div class="line">        return nickname;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setNickname(String nickname) &#123;</div><div class="line">        this.nickname = nickname;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getSex() &#123;</div><div class="line">        return sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSex(int sex) &#123;</div><div class="line">        this.sex = sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCountry() &#123;</div><div class="line">        return country;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCountry(String country) &#123;</div><div class="line">        this.country = country;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getProvince() &#123;</div><div class="line">        return province;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setProvince(String province) &#123;</div><div class="line">        this.province = province;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCity() &#123;</div><div class="line">        return city;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCity(String city) &#123;</div><div class="line">        this.city = city;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getLanguage() &#123;</div><div class="line">        return language;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setLanguage(String language) &#123;</div><div class="line">        this.language = language;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getHeadImgUrl() &#123;</div><div class="line">        return headImgUrl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setHeadImgUrl(String headImgUrl) &#123;</div><div class="line">        this.headImgUrl = headImgUrl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="6-获取网页授权凭证及获取用户信息"><a href="#6-获取网页授权凭证及获取用户信息" class="headerlink" title="6.获取网页授权凭证及获取用户信息"></a>6.获取网页授权凭证及获取用户信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.utils;</div><div class="line"></div><div class="line">import java.util.List;</div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import com.wyj.wechart.pojo.SNSUserInfo;</div><div class="line">import com.wyj.wechart.pojo.WeixinOauth2Token;</div><div class="line"></div><div class="line">import net.sf.json.JSONArray;</div><div class="line">import net.sf.json.JSONObject;</div><div class="line">/**</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月24日 下午3:19:44</div><div class="line"> */</div><div class="line">public class AdvancedUtil &#123;</div><div class="line"></div><div class="line">    private static Logger log = LoggerFactory.getLogger(AdvancedUtil.class);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取网页授权凭证</div><div class="line">     * </div><div class="line">     * @param appId</div><div class="line">     *            公众账号的唯一标识</div><div class="line">     * @param appSecret</div><div class="line">     *            公众账号的密钥</div><div class="line">     * @param code</div><div class="line">     * @return WeixinAouth2Token</div><div class="line">     */</div><div class="line">    public static WeixinOauth2Token getOauth2AccessToken(String appId, String appSecret, String code) &#123;</div><div class="line">        WeixinOauth2Token wat = null;</div><div class="line">        // 拼接请求地址</div><div class="line">        String requestUrl = &quot;https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code&quot;;</div><div class="line">        requestUrl = requestUrl.replace(&quot;APPID&quot;, appId);</div><div class="line">        requestUrl = requestUrl.replace(&quot;SECRET&quot;, appSecret);</div><div class="line">        requestUrl = requestUrl.replace(&quot;CODE&quot;, code);</div><div class="line">        // 获取网页授权凭证</div><div class="line">        JSONObject jsonObject = CommonUtil.httpsRequest(requestUrl, &quot;GET&quot;, null);</div><div class="line">        if (null != jsonObject) &#123;</div><div class="line">            try &#123;</div><div class="line">                wat = new WeixinOauth2Token();</div><div class="line">                wat.setAccessToken(jsonObject.getString(&quot;access_token&quot;));</div><div class="line">                wat.setExpiresIn(jsonObject.getInt(&quot;expires_in&quot;));</div><div class="line">                wat.setRefreshToken(jsonObject.getString(&quot;refresh_token&quot;));</div><div class="line">                wat.setOpenId(jsonObject.getString(&quot;openid&quot;));</div><div class="line">                wat.setScope(jsonObject.getString(&quot;scope&quot;));</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                wat = null;</div><div class="line">                int errorCode = jsonObject.getInt(&quot;errcode&quot;);</div><div class="line">                String errorMsg = jsonObject.getString(&quot;errmsg&quot;);</div><div class="line">                log.error(&quot;获取网页授权凭证失败 errcode:&#123;&#125; errmsg:&#123;&#125;&quot;, errorCode, errorMsg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return wat;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 通过网页授权获取用户信息</div><div class="line">     * </div><div class="line">     * @param accessToken</div><div class="line">     *            网页授权接口调用凭证</div><div class="line">     * @param openId</div><div class="line">     *            用户标识</div><div class="line">     * @return SNSUserInfo</div><div class="line">     */</div><div class="line">    @SuppressWarnings(&#123; &quot;deprecation&quot;, &quot;unchecked&quot; &#125;)</div><div class="line">    public static SNSUserInfo getSNSUserInfo(String accessToken, String openId) &#123;</div><div class="line">        SNSUserInfo snsUserInfo = null;</div><div class="line">        // 拼接请求地址</div><div class="line">        String requestUrl = &quot;https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&quot;;</div><div class="line">        requestUrl = requestUrl.replace(&quot;ACCESS_TOKEN&quot;, accessToken).replace(&quot;OPENID&quot;, openId);</div><div class="line">        // 通过网页授权获取用户信息</div><div class="line">        JSONObject jsonObject = CommonUtil.httpsRequest(requestUrl, &quot;GET&quot;, null);</div><div class="line"></div><div class="line">        if (null != jsonObject) &#123;</div><div class="line">            try &#123;</div><div class="line">                snsUserInfo = new SNSUserInfo();</div><div class="line">                // 用户的标识</div><div class="line">                snsUserInfo.setOpenId(jsonObject.getString(&quot;openid&quot;));</div><div class="line">                // 昵称</div><div class="line">                snsUserInfo.setNickname(jsonObject.getString(&quot;nickname&quot;));</div><div class="line">                // 性别（1是男性，2是女性，0是未知）</div><div class="line">                snsUserInfo.setSex(jsonObject.getInt(&quot;sex&quot;));</div><div class="line">                // 用户所在国家</div><div class="line">                snsUserInfo.setCountry(jsonObject.getString(&quot;country&quot;));</div><div class="line">                // 用户所在省份</div><div class="line">                snsUserInfo.setProvince(jsonObject.getString(&quot;province&quot;));</div><div class="line">                // 用户所在城市</div><div class="line">                snsUserInfo.setCity(jsonObject.getString(&quot;city&quot;));</div><div class="line">                // 用户头像</div><div class="line">                snsUserInfo.setHeadImgUrl(jsonObject.getString(&quot;headimgurl&quot;));</div><div class="line">                // 用户特权信息</div><div class="line">                snsUserInfo.setPrivilegeList(JSONArray.toList(jsonObject.getJSONArray(&quot;privilege&quot;), List.class));</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                snsUserInfo = null;</div><div class="line">                int errorCode = jsonObject.getInt(&quot;errcode&quot;);</div><div class="line">                String errorMsg = jsonObject.getString(&quot;errmsg&quot;);</div><div class="line">                log.error(&quot;获取用户信息失败 errcode:&#123;&#125; errmsg:&#123;&#125;&quot;, errorCode, errorMsg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return snsUserInfo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="7-封装https请求类-CommonUtil-类"><a href="#7-封装https请求类-CommonUtil-类" class="headerlink" title="7.封装https请求类 CommonUtil 类"></a>7.封装https请求类 CommonUtil 类</h2><p>https请求的工具</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.utils;</div><div class="line"></div><div class="line">import java.security.cert.CertificateException;</div><div class="line">import java.security.cert.X509Certificate;</div><div class="line"></div><div class="line">import javax.net.ssl.X509TrustManager;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 证书信任管理器（用于https请求）</div><div class="line"> * 这个证书管理器的作用就是让它信任我们指定的证书，下面的代码意味着信任所有证书，不管是否权威机构颁发。</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:22:19</div><div class="line"> */</div><div class="line">public class MyX509TrustManager implements X509TrustManager &#123;</div><div class="line"></div><div class="line">    // 检查客户端证书</div><div class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 检查服务器端证书</div><div class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回受信任的X509证书数组</div><div class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 发送https请求</div><div class="line"> * </div><div class="line"> * @param requestUrl</div><div class="line"> *            请求地址</div><div class="line"> * @param requestMethod</div><div class="line"> *            请求方式（GET、POST）</div><div class="line"> * @param outputStr</div><div class="line"> *            提交的数据</div><div class="line"> * @return JSONObject(通过JSONObject.get(key)的方式获取json对象的属性值)</div><div class="line"> */</div><div class="line">public static JSONObject httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123;</div><div class="line">    JSONObject jsonObject = null;</div><div class="line">    try &#123;</div><div class="line">        // 创建SSLContext对象，并使用我们指定的信任管理器初始化</div><div class="line">        TrustManager[] tm = &#123; new MyX509TrustManager() &#125;;</div><div class="line">        SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</div><div class="line">        sslContext.init(null, tm, new java.security.SecureRandom());</div><div class="line">        // 从上述SSLContext对象中得到SSLSocketFactory对象</div><div class="line">        SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class="line"></div><div class="line">        URL url = new URL(requestUrl);</div><div class="line">        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();</div><div class="line">        conn.setSSLSocketFactory(ssf);</div><div class="line"></div><div class="line">        conn.setDoOutput(true);</div><div class="line">        conn.setDoInput(true);</div><div class="line">        conn.setUseCaches(false);</div><div class="line">        // 设置请求方式（GET/POST）</div><div class="line">        conn.setRequestMethod(requestMethod);</div><div class="line"></div><div class="line">        // 当outputStr不为null时向输出流写数据</div><div class="line">        if (null != outputStr) &#123;</div><div class="line">            OutputStream outputStream = conn.getOutputStream();</div><div class="line">            // 注意编码格式</div><div class="line">            outputStream.write(outputStr.getBytes(&quot;UTF-8&quot;));</div><div class="line">            outputStream.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 从输入流读取返回内容</div><div class="line">        InputStream inputStream = conn.getInputStream();</div><div class="line">        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, &quot;utf-8&quot;);</div><div class="line">        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);</div><div class="line">        String str = null;</div><div class="line">        StringBuffer buffer = new StringBuffer();</div><div class="line">        while ((str = bufferedReader.readLine()) != null) &#123;</div><div class="line">            buffer.append(str);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 释放资源</div><div class="line">        bufferedReader.close();</div><div class="line">        inputStreamReader.close();</div><div class="line">        inputStream.close();</div><div class="line">        inputStream = null;</div><div class="line">        conn.disconnect();</div><div class="line">        jsonObject = JSONObject.fromObject(buffer.toString());</div><div class="line">    &#125; catch (ConnectException ce) &#123;</div><div class="line">        log.error(&quot;连接超时：&#123;&#125;&quot;, ce);</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        log.error(&quot;https请求异常：&#123;&#125;&quot;, e);</div><div class="line">    &#125;</div><div class="line">    return jsonObject;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="8-写授权类："><a href="#8-写授权类：" class="headerlink" title="8.写授权类："></a>8.写授权类：</h2><p>替换成自己的appid 和 密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.controller;</div><div class="line"></div><div class="line">import org.springframework.stereotype.Controller;</div><div class="line">import org.springframework.web.bind.annotation.RequestMapping;</div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line"></div><div class="line">import com.wyj.wechart.pojo.SNSUserInfo;</div><div class="line">import com.wyj.wechart.pojo.WeixinOauth2Token;</div><div class="line">import com.wyj.wechart.utils.AdvancedUtil;</div><div class="line">/**</div><div class="line"> * 授权后的回调请求处理</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月27日 下午5:31:09</div><div class="line"> */</div><div class="line">@Controller</div><div class="line">@RequestMapping(&quot;/oauth&quot;)</div><div class="line">public class OAuthController &#123;</div><div class="line"></div><div class="line">    @RequestMapping</div><div class="line">    public ModelAndView index(String code,String state)&#123;</div><div class="line">        ModelAndView mv = new ModelAndView(&quot;/index&quot;);</div><div class="line">        </div><div class="line">        // 用户同意授权</div><div class="line">        if (!&quot;authdeny&quot;.equals(code)) &#123;</div><div class="line">            // 获取网页授权access_token</div><div class="line">            WeixinOauth2Token weixinOauth2Token = AdvancedUtil.getOauth2AccessToken(&quot;wx17fdedc3d6d0b68e&quot;, &quot;c3b3d919d65a781ba7db58d9d8dfb515&quot;, code);</div><div class="line">            // 网页授权接口访问凭证</div><div class="line">            String accessToken = weixinOauth2Token.getAccessToken();</div><div class="line">            // 用户标识</div><div class="line">            String openId = weixinOauth2Token.getOpenId();</div><div class="line">            // 获取用户信息</div><div class="line">            SNSUserInfo snsUserInfo = AdvancedUtil.getSNSUserInfo(accessToken, openId);</div><div class="line">            // 设置要传递的参数</div><div class="line">            mv.addObject(&quot;snsUserInfo&quot;, snsUserInfo);</div><div class="line">            mv.addObject(&quot;state&quot;, state);</div><div class="line">        &#125;</div><div class="line">        return mv;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="9-授权后，显示信息的页面"><a href="#9-授权后，显示信息的页面" class="headerlink" title="9.授权后，显示信息的页面"></a>9.授权后，显示信息的页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">&lt;title&gt;OAuth2.0网页授权&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line"></div><div class="line">&lt;#if snsUserInfo??&gt;</div><div class="line">    &lt;table width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;</div><div class="line">        &lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;属性&lt;/td&gt;&lt;td width=&quot;80%&quot;&gt;值&lt;/td&gt;&lt;/tr&gt;</div><div class="line">        &lt;tr&gt;&lt;td&gt;OpenID&lt;/td&gt;&lt;td&gt;$&#123;snsUserInfo.openId&#125;&lt;/td&gt;&lt;/tr&gt;</div><div class="line">        &lt;tr&gt;&lt;td&gt;昵称&lt;/td&gt;&lt;td&gt;$&#123;snsUserInfo.nickname&#125;&lt;/td&gt;&lt;/tr&gt;</div><div class="line">        &lt;tr&gt;&lt;td&gt;性别&lt;/td&gt;&lt;td&gt;$&#123;snsUserInfo.sex&#125;&lt;/td&gt;&lt;/tr&gt;</div><div class="line">        &lt;tr&gt;&lt;td&gt;国家&lt;/td&gt;&lt;td&gt;$&#123;snsUserInfo.country&#125;&lt;/td&gt;&lt;/tr&gt;</div><div class="line">        &lt;tr&gt;&lt;td&gt;省份&lt;/td&gt;&lt;td&gt;$&#123;snsUserInfo.province&#125;&lt;/td&gt;&lt;/tr&gt;</div><div class="line">        &lt;tr&gt;&lt;td&gt;城市&lt;/td&gt;&lt;td&gt;$&#123;snsUserInfo.city&#125;&lt;/td&gt;&lt;/tr&gt;</div><div class="line">        &lt;tr&gt;&lt;td&gt;头像&lt;/td&gt;&lt;td&gt;$&#123;snsUserInfo.headImgUrl&#125;&lt;/td&gt;&lt;/tr&gt;</div><div class="line">&lt;!--         &lt;tr&gt;&lt;td&gt;特权&lt;/td&gt;&lt;td&gt;$&#123;snsUserInfo.privilegeList&#125;&lt;/td&gt;&lt;/tr&gt; --&gt;</div><div class="line">        &lt;tr&gt;&lt;td&gt;state:&lt;/td&gt;&lt;td&gt;$&#123;state&#125;&lt;/td&gt;&lt;/tr&gt;</div><div class="line">    &lt;/table&gt;</div><div class="line">	</div><div class="line">	&lt;#else&gt;</div><div class="line">	&lt;p&gt;用户不同意授权,未获取到用户信息！&lt;/p&gt;</div><div class="line">&lt;/#if&gt;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h2 id="10-application-properties配置"><a href="#10-application-properties配置" class="headerlink" title="10.application.properties配置"></a>10.application.properties配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">server.port=80</div><div class="line"></div><div class="line">spring.freemarker.cache=false</div><div class="line">spring.freemarker.charset=UTF-8</div><div class="line">spring.freemarker.check-template-location=true</div><div class="line">spring.freemarker.content-type=text/html</div><div class="line">spring.freemarker.expose-request-attributes=true</div><div class="line">spring.freemarker.expose-session-attributes=true</div><div class="line">spring.freemarker.request-context-attribute=request</div><div class="line">spring.freemarker.template-loader-path=classpath:/templates</div><div class="line">spring.freemarker.suffix=.html</div><div class="line">spring.mvc.static-path-pattern=/static/**</div></pre></td></tr></table></figure>
<h2 id="11-替换官方的链接成我们的方法路径："><a href="#11-替换官方的链接成我们的方法路径：" class="headerlink" title="11.替换官方的链接成我们的方法路径："></a>11.替换官方的链接成我们的方法路径：</h2><p><strong>官方的请求链接：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect</div></pre></td></tr></table></figure>
<p>需要修改的地方：</p>
<p>（1）替换自己的AppID</p>
<p>（2）将redirect_url换成自己的授权请求链接URL。注意这个连接需要经过UTF-8编码。</p>
<p>（3）需要修改scope。需要弹出页面则要修改为snsapi_userinfo 。</p>
<p>scope参数的解释：</p>
<p>1、以snsapi_base为scope发起的网页授权，是用来获取进入页面的用户的openid的，并且是静默授权并自动跳转到回调页的。用户感知的就是直接进入了回调页（往往是业务页面）</p>
<p>2、以snsapi_userinfo为scope发起的网页授权，是用来获取用户的基本信息的。但这种授权需要用户手动同意，并且由于用户同意过，所以无须关注，就可在授权后获取该用户的基本信息。 </p>
<p><strong>URL转码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * URL编码（utf-8）</div><div class="line"> * </div><div class="line"> * @param source</div><div class="line"> * @return</div><div class="line"> */</div><div class="line">public static String urlEncodeUTF8(String source) &#123;</div><div class="line">    String result = source;</div><div class="line">    try &#123;</div><div class="line">        result = java.net.URLEncoder.encode(source, &quot;utf-8&quot;);</div><div class="line">    &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.test;</div><div class="line"></div><div class="line">import com.wyj.wechart.utils.CommonUtil;</div><div class="line">/**</div><div class="line"> * URL转码</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月27日 下午5:35:02</div><div class="line"> */</div><div class="line">public class TransCodeUrlTest &#123;</div><div class="line">    /**</div><div class="line">     * 生成URL编码</div><div class="line">     * </div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        String source = &quot;http://6400cc45.ngrok.io/oauth&quot;;</div><div class="line">        System.out.println(CommonUtil.urlEncodeUTF8(source));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以直接在线url编码： <a href="http://tool.chinaz.com/Tools/URLEncode.aspx" target="_blank" rel="external">http://tool.chinaz.com/Tools/URLEncode.aspx</a></p>
<h2 id="12-修改网页授权获取用户基本信息"><a href="#12-修改网页授权获取用户基本信息" class="headerlink" title="12.修改网页授权获取用户基本信息"></a>12.修改网页授权获取用户基本信息</h2><p>微信公共平台-&gt;测试号管理-&gt;体验接口权限表-&gt;网页服务-&gt;网页帐号-&gt;修改<br>修改完成后需要重新关注<br><img src="/2018/01/27/微信公共号开发教程java版——微信网页授权-八/a.png" alt="a"><br><img src="/2018/01/27/微信公共号开发教程java版——微信网页授权-八/b.png" alt="b"></p>
<h2 id="13-测试效果："><a href="#13-测试效果：" class="headerlink" title="13.测试效果："></a>13.测试效果：</h2><p>复制上面替换好的链接，然后丢进浏览器，然后用微信来扫一扫。<br><img src="/2018/01/27/微信公共号开发教程java版——微信网页授权-八/c.png" alt="c"><br><img src="/2018/01/27/微信公共号开发教程java版——微信网页授权-八/d.jpg" alt="d"></p>
<p><font color="red">注：github项目地址：</font><a href="https://github.com/wangyuanjun008/wyj-wechat-demo" target="_blank" rel="external">微信公共号开发用例</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：微信网页授权介绍&quot;&gt;&lt;a href=&quot;#一：微信网页授权介绍&quot; class=&quot;headerlink&quot; title=&quot;一：微信网页授权介绍&quot;&gt;&lt;/a&gt;一：微信网页授权介绍&lt;/h1&gt;&lt;p&gt;官网详细介绍:&lt;a href=&quot;https://mp.weixin.qq.c
    
    </summary>
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>微信公共号开发教程java版——获取用户基本信息(UnionID机制)(七)</title>
    <link href="http://wangyuanjun.cn/2018/01/27/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8Bjava%E7%89%88%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF-UnionID%E6%9C%BA%E5%88%B6-%E4%B8%83/"/>
    <id>http://wangyuanjun.cn/2018/01/27/微信公共号开发教程java版——获取用户基本信息-UnionID机制-七/</id>
    <published>2018-01-27T07:14:32.000Z</published>
    <updated>2018-01-27T14:34:06.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：UnionID机制说明"><a href="#一：UnionID机制说明" class="headerlink" title="一：UnionID机制说明"></a>一：UnionID机制说明</h1><p>官网详细介绍:<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140839" target="_blank" rel="external">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140839</a></p>
<h2 id="获取用户基本信息-UnionID机制"><a href="#获取用户基本信息-UnionID机制" class="headerlink" title="获取用户基本信息(UnionID机制)"></a>获取用户基本信息(UnionID机制)</h2><p>在关注者与公众号产生消息交互后，公众号可获得关注者的OpenID（加密后的微信号，每个用户对每个公众号的OpenID是唯一的。对于不同公众号，同一用户的openid不同）。公众号可通过本接口来根据OpenID获取用户基本信息，包括昵称、头像、性别、所在城市、语言和关注时间。</p>
<p>请注意，如果开发者有在多个公众号，或在公众号、移动应用之间统一用户帐号的需求，需要前往微信开放平台（open.weixin.qq.com）绑定公众号后，才可利用UnionID机制来满足上述需求。</p>
<h2 id="UnionID机制说明："><a href="#UnionID机制说明：" class="headerlink" title="UnionID机制说明："></a>UnionID机制说明：</h2><p>开发者可通过OpenID来获取用户基本信息。特别需要注意的是，如果开发者拥有多个移动应用、网站应用和公众帐号，可通过获取用户基本信息中的unionid来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号，用户的unionid是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。</p>
<h2 id="获取用户基本信息（包括UnionID机制）"><a href="#获取用户基本信息（包括UnionID机制）" class="headerlink" title="获取用户基本信息（包括UnionID机制）"></a>获取用户基本信息（包括UnionID机制）</h2><p>开发者可通过OpenID来获取用户基本信息。请使用https协议。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">接口调用请求说明</div><div class="line">http请求方式: GET</div><div class="line">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</div></pre></td></tr></table></figure>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:right">是否必须</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>access_token</td>
<td style="text-align:right">是</td>
<td style="text-align:center">调用接口凭证</td>
</tr>
<tr>
<td>openid</td>
<td style="text-align:right">是</td>
<td style="text-align:center">普通用户的标识，对当前公众号唯一</td>
</tr>
<tr>
<td>lang</td>
<td style="text-align:right">否</td>
<td style="text-align:center">返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语</td>
</tr>
</tbody>
</table>
<p>返回说明</p>
<p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;subscribe&quot;: 1, </div><div class="line">    &quot;openid&quot;: &quot;o6_bmjrPTlm6_2sgVt7hMZOPfL2M&quot;, </div><div class="line">    &quot;nickname&quot;: &quot;Band&quot;, </div><div class="line">    &quot;sex&quot;: 1, </div><div class="line">    &quot;language&quot;: &quot;zh_CN&quot;, </div><div class="line">    &quot;city&quot;: &quot;广州&quot;, </div><div class="line">    &quot;province&quot;: &quot;广东&quot;, </div><div class="line">    &quot;country&quot;: &quot;中国&quot;, </div><div class="line">    &quot;headimgurl&quot;:&quot;http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0&quot;,</div><div class="line">    &quot;subscribe_time&quot;: 1382694957,</div><div class="line">    &quot;unionid&quot;: &quot; o6_bmasdasdsad6_2sgVt7hMZOPfL&quot;</div><div class="line">    &quot;remark&quot;: &quot;&quot;,</div><div class="line">    &quot;groupid&quot;: 0,</div><div class="line">    &quot;tagid_list&quot;:[128,2]</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>subscribe</td>
<td>用户是否订阅该公众号标识，值为0时，代表此用户没有关注该公众号，拉取不到其余信息。</td>
</tr>
<tr>
<td>openid</td>
<td>用户的标识，对当前公众号唯一</td>
</tr>
<tr>
<td>nickname</td>
<td>用户的昵称</td>
</tr>
<tr>
<td>sex</td>
<td>用户的性别，值为1时是男性，值为2时是女性，值为0时是未知</td>
</tr>
<tr>
<td>city</td>
<td>用户所在城市</td>
</tr>
<tr>
<td>country</td>
<td>用户所在国家</td>
</tr>
<tr>
<td>province</td>
<td>用户所在省份</td>
</tr>
<tr>
<td>language</td>
<td>用户的语言，简体中文为zh_CN</td>
</tr>
<tr>
<td>headimgurl</td>
<td>用户头像，最后一个数值代表正方形头像大小（有0、46、64、96、132数值可选，0代表640*640正方形头像），用户没有头像时该项为空。若用户更换头像，原有头像URL将失效。</td>
</tr>
<tr>
<td>subscribe_time</td>
<td>用户关注时间，为时间戳。如果用户曾多次关注，则取最后关注时间</td>
</tr>
<tr>
<td>unionid</td>
<td>只有在用户将公众号绑定到微信开放平台帐号后，才会出现该字段。</td>
</tr>
<tr>
<td>remark</td>
<td>公众号运营者对粉丝的备注，公众号运营者可在微信公众平台用户管理界面对粉丝添加备注</td>
</tr>
<tr>
<td>groupid</td>
<td>用户所在的分组ID（兼容旧的用户分组接口）</td>
</tr>
<tr>
<td>tagid_list</td>
<td>用户被打上的标签ID列表</td>
</tr>
</tbody>
</table>
<p>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为AppID无效错误）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;errcode&quot;:40013,&quot;errmsg&quot;:&quot;invalid appid&quot;&#125;</div></pre></td></tr></table></figure>
<h1 id="二：封装用户信息"><a href="#二：封装用户信息" class="headerlink" title="二：封装用户信息"></a>二：封装用户信息</h1><h2 id="1-用户的基本信息类"><a href="#1-用户的基本信息类" class="headerlink" title="1.用户的基本信息类"></a>1.用户的基本信息类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.pojo;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 微信用户的基本信息</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月24日 上午10:05:42</div><div class="line"> */</div><div class="line">public class WeixinUserInfo &#123;</div><div class="line"></div><div class="line">    // 用户的标识</div><div class="line">    private String openId;</div><div class="line"></div><div class="line">    // 关注状态（1是关注，0是未关注），未关注时获取不到其余信息</div><div class="line">    private int subscribe;</div><div class="line"></div><div class="line">    // 用户关注时间，为时间戳。如果用户曾多次关注，则取最后关注时间</div><div class="line">    private String subscribeTime;</div><div class="line"></div><div class="line">    // 昵称</div><div class="line">    private String nickname;</div><div class="line"></div><div class="line">    // 用户的性别（1是男性，2是女性，0是未知）</div><div class="line">    private int sex;</div><div class="line"></div><div class="line">    // 用户所在国家</div><div class="line">    private String country;</div><div class="line"></div><div class="line">    // 用户所在省份</div><div class="line">    private String province;</div><div class="line"></div><div class="line">    // 用户所在城市</div><div class="line">    private String city;</div><div class="line"></div><div class="line">    // 用户的语言，简体中文为zh_CN</div><div class="line">    private String language;</div><div class="line"></div><div class="line">    // 用户头像</div><div class="line">    private String headImgUrl;</div><div class="line"></div><div class="line">    public String getOpenId() &#123;</div><div class="line">        return openId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setOpenId(String openId) &#123;</div><div class="line">        this.openId = openId;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getSubscribe() &#123;</div><div class="line">        return subscribe;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSubscribe(int subscribe) &#123;</div><div class="line">        this.subscribe = subscribe;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getSubscribeTime() &#123;</div><div class="line">        return subscribeTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSubscribeTime(String subscribeTime) &#123;</div><div class="line">        this.subscribeTime = subscribeTime;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getNickname() &#123;</div><div class="line">        return nickname;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setNickname(String nickname) &#123;</div><div class="line">        this.nickname = nickname;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getSex() &#123;</div><div class="line">        return sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSex(int sex) &#123;</div><div class="line">        this.sex = sex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCountry() &#123;</div><div class="line">        return country;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCountry(String country) &#123;</div><div class="line">        this.country = country;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getProvince() &#123;</div><div class="line">        return province;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setProvince(String province) &#123;</div><div class="line">        this.province = province;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCity() &#123;</div><div class="line">        return city;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCity(String city) &#123;</div><div class="line">        this.city = city;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getLanguage() &#123;</div><div class="line">        return language;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setLanguage(String language) &#123;</div><div class="line">        this.language = language;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getHeadImgUrl() &#123;</div><div class="line">        return headImgUrl;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setHeadImgUrl(String headImgUrl) &#123;</div><div class="line">        this.headImgUrl = headImgUrl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们先来看看获取用户信息的接口：<br><a href="https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN</a><br>根据分析，获取用户的基本信息需要一个token。</p>
<h2 id="创建token类"><a href="#创建token类" class="headerlink" title="创建token类"></a>创建token类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.pojo;</div><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * 凭证</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:19:14</div><div class="line"> */</div><div class="line">public class Token &#123;</div><div class="line"></div><div class="line">    // 接口访问凭证</div><div class="line">    private String accessToken;</div><div class="line"></div><div class="line">    // 凭证有效期，单位：秒</div><div class="line">    private int expiresIn;</div><div class="line"></div><div class="line">    public String getAccessToken() &#123;</div><div class="line">        return accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAccessToken(String accessToken) &#123;</div><div class="line">        this.accessToken = accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getExpiresIn() &#123;</div><div class="line">        return expiresIn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setExpiresIn(int expiresIn) &#123;</div><div class="line">        this.expiresIn = expiresIn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="创建信任管理器"><a href="#创建信任管理器" class="headerlink" title="创建信任管理器"></a>创建信任管理器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.utils;</div><div class="line"></div><div class="line">import java.security.cert.CertificateException;</div><div class="line">import java.security.cert.X509Certificate;</div><div class="line"></div><div class="line">import javax.net.ssl.X509TrustManager;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 证书信任管理器（用于https请求）</div><div class="line"> * 这个证书管理器的作用就是让它信任我们指定的证书，下面的代码意味着信任所有证书，不管是否权威机构颁发。</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:22:19</div><div class="line"> */</div><div class="line">public class MyX509TrustManager implements X509TrustManager &#123;</div><div class="line"></div><div class="line">    // 检查客户端证书</div><div class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 检查服务器端证书</div><div class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回受信任的X509证书数组</div><div class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="封装了一个公共类："><a href="#封装了一个公共类：" class="headerlink" title="封装了一个公共类："></a>封装了一个公共类：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.utils;</div><div class="line"></div><div class="line">import java.io.BufferedReader;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line">import java.net.ConnectException;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">import javax.net.ssl.HttpsURLConnection;</div><div class="line">import javax.net.ssl.SSLContext;</div><div class="line">import javax.net.ssl.SSLSocketFactory;</div><div class="line">import javax.net.ssl.TrustManager;</div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import com.wyj.wechart.pojo.Token;</div><div class="line">import com.wyj.wechart.pojo.WeixinUserInfo;</div><div class="line"></div><div class="line">import net.sf.json.JSONException;</div><div class="line">import net.sf.json.JSONObject;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通用工具类</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:36:50</div><div class="line"> */</div><div class="line">public class CommonUtil &#123;</div><div class="line">    private static Logger log = LoggerFactory.getLogger(CommonUtil.class);</div><div class="line"></div><div class="line">    // 凭证获取（GET）</div><div class="line">    public final static String token_url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET&quot;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 发送https请求</div><div class="line">     * </div><div class="line">     * @param requestUrl</div><div class="line">     *            请求地址</div><div class="line">     * @param requestMethod</div><div class="line">     *            请求方式（GET、POST）</div><div class="line">     * @param outputStr</div><div class="line">     *            提交的数据</div><div class="line">     * @return JSONObject(通过JSONObject.get(key)的方式获取json对象的属性值)</div><div class="line">     */</div><div class="line">    public static JSONObject httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123;</div><div class="line">        JSONObject jsonObject = null;</div><div class="line">        try &#123;</div><div class="line">            // 创建SSLContext对象，并使用我们指定的信任管理器初始化</div><div class="line">            TrustManager[] tm = &#123; new MyX509TrustManager() &#125;;</div><div class="line">            SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</div><div class="line">            sslContext.init(null, tm, new java.security.SecureRandom());</div><div class="line">            // 从上述SSLContext对象中得到SSLSocketFactory对象</div><div class="line">            SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class="line"></div><div class="line">            URL url = new URL(requestUrl);</div><div class="line">            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();</div><div class="line">            conn.setSSLSocketFactory(ssf);</div><div class="line"></div><div class="line">            conn.setDoOutput(true);</div><div class="line">            conn.setDoInput(true);</div><div class="line">            conn.setUseCaches(false);</div><div class="line">            // 设置请求方式（GET/POST）</div><div class="line">            conn.setRequestMethod(requestMethod);</div><div class="line"></div><div class="line">            // 当outputStr不为null时向输出流写数据</div><div class="line">            if (null != outputStr) &#123;</div><div class="line">                OutputStream outputStream = conn.getOutputStream();</div><div class="line">                // 注意编码格式</div><div class="line">                outputStream.write(outputStr.getBytes(&quot;UTF-8&quot;));</div><div class="line">                outputStream.close();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 从输入流读取返回内容</div><div class="line">            InputStream inputStream = conn.getInputStream();</div><div class="line">            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, &quot;utf-8&quot;);</div><div class="line">            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);</div><div class="line">            String str = null;</div><div class="line">            StringBuffer buffer = new StringBuffer();</div><div class="line">            while ((str = bufferedReader.readLine()) != null) &#123;</div><div class="line">                buffer.append(str);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 释放资源</div><div class="line">            bufferedReader.close();</div><div class="line">            inputStreamReader.close();</div><div class="line">            inputStream.close();</div><div class="line">            inputStream = null;</div><div class="line">            conn.disconnect();</div><div class="line">            jsonObject = JSONObject.fromObject(buffer.toString());</div><div class="line">        &#125; catch (ConnectException ce) &#123;</div><div class="line">            log.error(&quot;连接超时：&#123;&#125;&quot;, ce);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;https请求异常：&#123;&#125;&quot;, e);</div><div class="line">        &#125;</div><div class="line">        return jsonObject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取接口访问凭证</div><div class="line">     * </div><div class="line">     * @param appid</div><div class="line">     *            凭证</div><div class="line">     * @param appsecret</div><div class="line">     *            密钥</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static Token getToken(String appid, String appsecret) &#123;</div><div class="line">        Token token = null;</div><div class="line">        String requestUrl = token_url.replace(&quot;APPID&quot;, appid).replace(&quot;APPSECRET&quot;, appsecret);</div><div class="line">        // 发起GET请求获取凭证</div><div class="line">        JSONObject jsonObject = httpsRequest(requestUrl, &quot;GET&quot;, null);</div><div class="line"></div><div class="line">        if (null != jsonObject) &#123;</div><div class="line">            try &#123;</div><div class="line">                token = new Token();</div><div class="line">                token.setAccessToken(jsonObject.getString(&quot;access_token&quot;));</div><div class="line">                token.setExpiresIn(jsonObject.getInt(&quot;expires_in&quot;));</div><div class="line">            &#125; catch (JSONException e) &#123;</div><div class="line">                token = null;</div><div class="line">                // 获取token失败</div><div class="line">                log.error(&quot;获取token失败 errcode:&#123;&#125; errmsg:&#123;&#125;&quot;, jsonObject.getInt(&quot;errcode&quot;), jsonObject.getString(&quot;errmsg&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return token;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * URL编码（utf-8）</div><div class="line">     * </div><div class="line">     * @param source</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String urlEncodeUTF8(String source) &#123;</div><div class="line">        String result = source;</div><div class="line">        try &#123;</div><div class="line">            result = java.net.URLEncoder.encode(source, &quot;utf-8&quot;);</div><div class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 根据内容类型判断文件扩展名</div><div class="line">     * </div><div class="line">     * @param contentType</div><div class="line">     *            内容类型</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static String getFileExt(String contentType) &#123;</div><div class="line">        String fileExt = &quot;&quot;;</div><div class="line">        if (&quot;image/jpeg&quot;.equals(contentType))</div><div class="line">            fileExt = &quot;.jpg&quot;;</div><div class="line">        else if (&quot;audio/mpeg&quot;.equals(contentType))</div><div class="line">            fileExt = &quot;.mp3&quot;;</div><div class="line">        else if (&quot;audio/amr&quot;.equals(contentType))</div><div class="line">            fileExt = &quot;.amr&quot;;</div><div class="line">        else if (&quot;video/mp4&quot;.equals(contentType))</div><div class="line">            fileExt = &quot;.mp4&quot;;</div><div class="line">        else if (&quot;video/mpeg4&quot;.equals(contentType))</div><div class="line">            fileExt = &quot;.mp4&quot;;</div><div class="line">        return fileExt;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 获取用户信息</div><div class="line">     * </div><div class="line">     * @param accessToken 接口访问凭证</div><div class="line">     * @param openId 用户标识</div><div class="line">     * @return WeixinUserInfo</div><div class="line">     */</div><div class="line">    public static WeixinUserInfo getUserInfo(String accessToken, String openId) &#123;</div><div class="line">        WeixinUserInfo weixinUserInfo = null;</div><div class="line">        // 拼接请求地址</div><div class="line">        String requestUrl = &quot;https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&quot;;</div><div class="line">        requestUrl = requestUrl.replace(&quot;ACCESS_TOKEN&quot;, accessToken).replace(&quot;OPENID&quot;, openId);</div><div class="line">        // 获取用户信息</div><div class="line">        JSONObject jsonObject = CommonUtil.httpsRequest(requestUrl, &quot;GET&quot;, null);</div><div class="line"></div><div class="line">        if (null != jsonObject) &#123;</div><div class="line">            try &#123;</div><div class="line">                weixinUserInfo = new WeixinUserInfo();</div><div class="line">                // 用户的标识</div><div class="line">                weixinUserInfo.setOpenId(jsonObject.getString(&quot;openid&quot;));</div><div class="line">                // 关注状态（1是关注，0是未关注），未关注时获取不到其余信息</div><div class="line">                weixinUserInfo.setSubscribe(jsonObject.getInt(&quot;subscribe&quot;));</div><div class="line">                // 用户关注时间</div><div class="line">                weixinUserInfo.setSubscribeTime(jsonObject.getString(&quot;subscribe_time&quot;));</div><div class="line">                // 昵称</div><div class="line">                weixinUserInfo.setNickname(jsonObject.getString(&quot;nickname&quot;));</div><div class="line">                // 用户的性别（1是男性，2是女性，0是未知）</div><div class="line">                weixinUserInfo.setSex(jsonObject.getInt(&quot;sex&quot;));</div><div class="line">                // 用户所在国家</div><div class="line">                weixinUserInfo.setCountry(jsonObject.getString(&quot;country&quot;));</div><div class="line">                // 用户所在省份</div><div class="line">                weixinUserInfo.setProvince(jsonObject.getString(&quot;province&quot;));</div><div class="line">                // 用户所在城市</div><div class="line">                weixinUserInfo.setCity(jsonObject.getString(&quot;city&quot;));</div><div class="line">                // 用户的语言，简体中文为zh_CN</div><div class="line">                weixinUserInfo.setLanguage(jsonObject.getString(&quot;language&quot;));</div><div class="line">                // 用户头像</div><div class="line">                weixinUserInfo.setHeadImgUrl(jsonObject.getString(&quot;headimgurl&quot;));</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                if (0 == weixinUserInfo.getSubscribe()) &#123;</div><div class="line">                    log.error(&quot;用户&#123;&#125;已取消关注&quot;, weixinUserInfo.getOpenId());</div><div class="line">                &#125; else &#123;</div><div class="line">                    int errorCode = jsonObject.getInt(&quot;errcode&quot;);</div><div class="line">                    String errorMsg = jsonObject.getString(&quot;errmsg&quot;);</div><div class="line">                    log.error(&quot;获取用户信息失败 errcode:&#123;&#125; errmsg:&#123;&#125;&quot;, errorCode, errorMsg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return weixinUserInfo;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h2><p>替换为自己的appid和秘钥。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.test;</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import com.wyj.wechart.pojo.WeixinUserInfo;</div><div class="line">import com.wyj.wechart.utils.CommonUtil;</div><div class="line"></div><div class="line">public class WeixinUserInfoTest &#123;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testWeixinUserInfo() &#123;</div><div class="line"></div><div class="line">        // 获取接口访问凭证(替换为自己的appid和秘钥。)</div><div class="line">        String accessToken = CommonUtil.getToken(&quot;xxxx&quot;, &quot;xxxx&quot;).getAccessToken();</div><div class="line">        /**</div><div class="line">         * 获取用户信息</div><div class="line">         */</div><div class="line">        WeixinUserInfo user = CommonUtil.getUserInfo(accessToken, &quot;OpenID&quot;);</div><div class="line">        System.out.println(&quot;OpenID：&quot; + user.getOpenId());</div><div class="line">        System.out.println(&quot;关注状态：&quot; + user.getSubscribe());</div><div class="line">        System.out.println(&quot;关注时间：&quot; + user.getSubscribeTime());</div><div class="line">        System.out.println(&quot;昵称：&quot; + user.getNickname());</div><div class="line">        System.out.println(&quot;性别：&quot; + user.getSex());</div><div class="line">        System.out.println(&quot;国家：&quot; + user.getCountry());</div><div class="line">        System.out.println(&quot;省份：&quot; + user.getProvince());</div><div class="line">        System.out.println(&quot;城市：&quot; + user.getCity());</div><div class="line">        System.out.println(&quot;语言：&quot; + user.getLanguage());</div><div class="line">        System.out.println(&quot;头像：&quot; + user.getHeadImgUrl());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果如下： </p>
<p><img src="/2018/01/27/微信公共号开发教程java版——获取用户基本信息-UnionID机制-七/userInfo.png" alt="userInfo"></p>
<p><font color="red">注：github项目地址：</font><a href="https://github.com/wangyuanjun008/wyj-wechat-demo" target="_blank" rel="external">微信公共号开发用例</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：UnionID机制说明&quot;&gt;&lt;a href=&quot;#一：UnionID机制说明&quot; class=&quot;headerlink&quot; title=&quot;一：UnionID机制说明&quot;&gt;&lt;/a&gt;一：UnionID机制说明&lt;/h1&gt;&lt;p&gt;官网详细介绍:&lt;a href=&quot;https://mp
    
    </summary>
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>微信公共号开发教程java版——实现自定义菜单(六)</title>
    <link href="http://wangyuanjun.cn/2018/01/26/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8Bjava%E7%89%88%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95-%E5%85%AD/"/>
    <id>http://wangyuanjun.cn/2018/01/26/微信公共号开发教程java版——实现自定义菜单-六/</id>
    <published>2018-01-26T09:22:56.000Z</published>
    <updated>2018-01-27T14:33:56.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：自定义菜单文档说明"><a href="#一：自定义菜单文档说明" class="headerlink" title="一：自定义菜单文档说明"></a>一：自定义菜单文档说明</h1><p>自定义菜单能够帮助公众号丰富界面，让用户更好更快地理解公众号的功能。开启自定义菜单后，公众号界面如图所示：<br>官网详细介绍:<a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141013" target="_blank" rel="external">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141013</a><br><strong>请注意：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。</div><div class="line">2、一级菜单最多4个汉字，二级菜单最多7个汉字，多出来的部分将会以“...”代替。</div><div class="line">3、创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果。</div></pre></td></tr></table></figure>
<p><strong>自定义菜单接口可实现多种类型按钮，如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1、click：点击推事件用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互；</div><div class="line">2、view：跳转URL用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。</div><div class="line">3、scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。</div><div class="line">4、scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。</div><div class="line">5、pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。</div><div class="line">6、pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。</div><div class="line">7、pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。</div><div class="line">8、location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。</div><div class="line">9、media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</div><div class="line">10、view_limited：跳转图文消息URL用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。</div></pre></td></tr></table></figure>
<p><strong>请注意，3到8的所有事件，仅支持微信iPhone5.4.1以上版本，和Android5.4以上版本的微信用户，旧版本微信用户点击后将没有回应，开发者也不能正常接收到事件推送。9和10，是专门给第三方平台旗下未微信认证（具体而言，是资质认证未通过）的订阅号准备的事件类型，它们是没有事件推送的，能力相对受限，其他类型的公众号不必使用。</strong></p>
<h2 id="接口调用请求说明"><a href="#接口调用请求说明" class="headerlink" title="接口调用请求说明"></a>接口调用请求说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http请求方式：POST（请使用https协议） https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN</div></pre></td></tr></table></figure>
<h2 id="click和view的请求示例"><a href="#click和view的请求示例" class="headerlink" title="click和view的请求示例"></a>click和view的请求示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;button&quot;:[</div><div class="line">    &#123;    </div><div class="line">         &quot;type&quot;:&quot;click&quot;,</div><div class="line">         &quot;name&quot;:&quot;今日歌曲&quot;,</div><div class="line">         &quot;key&quot;:&quot;V1001_TODAY_MUSIC&quot;</div><div class="line">     &#125;,</div><div class="line">     &#123;</div><div class="line">          &quot;name&quot;:&quot;菜单&quot;,</div><div class="line">          &quot;sub_button&quot;:[</div><div class="line">          &#123;    </div><div class="line">              &quot;type&quot;:&quot;view&quot;,</div><div class="line">              &quot;name&quot;:&quot;搜索&quot;,</div><div class="line">              &quot;url&quot;:&quot;http://www.soso.com/&quot;</div><div class="line">           &#125;,</div><div class="line">           &#123;</div><div class="line">                &quot;type&quot;:&quot;miniprogram&quot;,</div><div class="line">                &quot;name&quot;:&quot;wxa&quot;,</div><div class="line">                &quot;url&quot;:&quot;http://mp.weixin.qq.com&quot;,</div><div class="line">                &quot;appid&quot;:&quot;wx286b93c14bbf93aa&quot;,</div><div class="line">                &quot;pagepath&quot;:&quot;pages/lunar/index&quot;</div><div class="line">            &#125;,</div><div class="line">           &#123;</div><div class="line">              &quot;type&quot;:&quot;click&quot;,</div><div class="line">              &quot;name&quot;:&quot;赞一下我们&quot;,</div><div class="line">              &quot;key&quot;:&quot;V1001_GOOD&quot;</div><div class="line">           &#125;]</div><div class="line">      &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;button&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;扫码&quot;, </div><div class="line">            &quot;sub_button&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;type&quot;: &quot;scancode_waitmsg&quot;, </div><div class="line">                    &quot;name&quot;: &quot;扫码带提示&quot;, </div><div class="line">                    &quot;key&quot;: &quot;rselfmenu_0_0&quot;, </div><div class="line">                    &quot;sub_button&quot;: [ ]</div><div class="line">                &#125;, </div><div class="line">                &#123;</div><div class="line">                    &quot;type&quot;: &quot;scancode_push&quot;, </div><div class="line">                    &quot;name&quot;: &quot;扫码推事件&quot;, </div><div class="line">                    &quot;key&quot;: &quot;rselfmenu_0_1&quot;, </div><div class="line">                    &quot;sub_button&quot;: [ ]</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;发图&quot;, </div><div class="line">            &quot;sub_button&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;type&quot;: &quot;pic_sysphoto&quot;, </div><div class="line">                    &quot;name&quot;: &quot;系统拍照发图&quot;, </div><div class="line">                    &quot;key&quot;: &quot;rselfmenu_1_0&quot;, </div><div class="line">                   &quot;sub_button&quot;: [ ]</div><div class="line">                 &#125;, </div><div class="line">                &#123;</div><div class="line">                    &quot;type&quot;: &quot;pic_photo_or_album&quot;, </div><div class="line">                    &quot;name&quot;: &quot;拍照或者相册发图&quot;, </div><div class="line">                    &quot;key&quot;: &quot;rselfmenu_1_1&quot;, </div><div class="line">                    &quot;sub_button&quot;: [ ]</div><div class="line">                &#125;, </div><div class="line">                &#123;</div><div class="line">                    &quot;type&quot;: &quot;pic_weixin&quot;, </div><div class="line">                    &quot;name&quot;: &quot;微信相册发图&quot;, </div><div class="line">                    &quot;key&quot;: &quot;rselfmenu_1_2&quot;, </div><div class="line">                    &quot;sub_button&quot;: [ ]</div><div class="line">                &#125;</div><div class="line">            ]</div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            &quot;name&quot;: &quot;发送位置&quot;, </div><div class="line">            &quot;type&quot;: &quot;location_select&quot;, </div><div class="line">            &quot;key&quot;: &quot;rselfmenu_2_0&quot;</div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">           &quot;type&quot;: &quot;media_id&quot;, </div><div class="line">           &quot;name&quot;: &quot;图片&quot;, </div><div class="line">           &quot;media_id&quot;: &quot;MEDIA_ID1&quot;</div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">           &quot;type&quot;: &quot;view_limited&quot;, </div><div class="line">           &quot;name&quot;: &quot;图文消息&quot;, </div><div class="line">           &quot;media_id&quot;: &quot;MEDIA_ID2&quot;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:right">是否必须</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>button</td>
<td style="text-align:right">是</td>
<td style="text-align:center">一级菜单数组，个数应为1~3个</td>
</tr>
<tr>
<td>sub_button</td>
<td style="text-align:right">否</td>
<td style="text-align:center">二级菜单数组，个数应为1~5个</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:right">是</td>
<td style="text-align:center">菜单的响应动作类型，view表示网页类型，click表示点击类型，miniprogram表示小程序类型</td>
</tr>
<tr>
<td>name</td>
<td style="text-align:right">是</td>
<td style="text-align:center">菜单标题，不超过16个字节，子菜单不超过60个字节</td>
</tr>
<tr>
<td>key</td>
<td style="text-align:right">click等点击类型必须</td>
<td style="text-align:center">菜单KEY值，用于消息接口推送，不超过128字节</td>
</tr>
<tr>
<td>url</td>
<td style="text-align:right">view、miniprogram类型必须</td>
<td style="text-align:center">网页 链接，用户点击菜单可打开链接，不超过1024字节。 type为miniprogram时，不支持小程序的老版本客户端将打开本url</td>
</tr>
<tr>
<td>media_id</td>
<td style="text-align:right">media_id类型和view_limited类型必须</td>
<td style="text-align:center">调用新增永久素材接口返回的合法media_id</td>
</tr>
<tr>
<td>appid</td>
<td style="text-align:right">miniprogram类型必须</td>
<td style="text-align:center">小程序的appid（仅认证公众号可配置）</td>
</tr>
<tr>
<td>pagepath</td>
<td style="text-align:right">miniprogram类型必须</td>
<td style="text-align:center">小程序的页面路径</td>
</tr>
</tbody>
</table>
<p>返回结果</p>
<p>正确时的返回JSON数据包如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;&#125;</div></pre></td></tr></table></figure>
<p>错误时的返回JSON数据包如下（示例为无效菜单名长度）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;errcode&quot;:40018,&quot;errmsg&quot;:&quot;invalid button name size&quot;&#125;</div></pre></td></tr></table></figure>
<p>使用网页调试工具调试该接口：<a href="https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81&amp;form=%E8%8E%B7%E5%8F%96access_token%E6%8E%A5%E5%8F%A3%20/token" target="_blank" rel="external">网页调试工具</a></p>
<h1 id="二：菜单的封装"><a href="#二：菜单的封装" class="headerlink" title="二：菜单的封装"></a>二：菜单的封装</h1><p>接下来是对菜单结构的封装。<font color="red">因为我们是采用面向对象的编程方式，最终提交的json格式菜单数据就应该是由对象直接转换得到，而不是在程序代码中拼一大堆json数据。菜单结构封装的依据是公众平台API文档中给出的那一段json格式的菜单结构，如下所示：</font></p>
<h2 id="1-菜单项的基类"><a href="#1-菜单项的基类" class="headerlink" title="1.菜单项的基类"></a>1.菜单项的基类</h2><p>首先是 菜单项的基类，所有一级菜单、二级菜单都共有一个相同的属性，那就是name。菜单项基类的封装代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.menu;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 菜单项的基类</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:52:28</div><div class="line"> */</div><div class="line">public class Button &#123;</div><div class="line"></div><div class="line">    private String name;// 所有一级菜单、二级菜单都共有一个相同的属性，那就是name</div><div class="line"></div><div class="line">    public String getName() &#123;</div><div class="line">        return name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setName(String name) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-子菜单项的封装"><a href="#2-子菜单项的封装" class="headerlink" title="2.子菜单项的封装"></a>2.子菜单项的封装</h2><p>接着是子菜单项的封装。这里对子菜单是这样定义的：没有子菜单的菜单项，有可能是二级菜单项，也有可能是不含二级菜单的一级菜单。这类子菜单项一定会包含三个属性：type、name和key，封装的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.menu;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 子菜单项 :没有子菜单的菜单项，有可能是二级菜单项，也有可能是不含二级菜单的一级菜单。</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:54:53</div><div class="line"> */</div><div class="line">public class CommonButton extends Button &#123;</div><div class="line"></div><div class="line">    // 菜单的响应动作类型，view表示网页类型，click表示点击类型，miniprogram表示小程序类型</div><div class="line">    private String type;</div><div class="line"></div><div class="line">    // 菜单KEY值，用于消息接口推送，不超过128字节</div><div class="line">    private String key;</div><div class="line"></div><div class="line">    private String url;</div><div class="line"></div><div class="line">    public String getType() &#123;</div><div class="line">        return type;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setType(String type) &#123;</div><div class="line">        this.type = type;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getKey() &#123;</div><div class="line">        return key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setKey(String key) &#123;</div><div class="line">        this.key = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getUrl() &#123;</div><div class="line">        return url;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setUrl(String url) &#123;</div><div class="line">        this.url = url;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-父菜单项的封装"><a href="#3-父菜单项的封装" class="headerlink" title="3.父菜单项的封装"></a>3.父菜单项的封装</h2><p> 再往下是父菜单项的封装。对父菜单项的定义：包含有二级菜单项的一级菜单。这类菜单项包含有二个属性：name和sub_button，而sub_button以是一个子菜单项数组。父菜单项的封装代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.menu;</div><div class="line">/**</div><div class="line"> * 父菜单项 :包含有二级菜单项的一级菜单。这类菜单项包含有二个属性：name和sub_button，而sub_button以是一个子菜单项数组</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:59:04</div><div class="line"> */</div><div class="line">public class ComplexButton extends Button &#123;</div><div class="line">    </div><div class="line">    private Button[] sub_button;</div><div class="line"></div><div class="line">    public Button[] getSub_button() &#123;</div><div class="line">        return sub_button;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setSub_button(Button[] sub_button) &#123;</div><div class="line">        this.sub_button = sub_button;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-菜单对象的封装"><a href="#4-菜单对象的封装" class="headerlink" title="4.菜单对象的封装"></a>4.菜单对象的封装</h2><p>最后是整个菜单对象的封装，菜单对象包含多个菜单项（最多只能有3个），这些菜单项即可以是子菜单项（不含二级菜单的一级菜单），也可以是父菜单项（包含二级菜单的菜单项），如果能明白上面所讲的，再来看封装后的代码就很容易理解了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.menu;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 整个菜单对象的封装</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:59:46</div><div class="line"> */</div><div class="line">public class Menu &#123;</div><div class="line"></div><div class="line">    private Button[] button;</div><div class="line"></div><div class="line">    public Button[] getButton() &#123;</div><div class="line">        return button;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setButton(Button[] button) &#123;</div><div class="line">        this.button = button;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于菜单的POJO类的封装就介绍完了。</p>
<h2 id="5-接口凭证的封装"><a href="#5-接口凭证的封装" class="headerlink" title="5.接口凭证的封装"></a>5.接口凭证的封装</h2><p>AccessToken 的POJO的封装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.pojo;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 微信通用接口凭证</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午4:01:12</div><div class="line"> */</div><div class="line">public class AccessToken &#123;</div><div class="line"></div><div class="line">    // 获取到的凭证</div><div class="line">    private String token;</div><div class="line"></div><div class="line">    // 凭证有效时间，单位：秒</div><div class="line">    private int expiresIn;</div><div class="line"></div><div class="line">    public String getToken() &#123;</div><div class="line">        return token;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setToken(String token) &#123;</div><div class="line">        this.token = token;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getExpiresIn() &#123;</div><div class="line">        return expiresIn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setExpiresIn(int expiresIn) &#123;</div><div class="line">        this.expiresIn = expiresIn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>封装通用的请求方法</p>
<p>读到这里，就默认大家已经掌握了上面讲到的所有关于自定义菜单的理论知识，下面就进入代码实战讲解的部分。</p>
<p>先前我们了解到，创建菜单需要调用二个接口，并且都是https请求，而非http。如果要封装一个通用的请求方法，该方法至少需要具备以下能力：</p>
<p>1）支持HTTPS请求；</p>
<p>2）支持GET、POST两种方式；</p>
<p>3）支持参数提交，也支持无参数的情况；</p>
<h2 id="6-创建证书信任管理器"><a href="#6-创建证书信任管理器" class="headerlink" title="6.创建证书信任管理器"></a>6.创建证书信任管理器</h2><p>对于https请求，我们需要一个证书信任管理器，这个管理器类需要自己定义，但需要实现X509TrustManager接口，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.utils;</div><div class="line"></div><div class="line">import java.security.cert.CertificateException;</div><div class="line">import java.security.cert.X509Certificate;</div><div class="line"></div><div class="line">import javax.net.ssl.X509TrustManager;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 证书信任管理器（用于https请求）</div><div class="line"> * 这个证书管理器的作用就是让它信任我们指定的证书，下面的代码意味着信任所有证书，不管是否权威机构颁发。</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:22:19</div><div class="line"> */</div><div class="line">public class MyX509TrustManager implements X509TrustManager &#123;</div><div class="line"></div><div class="line">    // 检查客户端证书</div><div class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 检查服务器端证书</div><div class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回受信任的X509证书数组</div><div class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个证书管理器的作用就是让它信任我们指定的证书，上面的代码意味着信任所有证书，不管是否权威机构颁发。</p>
<h2 id="7-https请求方法实现"><a href="#7-https请求方法实现" class="headerlink" title="7.https请求方法实现"></a>7.https请求方法实现</h2><p>证书有了，通用的https请求方法就不难实现了，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.utils;</div><div class="line"></div><div class="line">import java.io.BufferedReader;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.net.ConnectException;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">import javax.net.ssl.HttpsURLConnection;</div><div class="line">import javax.net.ssl.SSLContext;</div><div class="line">import javax.net.ssl.SSLSocketFactory;</div><div class="line">import javax.net.ssl.TrustManager;</div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import com.wyj.wechart.menu.Menu;</div><div class="line">import com.wyj.wechart.pojo.AccessToken;</div><div class="line"></div><div class="line">import net.sf.json.JSONException;</div><div class="line">import net.sf.json.JSONObject;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 公众平台通用接口工具类</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午4:06:13</div><div class="line"> */</div><div class="line">public class WeixinUtil &#123;</div><div class="line"></div><div class="line">    private static Logger log = LoggerFactory.getLogger(WeixinUtil.class);</div><div class="line"></div><div class="line">    // 获取access_token的接口地址（GET） 限200（次/天）</div><div class="line">    public final static String access_token_url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET&quot;;</div><div class="line"></div><div class="line">    // 菜单创建（POST） 限100（次/天）</div><div class="line">    public static String menu_create_url = &quot;https://api.weixin.qq.com/cgi-bin/menu/create?access_token=ACCESS_TOKEN&quot;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 创建菜单</div><div class="line">     * </div><div class="line">     * @param menu</div><div class="line">     *            菜单实例</div><div class="line">     * @param accessToken</div><div class="line">     *            有效的access_token</div><div class="line">     * @return 0表示成功，其他值表示失败</div><div class="line">     */</div><div class="line">    public static int createMenu(Menu menu, String accessToken) &#123;</div><div class="line">        int result = 0;</div><div class="line">        // 拼装创建菜单的url</div><div class="line">        String url = menu_create_url.replace(&quot;ACCESS_TOKEN&quot;, accessToken);</div><div class="line">        // 将菜单对象转换成json字符串</div><div class="line">        String jsonMenu = JSONObject.fromObject(menu).toString();</div><div class="line">        // 调用接口创建菜单</div><div class="line">        JSONObject jsonObject = httpRequest(url, &quot;POST&quot;, jsonMenu);</div><div class="line">        if (null != jsonObject) &#123;</div><div class="line">            if (0 != jsonObject.getInt(&quot;errcode&quot;)) &#123;</div><div class="line">                result = jsonObject.getInt(&quot;errcode&quot;);</div><div class="line">                log.error(&quot;创建菜单失败 errcode:&#123;&#125; errmsg:&#123;&#125;&quot;, jsonObject.getInt(&quot;errcode&quot;), jsonObject.getString(&quot;errmsg&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取access_token</div><div class="line">     * </div><div class="line">     * @param appid</div><div class="line">     *            凭证</div><div class="line">     * @param appsecret</div><div class="line">     *            密钥</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static AccessToken getAccessToken(String appid, String appsecret) &#123;</div><div class="line">        AccessToken accessToken = null;</div><div class="line"></div><div class="line">        String requestUrl = access_token_url.replace(&quot;APPID&quot;, appid).replace(&quot;APPSECRET&quot;, appsecret);</div><div class="line">        JSONObject jsonObject = httpRequest(requestUrl, &quot;GET&quot;, null);</div><div class="line">        // 如果请求成功</div><div class="line">        if (null != jsonObject) &#123;</div><div class="line">            try &#123;</div><div class="line">                accessToken = new AccessToken();</div><div class="line">                accessToken.setToken(jsonObject.getString(&quot;access_token&quot;));</div><div class="line">                accessToken.setExpiresIn(jsonObject.getInt(&quot;expires_in&quot;));</div><div class="line">            &#125; catch (JSONException e) &#123;</div><div class="line">                accessToken = null;</div><div class="line">                // 获取token失败</div><div class="line">                log.error(&quot;获取token失败 errcode:&#123;&#125; errmsg:&#123;&#125;&quot;, jsonObject.getInt(&quot;errcode&quot;), jsonObject.getString(&quot;errmsg&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 描述: 发起https请求并获取结果</div><div class="line">     * </div><div class="line">     * @param requestUrl</div><div class="line">     *            请求地址</div><div class="line">     * @param requestMethod</div><div class="line">     *            请求方式（GET、POST）</div><div class="line">     * @param outputStr</div><div class="line">     *            提交的数据</div><div class="line">     * @return JSONObject(通过JSONObject.get(key)的方式获取json对象的属性值)</div><div class="line">     */</div><div class="line">    public static JSONObject httpRequest(String requestUrl, String requestMethod, String outputStr) &#123;</div><div class="line">        JSONObject jsonObject = null;</div><div class="line">        StringBuffer buffer = new StringBuffer();</div><div class="line">        try &#123;</div><div class="line">            // 创建SSLContext对象，并使用我们指定的信任管理器初始化</div><div class="line">            TrustManager[] tm = &#123; new MyX509TrustManager() &#125;;</div><div class="line">            SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</div><div class="line">            sslContext.init(null, tm, new java.security.SecureRandom());</div><div class="line">            // 从上述SSLContext对象中得到SSLSocketFactory对象</div><div class="line">            SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class="line"></div><div class="line">            URL url = new URL(requestUrl);</div><div class="line">            HttpsURLConnection httpUrlConn = (HttpsURLConnection) url.openConnection();</div><div class="line">            httpUrlConn.setSSLSocketFactory(ssf);</div><div class="line"></div><div class="line">            httpUrlConn.setDoOutput(true);</div><div class="line">            httpUrlConn.setDoInput(true);</div><div class="line">            httpUrlConn.setUseCaches(false);</div><div class="line"></div><div class="line">            // 设置请求方式（GET/POST）</div><div class="line">            httpUrlConn.setRequestMethod(requestMethod);</div><div class="line"></div><div class="line">            if (&quot;GET&quot;.equalsIgnoreCase(requestMethod))</div><div class="line">                httpUrlConn.connect();</div><div class="line"></div><div class="line">            // 当有数据需要提交时</div><div class="line">            if (null != outputStr) &#123;</div><div class="line">                OutputStream outputStream = httpUrlConn.getOutputStream();</div><div class="line">                // 注意编码格式，防止中文乱码</div><div class="line">                outputStream.write(outputStr.getBytes(&quot;UTF-8&quot;));</div><div class="line">                outputStream.close();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 将返回的输入流转换成字符串</div><div class="line">            InputStream inputStream = httpUrlConn.getInputStream();</div><div class="line">            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, &quot;utf-8&quot;);</div><div class="line">            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);</div><div class="line"></div><div class="line">            String str = null;</div><div class="line">            while ((str = bufferedReader.readLine()) != null) &#123;</div><div class="line">                buffer.append(str);</div><div class="line">            &#125;</div><div class="line">            bufferedReader.close();</div><div class="line">            inputStreamReader.close();</div><div class="line">            // 释放资源</div><div class="line">            inputStream.close();</div><div class="line">            inputStream = null;</div><div class="line">            httpUrlConn.disconnect();</div><div class="line">            jsonObject = JSONObject.fromObject(buffer.toString());</div><div class="line">        &#125; catch (ConnectException ce) &#123;</div><div class="line">            log.error(&quot;Weixin server connection timed out.&quot;);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;https request error:&#123;&#125;&quot;, e);</div><div class="line">        &#125;</div><div class="line">        return jsonObject;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="8-添加菜单管理器："><a href="#8-添加菜单管理器：" class="headerlink" title="8.添加菜单管理器："></a>8.添加菜单管理器：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.main;</div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import com.wyj.wechart.menu.Button;</div><div class="line">import com.wyj.wechart.menu.CommonButton;</div><div class="line">import com.wyj.wechart.menu.ComplexButton;</div><div class="line">import com.wyj.wechart.menu.Menu;</div><div class="line">import com.wyj.wechart.pojo.AccessToken;</div><div class="line">import com.wyj.wechart.utils.WeixinUtil;</div><div class="line">/**</div><div class="line"> * 菜单管理器类</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午4:12:08</div><div class="line"> */</div><div class="line">public class MenuManager &#123;</div><div class="line">    private static Logger log = LoggerFactory.getLogger(MenuManager.class);</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // 第三方用户唯一凭证</div><div class="line">        String appId = &quot;wx17fdedc3d6d0b68e&quot;;</div><div class="line">        // 第三方用户唯一凭证密钥</div><div class="line">        String appSecret = &quot;c3b3d919d65a781ba7db58d9d8dfb515&quot;;</div><div class="line"></div><div class="line">        // 调用接口获取access_token</div><div class="line">        AccessToken at = WeixinUtil.getAccessToken(appId, appSecret);</div><div class="line"></div><div class="line">        if (null != at) &#123;</div><div class="line">            // 调用接口创建菜单</div><div class="line">            int result = WeixinUtil.createMenu(getMenu(), at.getToken());</div><div class="line"></div><div class="line">            // 判断菜单创建结果</div><div class="line">            if (0 == result)</div><div class="line">                log.info(&quot;菜单创建成功！&quot;);</div><div class="line">            else</div><div class="line">                log.info(&quot;菜单创建失败，错误码：&quot; + result);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 组装菜单数据</div><div class="line">     * </div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private static Menu getMenu() &#123;</div><div class="line">        CommonButton btn11 = new CommonButton();</div><div class="line">        btn11.setName(&quot;天气预报&quot;);</div><div class="line">        btn11.setType(&quot;view&quot;);</div><div class="line">        btn11.setKey(&quot;11&quot;);</div><div class="line">        btn11.setUrl(&quot;http://www.weather.com.cn/weather/101190101.shtml&quot;);</div><div class="line"></div><div class="line">        CommonButton btn12 = new CommonButton();</div><div class="line">        btn12.setName(&quot;公交查询&quot;);</div><div class="line">        btn12.setType(&quot;view&quot;);</div><div class="line">        btn12.setKey(&quot;12&quot;);</div><div class="line">        btn12.setUrl(&quot;http://www.gongjiao.com/&quot;);</div><div class="line">        </div><div class="line">        CommonButton btn13 = new CommonButton();</div><div class="line">        btn13.setName(&quot;百度地图&quot;);</div><div class="line">        btn13.setType(&quot;view&quot;);</div><div class="line">        btn13.setKey(&quot;13&quot;);</div><div class="line">        btn13.setUrl(&quot;https://map.baidu.com/&quot;);</div><div class="line">        </div><div class="line">        CommonButton btn14 = new CommonButton();</div><div class="line">        btn14.setName(&quot;滴滴出行&quot;);</div><div class="line">        btn14.setType(&quot;click&quot;);</div><div class="line">        btn14.setKey(&quot;14&quot;);</div><div class="line"></div><div class="line">        CommonButton btn21 = new CommonButton();</div><div class="line">        btn21.setName(&quot;csdn&quot;);</div><div class="line">        btn21.setType(&quot;click&quot;);</div><div class="line">        btn21.setKey(&quot;21&quot;);</div><div class="line"></div><div class="line">        CommonButton btn22 = new CommonButton();</div><div class="line">        btn22.setName(&quot;博客园&quot;);</div><div class="line">        btn22.setType(&quot;click&quot;);</div><div class="line">        btn22.setKey(&quot;22&quot;);</div><div class="line"></div><div class="line">        CommonButton btn23 = new CommonButton();</div><div class="line">        btn23.setName(&quot;开发头条&quot;);</div><div class="line">        btn23.setType(&quot;click&quot;);</div><div class="line">        btn23.setKey(&quot;23&quot;);</div><div class="line"></div><div class="line">        CommonButton btn24 = new CommonButton();</div><div class="line">        btn24.setName(&quot;云栖社区&quot;);</div><div class="line">        btn24.setType(&quot;click&quot;);</div><div class="line">        btn24.setKey(&quot;24&quot;);</div><div class="line"></div><div class="line">        CommonButton btn25 = new CommonButton();</div><div class="line">        btn25.setName(&quot;github&quot;);</div><div class="line">        btn25.setType(&quot;click&quot;);</div><div class="line">        btn25.setKey(&quot;25&quot;);</div><div class="line"></div><div class="line">        CommonButton btn31 = new CommonButton();</div><div class="line">        btn31.setName(&quot;淘宝网&quot;);</div><div class="line">        btn31.setType(&quot;click&quot;);</div><div class="line">        btn31.setKey(&quot;31&quot;);</div><div class="line"></div><div class="line">        CommonButton btn32 = new CommonButton();</div><div class="line">        btn32.setName(&quot;电影天堂&quot;);</div><div class="line">        btn32.setType(&quot;click&quot;);</div><div class="line">        btn32.setKey(&quot;32&quot;);</div><div class="line"></div><div class="line">        CommonButton btn33 = new CommonButton();</div><div class="line">        btn33.setName(&quot;小游戏&quot;);</div><div class="line">        btn33.setType(&quot;click&quot;);</div><div class="line">        btn33.setKey(&quot;33&quot;);</div><div class="line"></div><div class="line">        </div><div class="line">        /**</div><div class="line">         * 微信：  mainBtn1,mainBtn2,mainBtn3底部的三个一级菜单。</div><div class="line">         */</div><div class="line">        </div><div class="line">        ComplexButton mainBtn1 = new ComplexButton();</div><div class="line">        mainBtn1.setName(&quot;生活便利&quot;);</div><div class="line">        //一级下有4个子菜单</div><div class="line">        mainBtn1.setSub_button(new CommonButton[] &#123; btn11, btn12, btn13, btn14 &#125;);</div><div class="line">        </div><div class="line">        ComplexButton mainBtn2 = new ComplexButton();</div><div class="line">        mainBtn2.setName(&quot;学习社区&quot;);</div><div class="line">        mainBtn2.setSub_button(new CommonButton[] &#123; btn21, btn22, btn23, btn24, btn25 &#125;);</div><div class="line"></div><div class="line">        </div><div class="line">        ComplexButton mainBtn3 = new ComplexButton();</div><div class="line">        mainBtn3.setName(&quot;娱乐一下&quot;);</div><div class="line">        mainBtn3.setSub_button(new CommonButton[] &#123; btn31, btn32, btn33 &#125;);</div><div class="line"></div><div class="line">        </div><div class="line">        /**</div><div class="line">         * 封装整个菜单</div><div class="line">         */</div><div class="line">        Menu menu = new Menu();</div><div class="line">        menu.setButton(new Button[] &#123; mainBtn1, mainBtn2, mainBtn3 &#125;);</div><div class="line"></div><div class="line">        return menu;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意替换称自己的appId和appSecret。</p>
<p>直接执行MenuManager 的main 方法即可。</p>
<p>效果如下：</p>
<p><img src="/2018/01/26/微信公共号开发教程java版——实现自定义菜单-六/muens.png" alt="muens"></p>
<p><font color="red">注：github项目地址：</font><a href="https://github.com/wangyuanjun008/wyj-wechat-demo" target="_blank" rel="external">微信公共号开发用例</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：自定义菜单文档说明&quot;&gt;&lt;a href=&quot;#一：自定义菜单文档说明&quot; class=&quot;headerlink&quot; title=&quot;一：自定义菜单文档说明&quot;&gt;&lt;/a&gt;一：自定义菜单文档说明&lt;/h1&gt;&lt;p&gt;自定义菜单能够帮助公众号丰富界面，让用户更好更快地理解公众号的功能。
    
    </summary>
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>微信公共号开发教程java版——公共号access_token的获取(五)</title>
    <link href="http://wangyuanjun.cn/2018/01/26/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8Bjava%E7%89%88%E2%80%94%E2%80%94%E5%85%AC%E5%85%B1%E5%8F%B7access-token%E7%9A%84%E8%8E%B7%E5%8F%96-%E4%BA%94/"/>
    <id>http://wangyuanjun.cn/2018/01/26/微信公共号开发教程java版——公共号access-token的获取-五/</id>
    <published>2018-01-26T08:13:15.000Z</published>
    <updated>2018-01-27T14:33:44.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一：access-token简介"><a href="#一：access-token简介" class="headerlink" title="一：access_token简介"></a>一：access_token简介</h1><p>为了使第三方开发者能够为用户提供更多更有价值的个性化服务，微信公众平台 开放了许多接口，包括自定义菜单接口、客服接口、获取用户信息接口、用户分组接口、群发接口等，</p>
<p>access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p>
<p>公众平台的API调用所需的access_token的使用及生成方式说明：</p>
<p>1、建议公众号开发者使用中控服务器统一获取和刷新Access_token，其他业务逻辑服务器所使用的access_token均来自于该中控服务器，不应该各自去刷新，否则容易造成冲突，导致access_token覆盖而影响业务；</p>
<p>2、目前Access_token的有效期通过返回的expire_in来传达，目前是7200秒之内的值。中控服务器需要根据这个有效时间提前去刷新新access_token。在刷新过程中，中控服务器可对外继续输出的老access_token，此时公众平台后台会保证在5分钟内，新老access_token都可用，这保证了第三方业务的平滑过渡；</p>
<p>3、Access_token的有效时间可能会在未来有调整，所以中控服务器不仅需要内部定时主动刷新，还需要提供被动刷新access_token的接口，这样便于业务服务器在API调用获知access_token已超时的情况下，可以触发access_token的刷新流程。</p>
<p>公众号可以使用AppID和AppSecret调用本接口来获取access_token。AppID和AppSecret可在“微信公众平台-开发-基本配置”页中获得（需要已经成为开发者，且帐号没有异常状态）。<font color="red">调用接口时，请登录“微信公众平台-开发-基本配置”提前将服务器IP地址添加到IP白名单中，点击查看设置方法，否则将无法调用成功。</font></p>
<p>目前，获取access_token接口的调用频率限制为2000次/天，如果每次发送客服消息、获取用户信息、群发消息之前都要先调用获取 access_token接口得到接口访问凭证，这显然是不合理的，一方面会更耗时（多了一次接口调用操作），另一方面2000次/天的调用限制恐怕也不 够用。因此，在实际应用中，我们需要将获取到的access_token存储起来，然后定期调用access_token接口更新它，以保证随时取出的 access_token都是有效的。</p>
<p><font face="黑体" size="5">官网详细介绍：</font><a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183" target="_blank" rel="external">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140183</a></p>
<h2 id="接口调用请求说明"><a href="#接口调用请求说明" class="headerlink" title="接口调用请求说明"></a>接口调用请求说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https请求方式: GEThttps://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</div></pre></td></tr></table></figure>
<p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:right">是否必须</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>grant_type</td>
<td style="text-align:right">是</td>
<td style="text-align:center">获取access_token填写client_credential</td>
</tr>
<tr>
<td>appid</td>
<td style="text-align:right">是</td>
<td style="text-align:center">第三方用户唯一凭证</td>
</tr>
<tr>
<td>secret</td>
<td style="text-align:right">是</td>
<td style="text-align:center">第三方用户唯一凭证密钥，即appsecret</td>
</tr>
</tbody>
</table>
<h2 id="返回说明"><a href="#返回说明" class="headerlink" title="返回说明"></a>返回说明</h2><p>正常情况下，微信会返回下述JSON数据包给公众号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;access_token&quot;:&quot;ACCESS_TOKEN&quot;,&quot;expires_in&quot;:7200&#125;</div></pre></td></tr></table></figure>
<p>参数说明</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>access_token</td>
<td style="text-align:center">获取到的凭证</td>
</tr>
<tr>
<td>expires_in</td>
<td style="text-align:center">凭证有效时间，单位：秒</td>
</tr>
</tbody>
</table>
<p>错误时微信会返回错误码等信息，JSON数据包示例如下（该示例为AppID无效错误）:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;errcode&quot;:40013,&quot;errmsg&quot;:&quot;invalid appid&quot;&#125;</div></pre></td></tr></table></figure>
<h2 id="返回码说明"><a href="#返回码说明" class="headerlink" title="返回码说明"></a>返回码说明</h2><table>
<thead>
<tr>
<th>返回码</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-1</td>
<td style="text-align:center">系统繁忙，此时请开发者稍候再试</td>
</tr>
<tr>
<td>0</td>
<td style="text-align:center">请求成功</td>
</tr>
<tr>
<td>40001</td>
<td style="text-align:center">AppSecret错误或者AppSecret不属于这个公众号，请开发者确认AppSecret的正确性</td>
</tr>
<tr>
<td>40002</td>
<td style="text-align:center">请确保grant_type字段值为client_credential</td>
</tr>
<tr>
<td>40164</td>
<td style="text-align:center">调用接口的IP地址不在白名单中，请在接口IP白名单中进行设置</td>
</tr>
</tbody>
</table>
<h1 id="二：封装基本类"><a href="#二：封装基本类" class="headerlink" title="二：封装基本类"></a>二：封装基本类</h1><p>封装一下token类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.pojo;</div><div class="line"></div><div class="line">/**</div><div class="line"> * </div><div class="line"> * 凭证</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:19:14</div><div class="line"> */</div><div class="line">public class Token &#123;</div><div class="line"></div><div class="line">    // 接口访问凭证</div><div class="line">    private String accessToken;</div><div class="line"></div><div class="line">    // 凭证有效期，单位：秒</div><div class="line">    private int expiresIn;</div><div class="line"></div><div class="line">    public String getAccessToken() &#123;</div><div class="line">        return accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAccessToken(String accessToken) &#123;</div><div class="line">        this.accessToken = accessToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getExpiresIn() &#123;</div><div class="line">        return expiresIn;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setExpiresIn(int expiresIn) &#123;</div><div class="line">        this.expiresIn = expiresIn;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="三：获取token"><a href="#三：获取token" class="headerlink" title="三：获取token"></a>三：获取token</h1><ol>
<li><p>使用网页调试工具调试该接口：<a href="https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E5%9F%BA%E7%A1%80%E6%94%AF%E6%8C%81&amp;form=%E8%8E%B7%E5%8F%96access_token%E6%8E%A5%E5%8F%A3%20/token" target="_blank" rel="external">网页调试工具</a></p>
</li>
<li><p>直接通过浏览器访问：<a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET" target="_blank" rel="external">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a> ，然后把APPID和APPSECRET替换成自己的appID和appsecret，在浏览器即可获得token。</p>
</li>
<li><p>编写程序，模拟https连接，获得token：<br>对于https请求，我们需要一个证书信任管理器，这个管理器类需要自己定义，但需要实现X509TrustManager接口，　</p>
</li>
</ol>
<p>首先定义一个MyX509TrustManager 类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.utils;</div><div class="line"></div><div class="line">import java.security.cert.CertificateException;</div><div class="line">import java.security.cert.X509Certificate;</div><div class="line"></div><div class="line">import javax.net.ssl.X509TrustManager;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 证书信任管理器（用于https请求）</div><div class="line"> * 这个证书管理器的作用就是让它信任我们指定的证书，下面的代码意味着信任所有证书，不管是否权威机构颁发。</div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:22:19</div><div class="line"> */</div><div class="line">public class MyX509TrustManager implements X509TrustManager &#123;</div><div class="line"></div><div class="line">    // 检查客户端证书</div><div class="line">    public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 检查服务器端证书</div><div class="line">    public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 返回受信任的X509证书数组</div><div class="line">    public X509Certificate[] getAcceptedIssuers() &#123;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建立一个token测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.test;</div><div class="line"></div><div class="line">import java.io.BufferedReader;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">import javax.net.ssl.HttpsURLConnection;</div><div class="line">import javax.net.ssl.SSLContext;</div><div class="line">import javax.net.ssl.SSLSocketFactory;</div><div class="line">import javax.net.ssl.TrustManager;</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import com.wyj.wechart.pojo.Token;</div><div class="line">import com.wyj.wechart.utils.CommonUtil;</div><div class="line">import com.wyj.wechart.utils.MyX509TrustManager;</div><div class="line"></div><div class="line">public class TokenTest &#123;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testGetToken1() throws Exception &#123;</div><div class="line">        String tokenUrl = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=appID&amp;secret=appsecret&quot;;</div><div class="line">        // 建立连接</div><div class="line">        URL url = new URL(tokenUrl);</div><div class="line">        HttpsURLConnection httpUrlConn = (HttpsURLConnection) url.openConnection();</div><div class="line"></div><div class="line">        // 创建SSLContext对象，并使用我们指定的信任管理器初始化</div><div class="line">        TrustManager[] tm = &#123; new MyX509TrustManager() &#125;;</div><div class="line">        SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</div><div class="line">        sslContext.init(null, tm, new java.security.SecureRandom());</div><div class="line">        // 从上述SSLContext对象中得到SSLSocketFactory对象</div><div class="line">        SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class="line"></div><div class="line">        httpUrlConn.setSSLSocketFactory(ssf);</div><div class="line">        httpUrlConn.setDoOutput(true);</div><div class="line">        httpUrlConn.setDoInput(true);</div><div class="line"></div><div class="line">        // 设置请求方式（GET/POST）</div><div class="line">        httpUrlConn.setRequestMethod(&quot;GET&quot;);</div><div class="line"></div><div class="line">        // 取得输入流</div><div class="line">        InputStream inputStream = httpUrlConn.getInputStream();</div><div class="line">        InputStreamReader inputStreamReader = new InputStreamReader(</div><div class="line">                inputStream, &quot;utf-8&quot;);</div><div class="line">        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);</div><div class="line">        // 读取响应内容</div><div class="line">        StringBuffer buffer = new StringBuffer();</div><div class="line">        String str = null;</div><div class="line">        while ((str = bufferedReader.readLine()) != null) &#123;</div><div class="line">            buffer.append(str);</div><div class="line">        &#125;</div><div class="line">        bufferedReader.close();</div><div class="line">        inputStreamReader.close();</div><div class="line">        // 释放资源</div><div class="line">        inputStream.close();</div><div class="line">        httpUrlConn.disconnect();</div><div class="line">        // 输出返回结果</div><div class="line">        System.out.println(buffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 微信服务器返回的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;access_token&quot;:&quot;E3kRcQTati3QBPz97ou7zG0NXFrZFbA5No_hs5FNUZ62ROT0jr0txWr-gG1w-t06kk0zBW0kFmJiicJAydFyHNZhIh2uqIw4B5t85huRLs4&quot;,&quot;expires_in&quot;:7200&#125;</div></pre></td></tr></table></figure>
<p>代码优化：微信服务器返回的是json数据，如何从json里面解析出来的值</p>
<p>通过一款开源的json开发工具包json-lib，将他转换为java对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">	&lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt;</div><div class="line">	&lt;artifactId&gt;json-lib&lt;/artifactId&gt;</div><div class="line">	&lt;version&gt;2.4&lt;/version&gt;</div><div class="line">	&lt;classifier&gt;jdk15&lt;/classifier&gt;&lt;!--指定jdk版本 --&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>封装一个通用的工具类 CommonUtil ，用于专门获取token：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.utils;</div><div class="line"></div><div class="line">import java.io.BufferedReader;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.io.OutputStream;</div><div class="line">import java.io.UnsupportedEncodingException;</div><div class="line">import java.net.ConnectException;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">import javax.net.ssl.HttpsURLConnection;</div><div class="line">import javax.net.ssl.SSLContext;</div><div class="line">import javax.net.ssl.SSLSocketFactory;</div><div class="line">import javax.net.ssl.TrustManager;</div><div class="line"></div><div class="line">import org.slf4j.Logger;</div><div class="line">import org.slf4j.LoggerFactory;</div><div class="line"></div><div class="line">import com.wyj.wechart.pojo.Token;</div><div class="line">import com.wyj.wechart.pojo.WeixinUserInfo;</div><div class="line"></div><div class="line">import net.sf.json.JSONException;</div><div class="line">import net.sf.json.JSONObject;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 通用工具类</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * @author：WangYuanJun</div><div class="line"> * @date：2018年1月23日 下午3:36:50</div><div class="line"> */</div><div class="line">public class CommonUtil &#123;</div><div class="line">    private static Logger log = LoggerFactory.getLogger(CommonUtil.class);</div><div class="line"></div><div class="line">    // 凭证获取（GET）</div><div class="line">    public final static String token_url = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET&quot;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 发送https请求</div><div class="line">     * </div><div class="line">     * @param requestUrl</div><div class="line">     *            请求地址</div><div class="line">     * @param requestMethod</div><div class="line">     *            请求方式（GET、POST）</div><div class="line">     * @param outputStr</div><div class="line">     *            提交的数据</div><div class="line">     * @return JSONObject(通过JSONObject.get(key)的方式获取json对象的属性值)</div><div class="line">     */</div><div class="line">    public static JSONObject httpsRequest(String requestUrl, String requestMethod, String outputStr) &#123;</div><div class="line">        JSONObject jsonObject = null;</div><div class="line">        try &#123;</div><div class="line">            // 创建SSLContext对象，并使用我们指定的信任管理器初始化</div><div class="line">            TrustManager[] tm = &#123; new MyX509TrustManager() &#125;;</div><div class="line">            SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</div><div class="line">            sslContext.init(null, tm, new java.security.SecureRandom());</div><div class="line">            // 从上述SSLContext对象中得到SSLSocketFactory对象</div><div class="line">            SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class="line"></div><div class="line">            URL url = new URL(requestUrl);</div><div class="line">            HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();</div><div class="line">            conn.setSSLSocketFactory(ssf);</div><div class="line"></div><div class="line">            conn.setDoOutput(true);</div><div class="line">            conn.setDoInput(true);</div><div class="line">            conn.setUseCaches(false);</div><div class="line">            // 设置请求方式（GET/POST）</div><div class="line">            conn.setRequestMethod(requestMethod);</div><div class="line"></div><div class="line">            // 当outputStr不为null时向输出流写数据</div><div class="line">            if (null != outputStr) &#123;</div><div class="line">                OutputStream outputStream = conn.getOutputStream();</div><div class="line">                // 注意编码格式</div><div class="line">                outputStream.write(outputStr.getBytes(&quot;UTF-8&quot;));</div><div class="line">                outputStream.close();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 从输入流读取返回内容</div><div class="line">            InputStream inputStream = conn.getInputStream();</div><div class="line">            InputStreamReader inputStreamReader = new InputStreamReader(inputStream, &quot;utf-8&quot;);</div><div class="line">            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);</div><div class="line">            String str = null;</div><div class="line">            StringBuffer buffer = new StringBuffer();</div><div class="line">            while ((str = bufferedReader.readLine()) != null) &#123;</div><div class="line">                buffer.append(str);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // 释放资源</div><div class="line">            bufferedReader.close();</div><div class="line">            inputStreamReader.close();</div><div class="line">            inputStream.close();</div><div class="line">            inputStream = null;</div><div class="line">            conn.disconnect();</div><div class="line">            jsonObject = JSONObject.fromObject(buffer.toString());</div><div class="line">        &#125; catch (ConnectException ce) &#123;</div><div class="line">            log.error(&quot;连接超时：&#123;&#125;&quot;, ce);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;https请求异常：&#123;&#125;&quot;, e);</div><div class="line">        &#125;</div><div class="line">        return jsonObject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取接口访问凭证</div><div class="line">     * </div><div class="line">     * @param appid</div><div class="line">     *            凭证</div><div class="line">     * @param appsecret</div><div class="line">     *            密钥</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public static Token getToken(String appid, String appsecret) &#123;</div><div class="line">        Token token = null;</div><div class="line">        String requestUrl = token_url.replace(&quot;APPID&quot;, appid).replace(&quot;APPSECRET&quot;, appsecret);</div><div class="line">        // 发起GET请求获取凭证</div><div class="line">        JSONObject jsonObject = httpsRequest(requestUrl, &quot;GET&quot;, null);</div><div class="line"></div><div class="line">        if (null != jsonObject) &#123;</div><div class="line">            try &#123;</div><div class="line">                token = new Token();</div><div class="line">                token.setAccessToken(jsonObject.getString(&quot;access_token&quot;));</div><div class="line">                token.setExpiresIn(jsonObject.getInt(&quot;expires_in&quot;));</div><div class="line">            &#125; catch (JSONException e) &#123;</div><div class="line">                token = null;</div><div class="line">                // 获取token失败</div><div class="line">                log.error(&quot;获取token失败 errcode:&#123;&#125; errmsg:&#123;&#125;&quot;, jsonObject.getInt(&quot;errcode&quot;), jsonObject.getString(&quot;errmsg&quot;));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return token;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改Token测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">package com.wyj.wechart.test;</div><div class="line"></div><div class="line">import java.io.BufferedReader;</div><div class="line">import java.io.InputStream;</div><div class="line">import java.io.InputStreamReader;</div><div class="line">import java.net.URL;</div><div class="line"></div><div class="line">import javax.net.ssl.HttpsURLConnection;</div><div class="line">import javax.net.ssl.SSLContext;</div><div class="line">import javax.net.ssl.SSLSocketFactory;</div><div class="line">import javax.net.ssl.TrustManager;</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import com.wyj.wechart.pojo.Token;</div><div class="line">import com.wyj.wechart.utils.CommonUtil;</div><div class="line">import com.wyj.wechart.utils.MyX509TrustManager;</div><div class="line"></div><div class="line">public class TokenTest &#123;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testGetToken1() throws Exception &#123;</div><div class="line">        String tokenUrl = &quot;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=appID&amp;secret=appsecret&quot;;</div><div class="line">        // 建立连接</div><div class="line">        URL url = new URL(tokenUrl);</div><div class="line">        HttpsURLConnection httpUrlConn = (HttpsURLConnection) url.openConnection();</div><div class="line"></div><div class="line">        // 创建SSLContext对象，并使用我们指定的信任管理器初始化</div><div class="line">        TrustManager[] tm = &#123; new MyX509TrustManager() &#125;;</div><div class="line">        SSLContext sslContext = SSLContext.getInstance(&quot;SSL&quot;, &quot;SunJSSE&quot;);</div><div class="line">        sslContext.init(null, tm, new java.security.SecureRandom());</div><div class="line">        // 从上述SSLContext对象中得到SSLSocketFactory对象</div><div class="line">        SSLSocketFactory ssf = sslContext.getSocketFactory();</div><div class="line"></div><div class="line">        httpUrlConn.setSSLSocketFactory(ssf);</div><div class="line">        httpUrlConn.setDoOutput(true);</div><div class="line">        httpUrlConn.setDoInput(true);</div><div class="line"></div><div class="line">        // 设置请求方式（GET/POST）</div><div class="line">        httpUrlConn.setRequestMethod(&quot;GET&quot;);</div><div class="line"></div><div class="line">        // 取得输入流</div><div class="line">        InputStream inputStream = httpUrlConn.getInputStream();</div><div class="line">        InputStreamReader inputStreamReader = new InputStreamReader(</div><div class="line">                inputStream, &quot;utf-8&quot;);</div><div class="line">        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);</div><div class="line">        // 读取响应内容</div><div class="line">        StringBuffer buffer = new StringBuffer();</div><div class="line">        String str = null;</div><div class="line">        while ((str = bufferedReader.readLine()) != null) &#123;</div><div class="line">            buffer.append(str);</div><div class="line">        &#125;</div><div class="line">        bufferedReader.close();</div><div class="line">        inputStreamReader.close();</div><div class="line">        // 释放资源</div><div class="line">        inputStream.close();</div><div class="line">        httpUrlConn.disconnect();</div><div class="line">        // 输出返回结果</div><div class="line">        System.out.println(buffer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void testGetToken2() &#123;</div><div class="line">        Token token = CommonUtil.getToken(&quot;appID&quot;,&quot;appsecret&quot;);</div><div class="line">        System.out.println(&quot;access_token:&quot;+token.getAccessToken());</div><div class="line">        System.out.println(&quot;expires_in:&quot;+token.getExpiresIn());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>控制台输出效果如下，说明我们获取到了access_token和expires_in：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">access_token:2amR6pr1eN-BuSBgho-nzo5tofxJ6BdEnRJQ87Zs5bj4ny4CGB8w-1D3YtjG2PzmEvVm1INrsVg-5BjyHCkWmBKsLPDSF3r_bdaPxMpKtbw</div><div class="line">expires_in:7200</div></pre></td></tr></table></figure>
<p><font color="red">注：github项目地址：</font><a href="https://github.com/wangyuanjun008/wyj-wechat-demo" target="_blank" rel="external">微信公共号开发用例</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一：access-token简介&quot;&gt;&lt;a href=&quot;#一：access-token简介&quot; class=&quot;headerlink&quot; title=&quot;一：access_token简介&quot;&gt;&lt;/a&gt;一：access_token简介&lt;/h1&gt;&lt;p&gt;为了使第三方开发者能够为用户
    
    </summary>
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/categories/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
    
      <category term="微信公共号" scheme="http://wangyuanjun.cn/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E5%85%B1%E5%8F%B7/"/>
    
  </entry>
  
</feed>
