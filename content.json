[{"title":"github-hexo搭建博客之hexo提交百度搜索引擎","date":"2017-12-18T09:13:23.000Z","path":"2017/12/18/github-hexo搭建博客之hexo提交百度搜索引擎/","text":"前几天在整理自己的博客想添加一个评论的功能，希望我写的博客能被广大人员所知，突然发现自己写的博客在百度上搜索不到，那我添加评论功能就没有意义，百度一下才知道github禁止了百度爬虫，晕死。折腾了好久才解决，接下来我向大家介绍我的解决方法。 #域名1.注册域名：我是在dnspod中注册域名的，下面我以dnspod为例；2.绑定域名 绑定域名分2种情况：CNAME和A记录。 A记录：A记录填写IP，由于不带www方式只能采用A记录，所以必须先才cmd的ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP CNAME：将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问 3.在source文件夹中新建一个CNAME文件（无后缀名），然后用文本编辑器打开，在首行添加你的网站域名，如http://xxxx.com，注意前面没有http://，也没有www，然后使用hexo g &amp;&amp; hexo d上传部署。在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 #验证网站1.百度搜索引擎入口：百度搜索引擎入口2.先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的public/下面 。然后部署到服务器,输入地址：http://chaoo.oschina.io/baidu_verify_wjJ25Q3cv2.html能访问到就可以点验证按钮(按照百度的引导步骤就好)。3.网页抓取:(1.主动推送 2.自动推送 3.sitemap 4.手动提交 )我选择的是自动推送 自动推送: 自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度，可将代码添加到\\themes\\landscape\\layout_partial\\after_footer.ejs中的最下面就行。 代码如下： &lt;script&gt; (function(){ var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); })(); &lt;/script&gt; 参考: hexo提交搜索引擎（百度+谷歌)","tags":[]},{"title":"github-hexo搭建博客之畅言实现博客的评论","date":"2017-12-18T07:16:28.000Z","path":"2017/12/18/github-hexo搭建博客之畅言实现博客的评论/","text":"前几天在整理自己的博客想添加一个评论的功能，希望我写的博客能被广大人员所知，解决了域名添加百度搜索引擎之后，我决定用畅言作为我的评论插件。 注册畅言进入畅言官网 , 点击右上角 “免费注册”，并填写注册信息 绑定域名详情见 [github-hexo搭建博客之hexo提交百度搜索引擎](http://wangyuanjun.cn/2017/12/18/github-hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E4%B9%8Bhexo%E6%8F%90%E4%BA%A4%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/) 登录并进入畅言后台注册完后，登录进入畅言官网，获取你的畅言 app id 和 app key。 使用畅言系统在主题的目录下_config.yml，添加上changyan_appid和changyan_conf的值。 #Cmments comment: cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: xxxxxxxxxxx appkey: xxxxxxxxxxxxxxxxxxxxxxxx","tags":[]},{"title":"使用element ui select下拉框多选，编辑状态下回显数据","date":"2017-12-07T14:55:20.000Z","path":"2017/12/07/使用element-ui-select下拉框多选，编辑状态下回显数据/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中使用的是 element ui 组件库，在使用select多选下拉框时，编辑页面不知道怎么为其赋值回显数据。下拉框的代码如下: &lt;el-form-item label=&quot;可选角色&quot;&gt; &lt;el-select v-model=&quot;commonForm.roles&quot; multiple placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;item in rolesItems&quot; :key=&quot;item.id&quot; :label=&quot;item.text&quot; :value=&quot;item.id&quot; &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; 猜想:多选下拉框是多条数据，将数据放到数组里面，将数据赋值给多选下拉框，就会有效果。 验证:将多选数据以数组的形式从后台返回到前台，后台字段类型是List返回结果如下: 查看页面多选回显数据成功 参考地址: https://github.com/wangyuanjun008/wyj-vue-security/blob/master/src/view/user/user.vue","tags":[{"name":"element ui","slug":"element-ui","permalink":"http://yoursite.com/tags/element-ui/"}]},{"title":"webpack引入jquery以及插件的方法(如ztree)","date":"2017-12-06T15:27:16.000Z","path":"2017/12/06/webpack引入jquery以及插件的方法-如ztree/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中需要用到树插件，但是我觉得element ui 自带的树组件不好用，最主要的问题就是后台返回到前台的数据用到递归，不太好做，所以想到了用ztree树插件来做。 安装 ztree (会自动下载依赖的 jquery ，所以不用下 jquery ) npm install ztree --save-dev 在需要的地方引入资源 import $ from &apos;jquery&apos; import &apos;ztree&apos; 但是报错说ztree找不到jquery，报错如下: 配置jquery由于 ztree 依赖于 jQuery，所以在代码中 import jQuery from ‘jquery’ 是不够的，这只是解决了自己代码对 jQuery 的依赖，在此处使用了webpack.ProvidePlugin 解决方案：在 webpack.base.conf.js 头部添加 var webpack = require(&apos;webpack&apos;) 在 resolve 后边添加 plugins: [ new webpack.ProvidePlugin({ $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot; }) ] 引入ztree在 main.js 中，加入如下代码 import &apos;ztree/css/zTreeStyle/zTreeStyle.css&apos; import &apos;ztree&apos; 项目效果:","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"解决element ui select下拉框不回显数据问题","date":"2017-12-05T14:06:34.000Z","path":"2017/12/05/解决element-ui-select下拉框不回显数据问题/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中用到 el-select 时遇到一个问题，就是在编辑表单时，下拉框的不显示数据，前台代码如下: &lt;el-select v-model=&quot;commonForm.status&quot; clearable placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;item in items&quot; :key=&quot;item.id&quot; :label=&quot;item.text&quot; :value=&quot;item.id&quot; &gt;&lt;/el-option&gt; &lt;/el-select&gt; 在浏览器中查看列表返回的数据: 在浏览器中查看下拉框数据源的数据: 发现select下拉的id和v-model里边的id类型不一致，修改后台下拉框数据源返回类型，下拉框显示数据成功。","tags":[{"name":"element ui","slug":"element-ui","permalink":"http://yoursite.com/tags/element-ui/"}]},{"title":"解决SpringMVC接收不到axios发送post请求的数据问题","date":"2017-12-04T13:10:03.000Z","path":"2017/12/04/解决SpringMVC接收不到axios发送post请求的数据问题/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中需要用到axios与后端接口交互的时候，使用POST请求时，后台接收不到前台传的数据js代码如下: export const addDataGroup = params =&gt; { return axios.post(`/remote/dataGroup/add`, params ); }; 请求的数据是: 后台代码代码如下: 解决如下:方法一 ：在项目中安装qs库作为格式化的依赖： npm install qs --save-dev 修改js代码: export const addDataGroup = params =&gt; { return axios.post(`/remote/dataGroup/add`, qs.stringify(params) ); }; 方法二：如果不想修改前端代码的话，需要对后台的代码做修改：通过翻看axios的文档得知：在axios使用Post发送数据时，默认是直接把json放到请求体中提交到后端的，而后端获取数据的方式有两种，一种是@RequestParam（通过字符串中解析出参数）,另一种是@ResponseBody（从请求体中取参数），很显然，我们的后端用了第一种方式。 参考文档：http://www.jzdlink.com/studynotes/201709141385.html","tags":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"}]},{"title":"在vue中使用axios跨域访问数据，用proxyTable解决跨域问题","date":"2017-12-04T13:04:58.000Z","path":"2017/12/04/在vue中使用axios跨域访问数据，用proxyTable解决跨域问题/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中需要用到axios与后端接口交互的时候，遇到了跨域的问题，浏览器报错如下: 能看到是有数据数据返回到前台的，说明前台没有接收到 解决方法: 进入你的vue项目下 -&gt; config -&gt; index.js，里面的dev对象下有一个proxyTable的属性，这个参数主要是一个地址映射表，可以帮助我们将复杂的url简化。 如果请求的地址是 http://127.0.0.1:8081/remote/1 ，使用proxyTable配置，请求的地址变为 /remote/1。在proxyTable中有个参数是changeOrigin，如果设置为true,那么本地会虚拟一个服务端接收你的请求并代你发送该请求，这样就不会有跨域问题了，当然这只适用于开发环境。 参考文档：https://vuejs-templates.github.io/webpack/proxy.html","tags":[{"name":"axios","slug":"axios","permalink":"http://yoursite.com/tags/axios/"}]},{"title":"使用webpack构建vue-cli项目,写scss脚本语言报错","date":"2017-11-28T06:44:20.000Z","path":"2017/11/28/使用webpack构建vue-cli项目-写scss脚本语言报错/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,但是我在使用webpack构建vue项目的时候，使用scss脚本语言是报错,错误如下: error in ./src/components/home.vue Syntax Error: Unclosed block @ ./node_modules/vue-style-loader!./node_modules/css-loader?{&quot;sourceMap&quot;:false}!./node_modules/vue-loader/lib/style-compiler?{&quot;vue&quot;:true,&quot;id&quot;:&quot;data-v-7cbbe74f&quot;,&quot;scoped&quot;:false,&quot;hasInlineConfig&quot;:false}!./node_modules/vue-loader/lib/selector.js?type=styles&amp;index=0&amp;bustCache!./src/components/home.vue 4:14-317 13:3-17:5 14:22-325 @ ./src/components/home.vue @ ./src/router/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:8080 webpack/hot/dev-server ./src/main.js 后来上网查询，如果你需要使用sass/scss定义样式，那么为了能正常编译，还需要做如下配置： //因为sass-loader依赖于node-sass，所以还要安装node-sass npm install --save-dev node-sass //在项目下，运行下列命令行 npm install --save-dev scss-loader npm install --save-dev sass-loader 因为资源是到国外下载的，如果长时间未响应或者报错，可以试用淘宝镜像 npm install --save node-sass --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/dist --sass-binary-site=http://npm.taobao.org/mirrors/node-sass","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Springboot RedisTemplate 报No qualifying bean of type... 不能按类型装配注入","date":"2017-11-23T09:40:09.000Z","path":"2017/11/23/Springboot-RedisTemplate-报No-qualifying-bean-of-type-不能按类型装配注入/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-springboot.github.com在项目中与redis集成，使用的依赖是: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 在Controller中使用如下: @Autowired private RedisTemplate&lt;String, DataGroup&gt; redisTemplate; 项目启动报错如下: Description: Field redisTemplate in com.wyj.controller.data.DataGroupController required a bean of type &apos;org.springframework.data.redis.core.RedisTemplate&apos; that could not be found. - Bean method &apos;redisTemplate&apos; in &apos;RedisAutoConfiguration.RedisConfiguration&apos; not loaded because @ConditionalOnMissingBean (names: redisTemplate; SearchStrategy: all) found bean &apos;redisTemplate&apos; Action: Consider revisiting the conditions above or defining a bean of type &apos;org.springframework.data.redis.core.RedisTemplate&apos; in your configuration. 2017-11-23 17:36:38.299 ERROR 5784 --- [ main] o.s.test.context.TestContextManager : Caught exception while allowing TestExecutionListener [org.springframework.test.context.web.ServletTestExecutionListener@3b2cf7ab] to prepare test instance [com.wyj.WyjSpringbootApplicationTests@6cc8adff] java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:189) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:131) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:230) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:228) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:287) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:289) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:247) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.junit.runners.ParentRunner.run(ParentRunner.java:363) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:283) [surefire-junit4-2.18.1.jar:2.18.1] at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:173) [surefire-junit4-2.18.1.jar:2.18.1] at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153) [surefire-junit4-2.18.1.jar:2.18.1] at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:128) [surefire-junit4-2.18.1.jar:2.18.1] at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:203) [surefire-booter-2.18.1.jar:2.18.1] at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:155) [surefire-booter-2.18.1.jar:2.18.1] at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103) [surefire-booter-2.18.1.jar:2.18.1] Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;dataGroupController&apos;: Unsatisfied dependency expressed through field &apos;redisTemplate&apos;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;org.springframework.data.redis.core.RedisTemplate&lt;java.lang.String, com.wyj.entity.data.DataGroup&gt;&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867) ~[spring-context-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) ~[spring-context-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) ~[spring-boot-1.5.8.RELEASE.jar:1.5.8.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) ~[spring-boot-1.5.8.RELEASE.jar:1.5.8.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) ~[spring-boot-1.5.8.RELEASE.jar:1.5.8.RELEASE] at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:120) ~[spring-boot-test-1.5.8.RELEASE.jar:1.5.8.RELEASE] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] ... 26 common frames omitted Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;org.springframework.data.redis.core.RedisTemplate&lt;java.lang.String, com.wyj.entity.data.DataGroup&gt;&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1493) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1104) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:585) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] ... 44 common frames omitted 苦思冥想多时，上网查阅资料，看springboot文档，结果如下 If you add a @Bean of your own of any of the auto-configured types it will replace the default (except in the case of RedisTemplate the exclusion is based on the bean name ‘redisTemplate’ not its type). 将代码改成: @Resource private RedisTemplate&lt;String, DataGroup&gt; redisTemplate; 项目启动不报错，完美解决!","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringMVC中使用aop注解无效的问题","date":"2017-09-28T06:47:46.000Z","path":"2017/09/28/SpringMVC中使用aop注解无效的问题/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-parent.git写日志注解完，进行测试时，发现日志注解没有生效，代码如下: 定义注解: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface SysLog { String action() default &quot;&quot;;//动作 } 切面: @Aspect @Component public class SysLogAspect { @Autowired private SysLogService sysLogService; @Pointcut(&quot;@annotation(com.wyj.annotation.SysLog)&quot;) public void pointCut(){} @Around(&quot;pointCut()&quot;) public Object aroud(ProceedingJoinPoint joinPoint) throws Throwable{ // 开始时间 long beginTime = System.currentTimeMillis(); //执行目标方法 Object result = joinPoint.proceed(); //执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; //保存日志 saveSysLog(joinPoint, time); return result; } } applicationContext.xml 配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=&quot;com.wyj&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot; /&gt; &lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; &lt;/beans&gt; controller代码: @Controller @RequestMapping(value = &quot;/user&quot;) public class UserController { private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private UserService userService; @SysLog(action=&quot;新增/编辑用户&quot;) @ResponseBody @RequestMapping(value = &quot;/add&quot;, method = RequestMethod.POST) public Retval save(User user) { Retval retval = Retval.newInstance(); try { if (user.getUserId() == null) { userService.saveUser(user); } else { userService.updateUser(user); } } catch (Exception e) { logger.error(e.getMessage(), e); } return retval; } } 和别人讨论了下，大致是Spring上下文的问题我的AOP配置是这样的：AOP命名空间和挪到SpringMVC自己的配置文件里面，AOP就生效了。 代码如下:springmvc-servlet.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; default-lazy-init=&quot;true&quot;&gt; &lt;mvc:annotation-driven /&gt; &lt;mvc:annotation-driven content-negotiation-manager=&quot;contentNegotiationManager&quot;&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;prettyPrint&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;contentNegotiationManager&quot; class=&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;&gt; &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;defaultContentType&quot; value=&quot;application/json&quot; /&gt; &lt;property name=&quot;mediaTypes&quot;&gt; &lt;value&gt; json=application/json xml=application/xml &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:component-scan base-package=&quot;com.wyj&quot;&gt;&lt;/context:component-scan&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;mvc:resources location=&quot;/resources/**&quot; mapping=&quot;/resources/**&quot; /&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; &lt;/beans&gt; 另外以上所述的是对controller进行切面时的配置，如果是对service进行切面，那么 这两个注释就要用在ApplicationContext.xml里面了，注意此时不要开启aop的cglib代理模式。 解释： 1.SpringMVC这个框架简化了很多的配置，但是请注意@Controller和@Service都是SpringMVC框架包里面的，也就是说，这些类的实例化以及注入也是由SpringMVC这个框架完成的（确切的来说是这个框架自己有的上下文的IoC容器完成的）。 2.而对AOP和事务的支持是Spring框架本身完成的，是Spring框架的应用上下文所扫描并处理的。 从1.2可以得出一个结论，如果SpringMVC和Spring本身用的是一个应用上下文，一个Ioc容器，那随便你的和命名空间配置在哪里，无论是Spring的ApplicationContext.xml还是SpringMVC的springmvc-servlet.xml里面，反正都是一个容器，怎么扫描，怎么处理都能找到。 但关键的是以上假设不成立，总的来说SpringMVC的应用上下文的 “ 父 ” 上下文才是Spring的应用上下文。那么这个也就是说Spring的应用上下文初始化完成的时候，它开始扫描到底哪些Bean用了AspectJ的注解，哪些用了Transactional的注解，但是利用SpringMVC注解配置的这些Bean它是找不到的，因为用了这些注解的Bean还没有被实例化甚至是还没有被装载，为什么呢？因为管理这些bean的SpringMVC的上下文可能还没有完成初始化。OK，既然Spring的上下文找不到到底哪些Bean应用了注解，那他自然也没有办法给这些Bean提供声明式AOP和事务的支持了。 至于为什么SpringMVC的应用上下文的 “ 父 ” 上下文才是Spring的应用上下文，这里有大牛为我们详解：http://blog.csdn.net/c289054531/article/details/9196149 另外，Spring中的切面类固然要用@Aspect标注，但也不要忘了用@Componet标注，这样才能被注册到容器中","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"使用Spring配置shiro时,自定义Realm中属性无法使用注解注入解决办法","date":"2017-09-21T15:30:17.000Z","path":"2017/09/21/使用Spring配置shiro时-自定义Realm中属性无法使用注解注入解决办法/","text":"项目地址: https://github.com/wangyuanjun008/wyj-parent.github.com最近在使用shiro框架与系统集成的时候，启动报错如下: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;shiroFilter&apos; defined in class path resource [spring-context-shiro.xml]: Cannot resolve reference to bean &apos;securityManager&apos; while setting bean property &apos;securityManager&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;securityManager&apos; defined in class path resource [spring-context-shiro.xml]: Cannot resolve reference to bean &apos;userRealm&apos; while setting bean property &apos;realm&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userRealm&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.wyj.service.system.UserService com.wyj.shiro.realm.UserRealm.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:328) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:107) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1456) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1197) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:232) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:618) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:467) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:403) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106) [spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4729) [catalina.jar:na] at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5167) [catalina.jar:na] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) [catalina.jar:na] at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:725) [catalina.jar:na] at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:701) [catalina.jar:na] at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:717) [catalina.jar:na] at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:586) [catalina.jar:8.0.26.B] at org.apache.catalina.startup.HostConfig$DeployDescriptor.run(HostConfig.java:1750) [catalina.jar:8.0.26.B] at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_77] at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_77] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_77] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_77] at java.lang.Thread.run(Thread.java:745) [na:1.8.0_77] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;securityManager&apos; defined in class path resource [spring-context-shiro.xml]: Cannot resolve reference to bean &apos;userRealm&apos; while setting bean property &apos;realm&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userRealm&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.wyj.service.system.UserService com.wyj.shiro.realm.UserRealm.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:328) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:107) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1456) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1197) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:320) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 28 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userRealm&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.wyj.service.system.UserService com.wyj.shiro.realm.UserRealm.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:292) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1185) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:320) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 38 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.wyj.service.system.UserService com.wyj.shiro.realm.UserRealm.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:508) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:87) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:289) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 46 common frames omitted Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoSuchBeanDefinitionException(DefaultListableBeanFactory.java:1100) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:960) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:855) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:480) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 48 common frames omitted 在shiro.xml的配置是: &lt;bean id=&quot;userRealm&quot; class=&quot;com.wyj.shiro.realm.UserRealm&quot;/&gt; UserRealm.java的代码是: public class UserRealm extends AuthorizingRealm{ @Autowired private UserService userService; @Autowired private RoleService roleService; @Autowired private MenuService menuService; /** * 授权(验证权限时调用) * 为当前登陆成功的用户授予权限和角色，已经登陆成功了 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { ... return info; } /** * 认证(登录时调用) * 验证当前登录的用户，获取认证信息 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { ... return info; } } 纠结了几个小时终于找到了问题所在,因为shiro的realm属于Filter,简单说就是初始化realm时,spring还未加载相关业务Bean,那么解决办法就是将springmvc的配置文件加载提前。 解决办法打开web.xml文件","tags":[{"name":"shiro","slug":"shiro","permalink":"http://yoursite.com/tags/shiro/"}]},{"title":"树插件ztree异步加载数据与一次性加载全部数据的写法","date":"2017-09-18T13:12:47.000Z","path":"2017/09/18/树插件ztree异步加载数据与一次性加载全部数据的写法/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-parent.github.com用到了ztree树，给大家分享异步加载数据与一次性加载数据的写法 异步加载数据是为了防止大数据量而造成树卡死的情况,代码如下:前台js: &lt;div class=&quot;col-lg-12&quot; style=&quot;height:300px; overflow:scroll;&quot;&gt; &lt;ul id=&quot;treeDemo&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; &lt;/div&gt; function setting() { var setting = { async : { enable : true, type : &quot;get&quot;, url : &apos;${ctx}/menu/renderTree&apos;, autoParam : [ &quot;id&quot;, &quot;type&quot; ] }, callback : { onClick : zTreeOnClick } }; return setting; } $.fn.zTree.init($(&quot;#treeDemo&quot;), setting(treeUrl)); 后台java: @ResponseBody @RequestMapping(value = &quot;/renderTree&quot;, method = RequestMethod.GET) public List&lt;Map&lt;String, Object&gt;&gt; renderTree1(Long id, String type) { List&lt;Map&lt;String, Object&gt;&gt; returnList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); // 加载根节点 if (StringUtils.isEmpty(id)) { Map&lt;String, Object&gt; root = new HashMap&lt;String, Object&gt;(); root.put(&quot;id&quot;, 0);// 根节点的ID root.put(&quot;name&quot;, &quot;权限管理系统&quot;); // 根节点的名字 root.put(&quot;isParent&quot;, true);//// 设置根节点为父节点 // 加载一级节点 List&lt;Map&lt;String, Object&gt;&gt; returnList1 = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); List&lt;Menu&gt; menus = menuService.listOneNodeMenus(); for (Menu menu : menus) { Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;(); node.put(&quot;id&quot;, menu.getMenuId()); node.put(&quot;name&quot;, menu.getName()); node.put(&quot;isParent&quot;, menuService.isSubNodeById(menu.getMenuId())); returnList1.add(node); } root.put(&quot;children&quot;, returnList1); returnList.add(root); return returnList; } // 加载子节点 List&lt;Menu&gt; menus = null; if (id != null &amp;&amp; id &gt; 0L) { menus = menuService.listSubMenuByParentId(id); for (Menu menu : menus) { Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;(); node.put(&quot;id&quot;, menu.getMenuId()); node.put(&quot;name&quot;, menu.getName()); node.put(&quot;isParent&quot;, menuService.isSubNodeById(menu.getMenuId())); returnList.add(node); } } return returnList; } 加载全部数据:前台js &lt;div class=&quot;col-lg-12&quot; style=&quot;height:300px; overflow:scroll;&quot;&gt; &lt;ul id=&quot;treeDemo&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; &lt;/div&gt; function setting() { var setting = { data : { simpleData : { enable : true, idKey : &quot;menuId&quot;, pIdKey : &quot;parentId&quot;, rootPId : null }, check: { enable: true, chkStyle: &quot;checkbox&quot;, chkboxType: { &quot;Y&quot;: &quot;ps&quot;, &quot;N&quot;: &quot;ps&quot; } } }; return setting; } } var jsonTree = getDataStore(&apos;${ctx}/auth/renderTree&apos;);//获得所有节点 var ztree=$.fn.zTree.init($(&quot;#treeDemo&quot;), setting(),jsonTree); 后台java: @ResponseBody @RequestMapping(value = &quot;/renderTree&quot;, method = RequestMethod.GET) public List&lt;Menu&gt; renderTree() { return menuService.listTree(); } 希望能对大家有所帮助!","tags":[{"name":"ztree","slug":"ztree","permalink":"http://yoursite.com/tags/ztree/"}]},{"title":"在java中调用存储过程","date":"2017-09-14T01:57:48.000Z","path":"2017/09/14/在java中调用存储过程/","text":"最近在做一个需要调用存储过程的功能，大多数的写法是: Connection conn=null; CallableStatement csmt=null; try { conn=JDBCUtils.getConnection(); conn.setAutoCommit(false); csmt=conn.prepareCall(&quot;call prc_1(?,?,?)&quot;); csmt.setInt(1,80); csmt.setString(2,&quot;ioc&quot;); csmt.setString(3,&quot;fhp&quot;); csmt.execute(); conn.commit(); System.out.println(&quot;success insert data&quot;); } catch (SQLException e) { e.printStackTrace(); } 但是在运用的过程是没有效果的，后来找了另外的方法，使用了jpa注解，代码如下: 存储过程需要依赖在实体上，在实体上加上@NamedStoredProcedureQueries注解，@NamedStoredProcedureQuery中name为java的方法名，procedureName为存储过程的名字，@StoredProcedureParameter中mode代表入参，name是参数名，type是参数类型 @Entity Table(name = &quot;d_cp_delivery&quot;) @NamedStoredProcedureQueries({ @NamedStoredProcedureQuery(name = &quot;closePurchaseorder&quot;, procedureName = &quot;SRMANLI.closePurchaseorder&quot;, parameters = { @StoredProcedureParameter(mode = ParameterMode.IN, name = &quot;i_deliveryid&quot;, type = Long.class) }) }) 2.调用方法如下 //java代码 EntityManager em; @Override @PersistenceContext(unitName = &quot;srment&quot;) public void setEntityManager(EntityManager em) { super.setEntityManager(em); this.em = em; } @Override public void closePurchaseorder(Long deliveryId) { Query qry = em.createNativeQuery(&quot;{call srmanli.closePurchaseorder(?1)}&quot;); qry.setParameter(1, deliveryId); qry.executeUpdate(); em.clear(); } //存储过程 procedure closePurchaseorder(i_deliveryid in number) is v_PurchaseorderDtlNum number; -- v_reqtime date := sysdate; --请求时间 v_err_msg clob; --异常 begin end;","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"使用select2下拉框ajax加载数据时,编辑赋值的方法","date":"2017-09-13T16:19:44.000Z","path":"2017/09/14/使用select2下拉框ajax加载数据时-编辑赋值的方法/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-parent.github.com使用bootstrap select2下拉框插件，ajax从后台加载数据，保存编辑后，不知道怎么为下拉框赋值，下拉框代码如下: &lt;label class=&quot;col-sm-1 control-label&quot;&gt;使用状态:&lt;/label&gt; &lt;select id=&quot;sel_status&quot; name=&quot;status&quot; class=&quot;col-sm-3 form-control select2&quot;&gt;&lt;/select&gt; $(&quot;#sel_status&quot;).select2({ placeholder : &quot;--请选择--&quot;, dropdownParent : $(&quot;#myModal&quot;), allowClear : true, width : 150, ajax : { url : &apos;${ctx}/dataDict/getData?groupCode=&apos;+&apos;yesOrNo&apos;, dataType : &apos;json&apos;, type : &apos;get&apos;, data: function (params) { return { q: params.term, // search term 请求参数 page: params.page }; }, processResults: function (data, params) { params.page = params.page || 1; return { results: data,//itemList pagination: { more: (params.page * 30) &lt; data.total_count } }; }, cache: true } }); 通过查询api知道，在select4.0之后可以使用 $(“select”).val(“id”).trigger(“change”);为下拉框赋值你会发现下拉框中的数据是点击之后才会加载数据的，使用如上方法 ‘id’是未知的，原因是在编辑的时候下拉框的数据还没有加载出来 解决方法如下: function getDataByGroupCode(groupCode){ var dataStore; $.ajax({ dataType : &apos;json&apos;, type : &apos;get&apos;, url : model.dataURL+groupCode, async : false, success: function(data){ dataStore=data; } }); return dataStore; } var dataStore = getDataByGroupCode(&apos;yesOrNo&apos;); $(&quot;#sel_status&quot;).select2({ placeholder : &quot;--请选择--&quot;, dropdownParent : $(&quot;#myModal&quot;), allowClear : true, width : 150, minimumResultsForSearch: -1, data : dataStore }); 在页面加载的时候就加载下拉框数据，在编辑时就能为其赋值，问题解决!","tags":[{"name":"select2","slug":"select2","permalink":"http://yoursite.com/tags/select2/"}]},{"title":"mybatis使用PageHelper插件报错Error creating bean with name sqlSessionFactory defined in class path resource [spring-mybatis.xml]","date":"2017-08-17T13:23:57.000Z","path":"2017/08/17/mybatis使用PageHelper插件报错Error-creating-bean-with-name-sqlSessionFactory-defined-in-class-path-resource-spring-mybatis-xml/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-parent.github.com在项目中使用mybatis的分页插件:PageHelper，整合spring后在启动后报错，错误如下: 2017-08-17 21:20:16.618 [ContainerBackgroundProcessor[StandardEngine[Catalina]]] ERROR org.springframework.web.context.ContextLoader - Context initialization failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;sqlSessionFactory&apos; defined in class path resource [spring-mybatis.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse config resource: class path resource [mybatis-config.xml]; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1553) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:539) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:681) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:403) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106) [spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4729) [catalina.jar:na] at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5167) [catalina.jar:na] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) [catalina.jar:na] at org.apache.catalina.core.StandardContext.reload(StandardContext.java:3746) [catalina.jar:na] at org.apache.catalina.loader.WebappLoader.backgroundProcess(WebappLoader.java:292) [catalina.jar:na] at org.apache.catalina.core.StandardContext.backgroundProcess(StandardContext.java:5528) [catalina.jar:na] at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1377) [catalina.jar:na] at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1381) [catalina.jar:na] at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1381) [catalina.jar:na] at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1349) [catalina.jar:na] at java.lang.Thread.run(Thread.java:745) [na:1.8.0_77] Caused by: org.springframework.core.NestedIOException: Failed to parse config resource: class path resource [mybatis-config.xml]; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:434) ~[mybatis-spring-1.2.2.jar:1.2.2] at org.mybatis.spring.SqlSessionFactoryBean.afterPropertiesSet(SqlSessionFactoryBean.java:340) ~[mybatis-spring-1.2.2.jar:1.2.2] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1612) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1549) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 23 common frames omitted Caused by: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor at org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XMLConfigBuilder.java:109) ~[mybatis-3.2.6.jar:3.2.6] at org.apache.ibatis.builder.xml.XMLConfigBuilder.parse(XMLConfigBuilder.java:92) ~[mybatis-3.2.6.jar:3.2.6] at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:428) ~[mybatis-spring-1.2.2.jar:1.2.2] ... 26 common frames omitted Caused by: java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor at org.apache.ibatis.builder.xml.XMLConfigBuilder.pluginElement(XMLConfigBuilder.java:142) ~[mybatis-3.2.6.jar:3.2.6] at org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XMLConfigBuilder.java:100) ~[mybatis-3.2.6.jar:3.2.6] ... 28 common frames omitted spring与mybaits集成的配置文件 spring-mybaits.xml &lt;!-- =======================================================================引入配置文件============================================ --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- =======================================================================配置数据源============================================ --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ================================================配置sessionfactory============================================================================== --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/wyj/mapping/auth/*.xml&quot;&gt;&lt;/property&gt; &lt;!-- 引入配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- =================================================装配dao接口================================================================================== --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.wyj.dao.auth&quot; /&gt;&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- =================================================声明式事务管理================================================================================== --&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; mybatis-config.xml 配置文件(分页插件) &lt;configuration&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库 --&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot; /&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt; &lt;!-- 和startPage中的pageNum效果一样--&gt; &lt;property name=&quot;offsetAsPageNum&quot; value=&quot;true&quot;/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt; &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt; &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt; &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt; &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt; &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt; &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,orderBy,不配置映射的用默认值 --&gt; &lt;!-- 不理解该含义的前提下，不要随便复制该配置 --&gt; &lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;&quot;/&gt; &lt;!-- 支持通过Mapper接口参数来传递分页参数 --&gt; &lt;property name=&quot;supportMethodsArguments&quot; value=&quot;true&quot;/&gt; &lt;!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page --&gt; &lt;property name=&quot;returnPageInfo&quot; value=&quot;check&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; 经过查找，原来是与mybaitis的jar包版本相差过大，项目运用的是4.1.1的版本，换上5.0.4的版本，重新运行项目，不再抛错。 修改spring-mybatis.xml配置文件如下 修改 sqlSessionFactory &lt;!-- ================================================配置sessionfactory============================================================================== --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/wyj/mapping/auth/*.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;value&gt; &lt;!-- helperDialect：有别于3.0+版本，现在必须是helperDialect，否则spring启动加载时会报错 --&gt; helperDialect=mysql &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 启动不再报错!!!","tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"试用hexo,换电脑跟新博客","date":"2017-06-29T15:33:55.000Z","path":"2017/06/29/试用hexo-换电脑跟新博客/","text":"作者：skycrown链接：https://www.zhihu.com/question/21193762/answer/103097754来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “youremail@example.com” 把其中的邮件地址换成自己的邮件地址，然后一路回车（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。2、下载Node.js，并安装3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是是.gitignore文件里面记载的可以忽略的内容。总结：.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：（1）为了使用hexo d来部署到git上，需要安装npm install hexo-deployer-git –save（2）为了建立RSS订阅，需要安装npm install hexo-generator-feed –save（3）为了建立站点地图，需要安装npm install hexo-generator-sitemap –save插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"Hello World","date":"2017-06-29T15:21:26.034Z","path":"2017/06/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"修改Weblogic jdk版本","date":"2017-05-17T08:10:45.000Z","path":"2017/05/17/修改Weblogic-jdk版本/","text":"1、E:\\develop-tools\\toolsInstall\\weblogic是我的weblogic安装目录2、E:\\develop-tools\\toolsInstall\\weblogic\\user_projects\\domains\\base_domain是我的域创建目录 找到E:\\develop-tools\\toolsInstall\\weblogic\\user_projects\\domains\\base_domain\\binsetDomainEnv.cmd,修改红框标注的","tags":[{"name":"weblogic","slug":"weblogic","permalink":"http://yoursite.com/tags/weblogic/"}]},{"title":"Oracle数据库之PL/SQL游标","date":"2017-04-28T06:35:56.000Z","path":"2017/04/28/Oracle数据库之PL-SQL游标/","text":"原文 http://www.cnblogs.com/zf29506564/p/5772344.html 游标概念 字面意思是游动的光标，是指向上下文区域的句柄或指针。 在PL/SQL块中执行CRUD操作时，ORACLE会在内存中为其分配上下文区。用数据库语言来描述游标就是：映射在上下文区结果集中一行数据上的位置实体。 用户可以使用游标访问结果集中的任意一行数据，将游标指向某行后，即可对该行数据进行操作。游标为应用提供了一种对具有多行数据查询结果集中的每一行数据分别进行单独处理的方法，是设计嵌入式SQL语句的应用程序的常用编程方式。 在每个用户会话中，可以同时打开多个游标，其最大数量由数据库初始化参数文件中的OPEN_CURSORS参数定义。 游标可分为显式游标和隐式游标两类。 显式游标 显式游标使用主要有四个步骤： 声明/定义游标打开游标读取数据关闭游标2.1 声明/定义游标 语法： CURSOR cursor_name [(parameter_dec [, parameter_dec ]…)] [RETURN datatype] IS select_statement;示例： DECLARE CURSOR c1 RETURN departments%ROWTYPE; – 声明C1游标 CURSOR c2 IS – 声明C2游标并定义 SELECT employee_id, job_id, salary FROM employees WHERE salary &gt; 2000; CURSOR c1 RETURN departments%ROWTYPE IS – 定义C1游标 SELECT * FROM departments WHERE department_id = 110; CURSOR c3 RETURN locations%ROWTYPE; – 声明C3游标 CURSOR c3 IS – 定义C3游标 SELECT * FROM locations WHERE country_id = ‘JP’; CURSOR c4(sal number) IS – 声明C4游标并定义 SELECT employee_id, job_id, salary FROM employees WHERE salary &gt; sal;BEGIN NULL;END;说明： 在指定参数数据类型时，不能使用长度约束，如C4游标的参数，不能写为number(10,4)这种结构。 [RETURN datatype]是可选的，表示游标返回数据的数据。如果选择，则应该严格与select_statement中的选择列表在次序和数据类型上匹配。一般是记录数据类型（RECORD）或带“%ROWTYPE”的数据。 2.2 打开游标 执行游标所对应的SELECT语句，将其查询结果放入工作区，并且指针指向工作区的首部，标识游标结果集。 语法： OPEN cursor_name [ ( cursor_parameter [ [,] actual_cursor_parameter ]… ) ]示例： OPEN c4 (1300);2.3 读取数据 检索结果集合中的数据行，放入指定的输出变量中。 语法： FETCH { cursor | cursor_variable | :host_cursor_variable } { into_clause | bulk_collect_into_clause [ LIMIT numeric_expression ] } ;执行FETCH语句时，每次返回一个数据行，然后自动将游标移动指向下一个数据行。当检索到最后一行数据时，如果再次执行FETCH语句，将操作失败，并将游标属性%NOTFOUND置为TRUE。所以每次执行完FETCH语句后，检查游标属性%NOTFOUND就可以判断FETCH语句是否执行成功并返回一个数据行，以便确定是否给对应的变量赋了值。 示例： fetch c4 into eid, jid, sal;2.4 关闭游标 当处理完游标结果集合数据后，应及时关闭游标，以释放该游标所占用的系统资源。 关闭游标后不能再使用FETCH语句获取其中数据。关闭后的游标可以使用OPEN语句重新打开。 语法： CLOSE cursor_name;完整示例1： DECLARE – 定义游标 CURSOR c_cursor IS SELECT first_name || last_name, Salary FROM EMPLOYEES WHERE rownum&lt;11; – 声明变量 v_ename EMPLOYEES.first_name%TYPE; v_sal EMPLOYEES.Salary%TYPE;BEGIN – 打开游标 OPEN c_cursor; – 获取数据 FETCH c_cursor INTO v_ename, v_sal; – 处理数据 WHILE c_cursor%FOUND LOOP DBMS_OUTPUT.PUT_LINE(v_ename||’—‘||to_char(v_sal) ); FETCH c_cursor INTO v_ename, v_sal; END LOOP; – 关闭游标 CLOSE c_cursor;END;完整示例2： DECLARE – 定义RECORD记录类型 TYPE emp_record_type IS RECORD( f_name employees.first_name%TYPE, h_date employees.hire_date%TYPE); – 声明记录变量 v_emp_record EMP_RECORD_TYPE; – 定义游标，有参数与返回值 CURSOR c3(dept_id NUMBER, j_id VARCHAR2) RETURN EMP_RECORD_TYPE IS SELECT first_name, hire_date FROM employees WHERE department_id = dept_id AND job_id = j_id; BEGIN – 打开游标，传递参数值 OPEN c3(j_id =&gt; ‘AD_VP’, dept_id =&gt; 90); LOOP FETCH c3 INTO v_emp_record; – 获取数据 IF c3%FOUND THEN DBMS_OUTPUT.PUT_LINE(v_emp_record.f_name||’的雇佣日期是’||v_emp_record.h_date); ELSE DBMS_OUTPUT.PUT_LINE(‘已经处理完结果集了’); EXIT; – 处理完则退出循环 END IF; END LOOP; CLOSE c3; –关闭游标END; 显式游标属性 游标的状态（如是否打开，获取了多少行数据等）可以使用游标属性来获取。 游标属性以“%属性名”的形式加在游标名之后。显式游标属性有： 属性名 说明%FOUND 如果记录成功获取，返回TRUE，否则返回FALSE%NOTFOUND 如果记录获取失败，返回TRUE，否则返回FALSE%ROWCOUNT 返回已经从游标中获取的记录数%ISOPEN 如果游标是打开的，返回TRUE，否则返回FALSE示例： DECLARE v_empno EMPLOYEES.EMPLOYEE_ID%TYPE; v_sal EMPLOYEES.Salary%TYPE; – 定义游标 CURSOR c_cursor IS SELECT EMPLOYEE_ID, Salary FROM EMPLOYEES;BEGIN – 打开游标 OPEN c_cursor; LOOP – 获取数据 FETCH c_cursor INTO v_empno, v_sal; EXIT WHEN c_cursor%NOTFOUND; – 未读取到记录，则退出循环 IF v_sal&lt;=1200 THEN UPDATE EMPLOYEES SET Salary=Salary+50 WHERE EMPLOYEE_ID=v_empno; DBMS_OUTPUT.PUT_LINE(‘编码为’||v_empno||’工资已更新!’); END IF; DBMS_OUTPUT.PUT_LINE(‘记录数:’|| c_cursor %ROWCOUNT); END LOOP; – 关闭游标 CLOSE c_cursor;END; 基于游标定义记录变量 使用%ROWTYPE属性不仅可以基于表和视图定义记录变量，也可以基于游标定义记录变量。当基于游标定义记录变量时，记录成员名实际就是SELECT语句的列名和列别名。 为了简化显式游标的数据处理，建议使用基于游标的记录变量存放游标数据。基于游标定义记录变量，比声明记录类型变量要方便，不容易出错。 示例： DECLARE – 定义游标 CURSOR emp_cursor IS SELECT ename,sal FROM emp； emp_reocrd emp_cursor%ROWTYPE；– 游标变量BEGIN – 打开游标 OPEN emp_cursor； LOOP – 获取记录 FETCH emp_cursor INTO emp_record； EXIT WHEN emp_record%NOTFOUND； dbms_ouput.put_line(‘雇员名:’||emp_record.ename||’,雇员工资:’||emp_record.sal)； END LOOP； – 关闭游标 CLOSE emp_cursor；END； 隐式游标 如果在PL/SQL块中使用了SELECT语句进行操作，PL/SQL会隐含处理游标定义，而对于非查询语句，如修改、删除操作，则由ORACLE系统自动地为这些操作设置游标并创建其工作区。由系统隐含创建的游标称为隐式游标，隐式游标的名字为SQL。 对于隐式游标的操作，如定义、打开、取值及关闭操作，都由ORACLE 系统自动地完成，无需用户进行处理。用户只能通过隐式游标的相关属性，来完成相应的操作。在隐式游标的工作区中，所存放的数据是与用户自定义的显示游标无关的、最新处理的一条SQL语句所包含的数据。 隐式游标的属性： 属性名 说明SQL%FOUND 如果记录成功获取，返回TRUE，否则返回FALSESQL%NOTFOUND 如果记录获取失败，返回TRUE，否则返回FALSESQL%ROWCOUNT 返回已经从游标中获取的记录数SQL%ISOPEN 如果游标是打开的，返回TRUE，否则返回FALSE隐式游标在INSERT，UPDATE，DELETE，SELECT语句中不必明确定义游标。 示例： DECLARE v_rows NUMBER;BEGIN – 更新表数据 UPDATE employees SET salary = 5000 WHERE department_id = 90 AND job_id = ‘AD_VP’; – 获取受影响行数 v_rows := SQL%ROWCOUNT; DBMS_OUTPUT.PUT_LINE(‘更新了’||v_rows||’个员工的工资’);END; 游标FOR循环 游标FOR循环和显示游标的一种快捷使用方式，它使用FOR循环依次读取结果集中的行数据，当FOR循环开始时，游标自动打开（不需要OPEN）,每循环一次系统自动读取游标当前行的数据（不需要FETCH)，当退出FOR循环时，游标被自动关闭（不需要使用CLOSE）使用游标FOR循环的时候不能使用OPEN语句，FETCH语句和CLOSE语句，否则会产生错误。 语法： FOR index_variable IN cursor_name[(value[, value]…)] LOOP – 游标处理语句END LOOP;示例： DECLARE CURSOR emp_cur(vartype number) IS SELECT emp_no,emp_zc FROM cus_emp_basic WHERE com_no=vartype;BEGIN FOR person IN emp_cur(123) LOOP DBMS_OUTPUT.PUT_LINE(‘编号:’||person.emp_no||’,地址:’||person.emp_zc);END LOOP;END; 使用显示游标修改数据 在PL/SQL中依然可以使用UPDATE和DELETE语句更新或删除数据行。显式游标只有在需要获得多行数据的情况下使用。PL/SQL提供了仅仅使用游标就可以执行删除或更新记录的方法。 UPDATE或DELETE语句中的WHERE CURRENT OF子句专门处理要执行UPDATE或DELETE操作的表中取出的最近的数据。要使用这个方法，在声明游标时必须使用FOR UPDATE子句，当使用FOR UPDATE子句打开一个游标时，所有返回集中的数据行都将处于行级（ROW-LEVEL)独占式锁定，其他对象只能查询这些数据行，不能进行UPDATE、DELETE或SELECT…FOR UPDATE操作。 语法： FOR UPDATE [OF [schema.]table.column[,[schema.]table.column]..[NOWAIT]在多表查询中，使用OF子句来锁定特定的表,如果忽略了OF子句，那么所有表中选择的数据行都将被锁定。如果这些数据行已经被其他会话锁定，那么正常情况下ORACLE将等待，直到数据行解锁。当加上NOWAIT子句时，如果这些行真的被另一个会话锁定，则OPEN立即返回并给出： ORA-00054 ：resource busy and acquire with nowait specified.在UPDATE和DELETE中使用WHERE CURRENT OF子串的语法如下： WHERE{CURRENT OF cursor_name|search_condition}示例： DELCARE CURSOR c1 IS SELECT empno,salary FROM emp WHERE comm IS NULL FOR UPDATE OF comm; v_comm NUMBER(10,2);BEGIN FOR r1 IN c1 LOOP IF r1.salary&lt;500 THEN v_comm:=r1.salary0.25; ELSEIF r1.salary&lt;1000 THEN v_comm:=r1.salary0.20; ELSEIF r1.salary&lt;3000 THEN v_comm:=r1.salary0.15; ELSE v_comm:=r1.salary0.12; END IF; UPDATE emp SET comm=v_comm WHERE CURRENT OF c1; END LOOP;END 游标变量 与游标类似，游标变量指向多行查询的结果集的当前行。但是，游标与游标变量是不同的，就像常量和变量的关系一样。游标是静态的，游标变量是动态的，因为它不与特定的查询绑定在一起。 8.1 声明游标变量 语法： TYPE ref_type_name IS REF CURSOR [ RETURN return_type];说明： 游标变量类型有强类型定义和弱类型定义两种。强类型定义必须指定游标变量的返回值类型，而弱类型定义则不说明返回值类型。 return_type为游标变量的返回值类型，它必须为记录变量。 示例： – 定义一个REF CURSOU类型TYPE ref_cursor_type IS REF CURSOR;– 声明一个游标变量cv_ref REF_CURSOR_TYPE;8.2 游标变量的使用 与游标一样，游标变量操作也包括打开、提取和关闭三个步骤。 8.2.1 打开游标变量 语法： OPEN {cursor_variable_name | :host_cursor_variable_name}FOR select_statement;说明： host_cursor_variable_name为PL/SQL主机环境（如OCI: ORACLE Call Interface，Pro*c 程序等）中声明的游标变量。 OPEN…FOR 语句可以在关闭当前的游标变量之前重新打开游标变量，而不会导致CURSOR_ALREAD_OPEN异常错误。新打开游标变量时，前一个查询的内存处理区将被释放。 8.2.2 提取数据 语法： FETCH {cursor_variable_name | :host_cursor_variable_name}INTO {variable [, variable]…| record_variable};说明： 将提取到的数据放入普通变量和记录变量中存放。 8.2.3 关闭游标 语法： CLOSE {cursor_variable_name | :host_cursor_variable_name}说明： 如果应用程序试图关闭一个未打开的游标变量，则将导致INVALID_CURSOR异常错误。 示例1： DECLARETYPE ref_type_table IS REF CURSOR;v_cursor ref_type_table;emp_record emp%rowtype;BEGIN OPEN v_cursor FOR select * from emp where deptno=&no; LOOP FETCH v_cursor INTO emp_record; EXIT WHEN v_cursor%NOTFOUND; dbms_output.put_line(‘员工号：’||emp_record.ename||’部门号：’||emp_record.deptno); END LOOP; CLOSE v_cursor;END;示例2： DECLARE emp_record emp%rowtype; TYPE ref_type_table IS REF CURSOR RETURN emp%rowtype; v_cursor ref_type_table;BEGIN OPEN v_cursor FOR select * from emp where deptno=&no; LOOP FETCH v_cursor INTO emp_record; EXIT WHEN v_cursor%NOTFOUND; dbms_output.put_line(‘员工号：’||emp_record.ename||’部门号：’||emp_record.deptno); END LOOP; CLOSE v_cursor;END; DECLAREType emp_record_type IS RECORD( ename emp.ename%TYPE, salary emp.sal%TYPE, deptno emp.deptno%TYPE);emp_record emp_record_type; TYPE ref_type_table IS REF CURSOR RETURN emp_record_type;v_cursor ref_type_table;BEGIN OPEN v_cursor FOR select ename,sal,deptno from emp where deptno=&no; LOOP FETCH v_cursor INTO emp_record; EXIT WHEN v_cursor%NOTFOUND; dbms_output.put_line(‘员工号：’||emp_record.ename||’，部门号：’||emp_record.deptno||’，工资：’||emp_record.salary); END LOOP; CLOSE v_cursor;END; 使用游标批量获取 语法： FETCH … BULK COLLECT INTO …[LIMIT row_number];说明： 使用BULK COLLECT，我们可以用对数据库的一个来回，返回多行数据。BULK COLLECT减少了PL/SQL和SQL引擎之间的上下文开关数目，因而加速了数据获取的速度。 示例： DECLARE CURSOR emp_cursor(v_deptno number) IS SELECT * FROM EMP WHERE deptno = v_deptno; TYPE type_emp_table IS TABLE OF emp%ROWTYPE INDEX BY BINARY_INTEGER; emp_table type_emp_table; v_dno emp.deptno%TYPE;BEGIN v_dno := &no; OPEN emp_cursor(v_dno); FETCH emp_cursor BULK COLLECT INTO emp_table; CLOSE emp_cursor; FOR i IN 1..emp_table.COUNT LOOP dbms_output.put_line(‘员工号：’||emp_table(i).ename||’工资：’||emp_table(i).sal); END LOOP; CLOSE emp_cursor;END; 游标表达式 游标表达式作用是用于返回嵌套游标。语法： CURSOR(sub_query)示例： DECLARE CURSOR dept_emp_cursor(v_deptno number) IS SELECT dname,cursor(SELECT * FROM emp e WHERE e.deptno = d.deptno) FROM dept d WHERE deptno = v_deptno; TYPE emp_cursor_type IS REF CURSOR; emp_cursor emp_cursor_type; emp_record emp%ROWTYPE; v_name dept.dname%TYPE; v_dno emp.deptno%TYPE;BEGIN v_dno := &no; OPEN dept_emp_cursor(v_dno); loop FETCH dept_emp_cursor INTO v_name,emp_cursor; EXIT WHEN dept_emp_cursor%NOTFOUND; dbms_output.put_line(‘部门名称：’||v_name); LOOP FETCH emp_cursor INTO emp_record; EXIT WHEN emp_cursor%NOTFOUND; dbms_output.put_line(‘员工名称：’||emp_record.ename||’，工资：’||emp_record.sal); END LOOP; end loop; CLOSE dept_emp_cursor;END;","tags":[]},{"title":"跨Oracle数据库实现表级别的实时同步","date":"2017-04-28T05:49:50.000Z","path":"2017/04/28/跨Oracle数据库实现表级别的实时同步/","text":"一. 问题描述 有两个Oracle数据库，分别布置在不同的服务器上，系统均为windows2003； 这里暂且说成是一个主数据库和从数据库： (1) 主数据库: oracle_A ； (2) 从数据库: oracle_B ； 在oracle_A中有一个表table_A与oracle_B中的表table_B 结构相同 ； 我是处在oracle_B，oracle_A数据库分配给我有一个访问oracle_A表table_A的用户，该用户 只拥有查询的权限 ； 另外，需要 说明的一点 ，就是在oracle_B处,只需对table_B表进行查询的操作，不进行其他增删改的操作。 场景介绍完了， 我的问题 的是,如何在oracle_A中表table_A发生变化时,实时更新同步到oracle_B的table_B中? 我原来的处理方式: 通过建立远程连接DBLink+JOB定时任务+存储过程的方式,实现了定时同步 更新,但不能做到实时同步 。 二. 采用同义词+DB_Link的方式结果步骤 之所以能够选择采用同义词的方式，处理这个问题。主要还是源于在问题描述中提到一个点，那就是我们只需要对同步后的表进行 查询 操作。这点是使用同义词方式的重要要素。 下面详细模拟一下整个实验测试的过程： （1）首先在Oracle_A端创建一个对table_A只有查询功能的用户 创建用户 sqlplus /nolog conn /as sysdba; create user username identified by password; 查看所有的用户列表 用户创建完成后,查看用户是否创建成功 select * from all_users; 授予权限 为了能够保证能够登陆,必须赋予如下权限 –授予username用户创建session的权限,即登陆权限 grant create session to username; –授予username用户使用表空间的权限 grant unlimited tablespace to username; –oracle对权限管理比较严谨,普通用户之间也是默认不能互相访问的,需要互相授权. –如果scott用户要授权给username用户查看自己的test表的权限; sqlplus scott/tiget@localhost:1521/orcl –授予username用户查看指定的权限 grant select on test to username; –撤销权限 基本语法同grant,关键字为revoke;（2）验证用户是否可以成功登录，并进行访问授权的表 –使用sqlplus登录，并进行查询sqlplus username/password@localhost:1521/orcl;select * from scott.test;注意：查询表时，务必带上用户名，说明是哪个用户下的表。 （3）创建远程连接DB_Link 创建远程连接 db_linkcreate public database link db32 connect to tianzhi_test identified by “tianzhi_test” using ‘192.168.56.6:1521/ORCL’ 测试远程连接是否成功select * from tianzhi_smart.zh_item_news@db32;（4）在Oracle_B端创建同义词 使用sqlplus登录自己的用户sqlplus tianzhi_smart/tianzhi_smart@localhost:1521/orcl 创建同义词create or replace public synonym TEST1130 for scott.TEST@db32; 查询测试select * from TEST1130;可以看到这与在Oracle_A源数据库中查到的table_A表中的数据一样.注意事项: 当远程查询的数据库中包含BLOB字段时,会报出如下错误. ORA-22992: 无法使用从远程表选择的 LOB 定位器 当出现这个错误的时候，那是因为跨库连接查询中的表中存在BLOB类型的字段，所以一定要注意，所有表中存在blob类型字段， 不能用 select * from 连接的表不能将blob类型的字段出现在脚本中。如果这些blob类型的字段一定要导过来，可以先建立临时表再插入本地表，方法如下.在pl/sql中执行 第一步 建临时表 create global temporary table foo ( X BLOB ) on commit delete rows; 第二步 插入本地表 insert into foo select blobcolumn from remoteTable@dl_remote ;","tags":[{"name":"oracle","slug":"oracle","permalink":"http://yoursite.com/tags/oracle/"}]},{"title":" 解决“Dynamic Web Module 3.0 requires Java 1.6 or newer.”错误","date":"2017-03-30T13:23:16.000Z","path":"2017/03/30/解决“Dynamic-Web-Module-3-0-requires-Java-1-6-or-newer-”错误/","text":"eclipse maven在项目的pom.xml的标签中加入： org.apache.maven.plugins maven-compiler-plugin 2.3.2 1.6 1.6 保存，项目构建完成后在项目文件夹上点右键，选择Maven-&gt;Update Project Configuration，问题解决。","tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Extjs中textfield的悬浮提示","date":"2017-02-22T05:56:35.000Z","path":"2017/02/22/Extjs中textfield的悬浮提示/","text":"在Extjs中有时候我们需要textfield的提示信息，但是我们发现textfield并没有这样的配置项。这时候我们就要另想方法：我们需要在鼠标悬停在textfield组件的时候进行信息的提示，我们就需要在textfield中来监听，这里有两种进行textfield悬停提示的方法： 进行固定信息的提示：需要在监听中用render方法render: function (field, p) { Ext.QuickTips.init(); Ext.QuickTips.register({ target: field.el, text: &apos;这是textfield的固定信息提示！&apos; }) } 进行文本信息提示：提示信息为textfield的文本信息 var updateTip = function (field, t) { Ext.QuickTips.init(); Ext.QuickTips.register({ target: field.el, text: field.getValue() }) }; listeners: { // 鼠标移动到文本框显示悬浮框 render : function(p) { p.getEl().on(&apos;mouseover&apos;, function(p1) { updateTip(p); }); } }","tags":[{"name":"extjs","slug":"extjs","permalink":"http://yoursite.com/tags/extjs/"}]},{"title":"Redis基础命令","date":"2017-02-21T14:51:21.000Z","path":"2017/02/21/Redis基础命令/","text":"笔者最初接触Redis是因为了解了一些nosql方面的知识，觉得nosql是一个很有意思的方面。像其中的mongodb，redis等等。当初也没有深入的去了解Redis，直到自己前段时间在写一个web项目的时候需要用到缓存来进行性能优化我才仔细的来学习Redis。下面我就来说说我自己在学习Redis过程中的一些心得。 Redis是一个nosql数据库，它采用字典结构以键值对的形式将数据全部存储在内存中所以它读写的速度很快，因此很多项目用Redis做缓存用，我也是基于这个想法来学习Redis的。 Redis支持的数据类型分别是字符串(string)、散列(hash)、列表(list)、集合(set)、有序集合(sorted set)这五种。接下来我将仔细介绍下这几种数据结构的用法和对应的命令。 字符串类型 ：字符串类型是Redis中 最 基本 的数 据类型，是其他四种数据类型的基础。它能存储任何形式的字符串(二进制数据、Json对象、图片等)，它的最大数据容量是512MB。常用命令: set key value //赋值 get key //取值 keys * //查看所有的键 exists key //判断某个键是否存在 del key //删除一个键 type key //获取键的类型 incr/decr key //给键增加/减少一 incrby/decrby key increment/decrement //给键增加/减少一个整数 incrbyfloat key increment //增加浮点数 strlen key //返回键的长度 mset/mget //同时设置或者获取多个值 散列类型 ：散列类型的键值是一种字典结构，存储了字段和字段值的映射。但是字段值只能是字符串，不支持其他数据类型(Redis的其他数据类型也都不支持嵌套，只能是字符串。)。常用命令： hset key field value //赋值。不区分插入和更新操作，当键不存在是会自动建立。 hget key field //取值 hgetall key //取出所有的值 hexists key field //判断字段是否存在 hsetnx key field value //字段不存在时便赋值 hincrby key field increment //增加指定的数字，没有自增 hdel key field //删除一个或者多个字段，返回被删除的个数 hkeys key //只获取字段名 hvals key //只获取字段值 hlen key //只获取字段数量 列表类型 ：列表是个有序的字符串，向两端添加或者删除元素。它是使用双向链表实现的。常用命令: lpush/rpush list value //向左/右增加元素 lpop/rpop list //从左/右弹出元素 llen list //获列表的元素个数 lrange list start stop //获得列表片段(左边索引为0，如果为负则从右边开始) lrange key -1 0 则为获取所有的元素 lrem list count value //删除列表中前count个值为value的元素 rpoplpush oldlist newlist //将原列表的值放入新列表 集合类型 : 集合中的元素都是不同的，而且没有顺序。它可以求交集、并集、差集。常用命令: sadd set member //增加一个元素给集合(没有则创建) srem set member //删除一个或多个元素 smembers set //返回集合中所有的元素 sismember set member //判断元素是否存在于集合中 sdiff setA setB //求差集 sinter setA setB //求交集 sunion setA setB //求并集 sdiffstore destination setA setB //将求到的差集结果保存在destination中 srandmember set num //随机获取一个或多个元素(看后面加的参数) spop set //从集合中随机弹出一个元素 有序集合: 和集合相比给每个元素都关联了个分数。我们除了可以进行集合的操作外，还可以获取分数最高或者最低的几个元素。常用命令: zadd key score member //加入元素和对应分数，支持整数和双精度浮点，如果存在则修改。其中+inf和-inf代表正负无穷大 zscore key member //获得元素的分数 zrange/zrevrange key start stop //按分数从顺序/逆序排序 zrangebyscore key min (max //返回min和max之间的数左括号代表不包含 zincrby key increment member //给元素增加值 zcount key min max //获取指定范围元素的个数 zcard key //获取集合中元素的数量 zrem key member //删除元素 zremrangebyrank key start stop //按排名范围删除元素 zremrangebyscore key min max //删除分数范围值 zrank key member //元素按分数大小排名 zrevrank key member //从大到小排名 结语:个人学习总结有遗漏错误的地方还希望大家留言斧正，多多交流一起学习。","tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"阿里巴巴 Java 开发手册 笔记及重点","date":"2017-02-21T13:58:21.000Z","path":"2017/02/21/阿里巴巴-Java-开发手册-笔记及重点/","text":"编程规约1. POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。假设定义一个 boolean 的 isSuccess 属性，它的方法 Getter 被IDE生成为 isSuccess()，RPC等三方框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。这点也是笔者之前遇到过的，查了很久哪里的错最后发现是这个问题，不过经历一次后基本后面就能避免。 2. 接口类中的方法和属性不要加任何修饰符号。包括在一些开源的代码里，笔者也经常看见在接口方法上声明 public 关键字的，这是冗余的，在Java规范中提到过。关于代码的规范及简洁性诸位可以参考《重构 改善既有代码的设计》 及 代码整洁之道。 3. 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。不过没有必要插入多行空格进行隔开。这样可读性会明显提高，笔者经常看到部分开发人员的代码在很长的代码块里完全没有一个空行，没有按逻辑进行换行，这种习惯是不太好的。 4. 所有的覆写方法，必须加 @Override 注解。这样IDE会检查合法性，有错误的话会及时提示。 5. 所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。比如 Integer 的-128至127之间被缓存的对象可以直接使用==判断，因为被缓存了，是同一对象，地址相等，而这个区间外的却不能使用==判断，这也是面试时的一个常考点。 6. 关于基本数据类型与包装数据类型：所有的POJO类属性必须使用包装数据类型，以便映射数据库中的NULL，局部变量推荐使用基本数据类型。 7. 关于 hashCode 和 equals 的处理，遵循如下规则：只要重写 equals，就必须重写 hashCode，具体原因可参考《Effective java 中文版（第2版）》。 8. 关于 ArrayList 里 subList 结果的注意事项，subList 只是 ArrayList 的一个视图，这部分大家可以参考JDK里的源码。 9. 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。 10. 在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort， Collections.sort 会报 IllegalArgumentException 异常。这个在《Effective java 中文版（第2版）》中也有说明，虽然笔者之前看过，但在刚实习时的一个用于省份排序的代码里使用 Comparator 时还是忘了处理值相等的情况，所以，还是要实战后才能加深记忆。 11. 集合初始化时，尽量指定集合初始值大小。这在笔者实习面试时也被问到，这块的话主要考察 ArrayList 的原理，内部机制，诸位看看JDK里 ArrayList 的原理就明白了。 12. 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 13. 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。概括为一句话就是：尽量降低锁的粒度。 14. 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。关于并发这块可以参考《Java并发编程实战》，个人认为这本在笔者看过Java并发的书籍里能算上乘之作，另外也可参考《Java并发编程的艺术》。 15. 通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问题解决方案中较为简单一种(适用于 JDK5 及以上版本)，将目标属性声明为 volatile 型。这部分涉及到两个重点，一是双重检查锁，二是 volatile 的原理及Java的主内存及每个线程的内存之间的关系。volatile只能解决多线程时的内存可见性问题，无法解决线程安全问题。可参考Double checked locking 及 Initialization on demand holder idiom。 16. 注释掉的代码尽量要配合说明，而不是简单的注释掉。如果永久不用，建议直接删除，因为Git等版本控制系统保存了历史代码。 17. 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免无用的注释。 18. 善用 TODO 及 FIXME，IDE可以方便的进行扫描。 19. 获取当前毫秒数使用 System.currentTimeMillis()，System.nanoTime()产生的值仅用于比较，同一时刻不同虚拟机System.nanoTime()返回的值可能不一样并且相差很大，笔者的同事已经踩过一次坑，关于 nanoTime 诸位可以看一看JavaDoc。 异常日志1. 不要捕获Java类库中定义的继承自 RuntimeException 的运行时异常类，如：IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保证程序健壮性。说到这里，异常继承结构图也可以看下。 2. 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 3. 避免出现重复的代码(Don’t Repeat Yourself)，即DRY原则。关于这部分可参考《程序员修炼之道》。 4. 谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。关于日志把server磁盘撑爆的问题，我司也出现过，后面加了相关监控来避免。 MySQL规约1. 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint (1表示是，0表示否)，此规则同样适用于odps建表。任何字段如果为非负数，必须是 unsigned。因为这样的话可用容量提升了一倍。 2. 表名不使用复数名词。表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。 3. 禁用保留字，如 desc、range、match、delayed 等，禁止在代码里对 SQL 关键字进行单独处理。 4. 唯一索引名为 uk_字段名，普通索引名则为 idx_字段名。这样能让开发人员一眼就知道相关索引。 5. 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 6. 表必备三字段:id, gmt_create, gmt_modified。其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified 的类型均为 date_time 类型。创建时间与修改时间需要记录笔者理解，不理解的为什么要用 gmt 开头，北京时间应该是GMT + 8:00 啊。 7. 字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：不是频繁修改的字段；不是 varchar 超长字段，更不能是 text 字段。比如我司的很多表都冗余了 user_name 这个字段。 8. 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 9. 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。即使在应用层做了非常完善的校验和控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 10. 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。关于 MySQL 的知识，诸位可参考《高性能MySQL》。 11. 利用延迟关联或者子查询优化超多分页场景。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。 12. 建组合索引的时候，区分度最高的在最左边。 13. 不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)就是 SQL92 定义 的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 14. 不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 15. 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 16. 数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。 工程规约1. 高并发服务器建议调小 TCP 协议的 time_wait 超时时间。 2. 调大服务器所支持的最大文件句柄数(File Descriptor，简写为fd)。 3. 给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。 安全规约1. 隶属于用户个人的页面或者功能必须进行权限控制校验。 2. 用户敏感数据禁止直接展示，必须对展示数据脱敏。 3. 用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入， 禁止字符串拼接 SQL 访问数据库。 4.用户请求传入的任何参数必须做有效性验证。 5.表单、AJAX 提交必须执行 CSRF 安全过滤。 6.在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 7.关于安全这块可以阅读《白帽子讲Web安全》。 阿里巴巴Java开发手册","tags":[{"name":"编码规范","slug":"编码规范","permalink":"http://yoursite.com/tags/编码规范/"}]},{"title":"spring 读取properties的两种方法","date":"2017-02-21T13:47:12.000Z","path":"2017/02/21/spring-读取properties的两种方法/","text":"1.在配置文件中配置PropertyPlaceholderConfigurer 然后在需要的地方直接以下方式引用： 2.在配置文件中加入beans的命名空间声明如下： 用到了xmlns:context=http://www.springframework.org/schema/context配置如下：","tags":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"SpringMVC与LogBack集成","date":"2017-02-14T05:01:16.000Z","path":"2017/02/14/SpringMVC与LogBack集成/","text":"最近在做项目中需要用到日志，本来选取的是Log4j，最后经过对比之后还是发现LogBack在性能上比Log4j有优势。至于有什么好处，请参考下面这篇文章。从Log4j迁移到LogBack的理由 下面废话不多说了，就看一下，如何来把LogBack集成到我们的web项目中吧。本人前台用的是SpringMVC。 jar包配置 如果要使用LogBack做为日志的插件的话，需要的jar包有如下，直接看一下Maven依赖 org.slf4j slf4j-api 1.7.12 ch.qos.logback logback-classic 1.1.3 compile slf4j-api org.slf4j &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-access&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/span&gt; Web.xml 在web项目中需要通过web.xml来加载我们所需要的LogBack.xml具体如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- logback-begin --&gt; &lt;context-param&gt; &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:logback.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;com.util.LogbackConfigListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- logback-end --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:springMVC-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 这里一定要是/根据Servlet规范来的 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 上面的XML中用到了自定义的监听器，分别是三个类，如下所示 LogbackConfigListener类 package com.util; import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener; public class LogbackConfigListener implements ServletContextListener { public void contextInitialized(ServletContextEvent event) { LogbackWebConfigurer.initLogging(event.getServletContext()); } public void contextDestroyed(ServletContextEvent event) { LogbackWebConfigurer.shutdownLogging(event.getServletContext()); } } LogbackConfigurer类 package com.util; import java.io.File;import java.io.FileNotFoundException;import java.net.URL; import org.slf4j.LoggerFactory;import org.springframework.util.ResourceUtils;import org.springframework.util.SystemPropertyUtils; import ch.qos.logback.classic.LoggerContext;import ch.qos.logback.classic.joran.JoranConfigurator;import ch.qos.logback.core.joran.spi.JoranException; public abstract class LogbackConfigurer { /** Pseudo URL prefix for loading from the class path: &quot;classpath:&quot; */ public static final String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;; /** Extension that indicates a logback XML config file: &quot;.xml&quot; */ public static final String XML_FILE_EXTENSION = &quot;.xml&quot;; private static LoggerContext lc = (LoggerContext) LoggerFactory .getILoggerFactory(); private static JoranConfigurator configurator = new JoranConfigurator(); /** * Initialize logback from the given file location, with no config file * refreshing. Assumes an XML file in case of a &quot;.xml&quot; file extension, and a * properties file otherwise. * * @param location * the location of the config file: either a &quot;classpath:&quot; * location (e.g. &quot;classpath:mylogback.properties&quot;), an absolute * file URL (e.g. * &quot;file:C:/logback.properties), or a plain absolute path in the file system (e.g. &quot; * C:/logback.properties&quot;) * @throws FileNotFoundException * if the location specifies an invalid file path */ public static void initLogging(String location) throws FileNotFoundException { String resolvedLocation = SystemPropertyUtils .resolvePlaceholders(location); URL url = ResourceUtils.getURL(resolvedLocation); if (resolvedLocation.toLowerCase().endsWith(XML_FILE_EXTENSION)) { // DOMConfigurator.configure(url); configurator.setContext(lc); lc.reset(); try { configurator.doConfigure(url); } catch (JoranException ex) { throw new FileNotFoundException(url.getPath()); } lc.start(); } // else { // PropertyConfigurator.configure(url); // } } /** * Shut down logback, properly releasing all file locks. * &lt;p&gt; * This isn&apos;t strictly necessary, but recommended for shutting down logback * in a scenario where the host VM stays alive (for example, when shutting * down an application in a J2EE environment). */ public static void shutdownLogging() { lc.stop(); } /** * Set the specified system property to the current working directory. * &lt;p&gt; * This can be used e.g. for test environments, for applications that * leverage logbackWebConfigurer&apos;s &quot;webAppRootKey&quot; support in a web * environment. * * @param key * system property key to use, as expected in logback * configuration (for example: &quot;demo.root&quot;, used as * &quot;${demo.root}/WEB-INF/demo.log&quot;) * @see org.springframework.web.util.logbackWebConfigurer */ public static void setWorkingDirSystemProperty(String key) { System.setProperty(key, new File(&quot;&quot;).getAbsolutePath()); } } LogbackWebConfigurer类 package com.util; import java.io.FileNotFoundException; import javax.servlet.ServletContext; import org.springframework.util.ResourceUtils;import org.springframework.util.SystemPropertyUtils;import org.springframework.web.util.WebUtils; public abstract class LogbackWebConfigurer { /** Parameter specifying the location of the logback config file */ public static final String CONFIG_LOCATION_PARAM = &quot;logbackConfigLocation&quot;; /** * Parameter specifying the refresh interval for checking the logback config * file */ public static final String REFRESH_INTERVAL_PARAM = &quot;logbackRefreshInterval&quot;; /** Parameter specifying whether to expose the web app root system property */ public static final String EXPOSE_WEB_APP_ROOT_PARAM = &quot;logbackExposeWebAppRoot&quot;; /** * Initialize logback, including setting the web app root system property. * * @param servletContext * the current ServletContext * @see WebUtils#setWebAppRootSystemProperty */ public static void initLogging(ServletContext servletContext) { // Expose the web app root system property. if (exposeWebAppRoot(servletContext)) { WebUtils.setWebAppRootSystemProperty(servletContext); } // Only perform custom logback initialization in case of a config file. String location = servletContext .getInitParameter(CONFIG_LOCATION_PARAM); if (location != null) { // Perform actual logback initialization; else rely on logback&apos;s // default initialization. try { // Return a URL (e.g. &quot;classpath:&quot; or &quot;file:&quot;) as-is; // consider a plain file path as relative to the web application // root directory. if (!ResourceUtils.isUrl(location)) { // Resolve system property placeholders before resolving // real path. location = SystemPropertyUtils .resolvePlaceholders(location); location = WebUtils.getRealPath(servletContext, location); } // Write log message to server log. servletContext.log(&quot;Initializing logback from [&quot; + location + &quot;]&quot;); // Initialize without refresh check, i.e. without logback&apos;s // watchdog thread. LogbackConfigurer.initLogging(location); } catch (FileNotFoundException ex) { throw new IllegalArgumentException( &quot;Invalid &apos;logbackConfigLocation&apos; parameter: &quot; + ex.getMessage()); } } } /** * Shut down logback, properly releasing all file locks and resetting the * web app root system property. * * @param servletContext * the current ServletContext * @see WebUtils#removeWebAppRootSystemProperty */ public static void shutdownLogging(ServletContext servletContext) { servletContext.log(&quot;Shutting down logback&quot;); try { LogbackConfigurer.shutdownLogging(); } finally { // Remove the web app root system property. if (exposeWebAppRoot(servletContext)) { WebUtils.removeWebAppRootSystemProperty(servletContext); } } } /** * Return whether to expose the web app root system property, checking the * corresponding ServletContext init parameter. * * @see #EXPOSE_WEB_APP_ROOT_PARAM */ private static boolean exposeWebAppRoot(ServletContext servletContext) { String exposeWebAppRootParam = servletContext .getInitParameter(EXPOSE_WEB_APP_ROOT_PARAM); return (exposeWebAppRootParam == null || Boolean .valueOf(exposeWebAppRootParam)); } } logback.XML配置下面来看一下这个xml是如何配置的 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n ${log_dir}/error-log-%d{yyyy-MM-dd}.log ${maxHistory} %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n ${log_dir}/info-log-%d{yyyy-MM-dd}.log ${maxHistory} %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n ${log_dir}/access-log-%d{yyyy-MM-dd}.log ${maxHistory} %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n ${log_dir}/sys_user-log-%d{yyyy-MM-dd}.log ${maxHistory} %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n 关于这个XML文件的详细讲解请参考http://blog.csdn.net/haidage/article/details/6794509","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://yoursite.com/tags/SpringMVC/"}]},{"title":"如何相互转换逗号分隔的字符串和List","date":"2017-01-12T03:01:54.000Z","path":"2017/01/12/如何相互转换逗号分隔的字符串和List/","text":"将逗号分隔的字符串转换为List方法 1： 利用JDK的Arrays类String str = “a,b,c”;List result = Arrays.asList(str.split(“,”)); 方法 2： 利用Guava的SplitterString str = “a, b, c”;List result = Splitter.on(“,”).trimResults().splitToList(str); 方法 3： 利用Apache Commons的StringUtils （只是用了split)String str = “a,b,c”;List result = Arrays.asList(StringUtils.split(str,”,”)); 方法 4: 利用Spring Framework的StringUtilsString str = “a,b,c”;List str = Arrays.asList(StringUtils.commaDelimitedListToStringArray(str)); 将List转换为逗号分隔符方法 1: 不用工具类 public String listToString(List list, char separator) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; list.size(); i++) { if (i == list.size() - 1) { sb.append(list.get(i)); } else { sb.append(list.get(i)); sb.append(separator); } } return sb.toString(); } public String listToString(List list, char separator) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; list.size(); i++) { sb.append(list.get(i)).append(separator); } return sb.toString().substring(0,sb.toString().length()-1); } 方法 2： 利用Guava的JoinerList list = new ArrayList();list.add(“a”);list.add(“b”);list.add(“c”);String str = Joiner.on(“,”).join(list); 方法 3： 利用Apache Commons的StringUtilsList list = new ArrayList();list.add(“a”);list.add(“b”);list.add(“c”);String str = StringUtils.join(list.toArray(), “,”); 方法 4：利用Spring Framework的StringUtilsList list = new ArrayList();list.add(“a”);list.add(“b”);list.add(“c”);String str = StringUtils.collectionToDelimitedString(list, “,”); 比较下来，我的观点就是Guava库和StringUtils更灵活，适用面更广。","tags":[{"name":"java基础","slug":"java基础","permalink":"http://yoursite.com/tags/java基础/"}]},{"title":"extjs-上传图片","date":"2016-12-10T13:44:29.000Z","path":"2016/12/10/extjs-上传图片/","text":"&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;!--ExtJs框架开始--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/Ext/adapter/ext/ext-base.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/Ext/ext-all.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/Ext/src/locale/ext-lang-zh_CN.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/Ext/resources/css/ext-all.css&quot; /&gt; &lt;!--ExtJs框架结束--&gt; &lt;script type=&quot;text/javascript&quot;&gt; Ext.onReady(function () { //初始化标签中的Ext:Qtip属性。 Ext.QuickTips.init(); Ext.form.Field.prototype.msgTarget = &apos;side&apos;; //创建div组件 var imagebox = new Ext.BoxComponent({ autoEl: { style: &apos;width:150px;height:150px;margin:0px auto;border:1px solid #ccc; text-align:center;padding-top:20px;margin-bottom:10px&apos;, tag: &apos;div&apos;, id: &apos;imageshow&apos;, html: &apos;暂无图片&apos; } }); //创建文本上传域 var file = new Ext.form.TextField({ name: &apos;imgFile&apos;, fieldLabel: &apos;文件上传&apos;, inputType: &apos;file&apos;, allowBlank: false, blankText: &apos;请浏览图片&apos; }); //提交按钮处理方法 var btnsubmitclick = function () { if (form.getForm().isValid()) { form.getForm().submit({ waitTitle: &quot;请稍候&quot;, waitMsg: &apos;正在上传...&apos;, success: function (form, action) { Ext.MessageBox.alert(&quot;提示&quot;, &quot;上传成功！&quot;); document.getElementById(&apos;imageshow&apos;).innerHTML = &apos;&lt;img style=&quot;width:150px;height:150px&quot; src=&quot;&apos; + action.result.path + &apos;&quot;/&gt;&apos;; }, failure: function () { Ext.MessageBox.alert(&quot;提示&quot;, &quot;上传失败！&quot;); } }); } } //重置按钮&quot;点击时&quot;处理方法 var btnresetclick = function () { form.getForm().reset(); } //表单 var form = new Ext.form.FormPanel({ frame: true, fileUpload: true, url: &apos;/App_Ashx/Demo/Upload.ashx&apos;, title: &apos;表单标题&apos;, style: &apos;margin:10px&apos;, items: [imagebox, file], buttons: [{ text: &apos;保存&apos;, handler: btnsubmitclick }, { text: &apos;重置&apos;, handler: btnresetclick }] }); //窗体 var win = new Ext.Window({ title: &apos;窗口&apos;, width: 476, height: 374, resizable: true, modal: true, closable: true, maximizable: true, minimizable: true, buttonAlign: &apos;center&apos;, items: form }); win.show(); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 其中与service交互用上传图片的 一般处理程序文件，源码如下： /App_Ashx/Demo/Upload.ashx using System;using System.Web;using System.IO;using System.Globalization; namespace HZYT.ExtJs.WebSite.App_Ashx.Demo{ public class Upload : IHttpHandler { public void ProcessRequest(HttpContext context) { //虚拟目录，建议写在配置文件中 String strPath = “/Upload/Image/“; //文件本地目录 String dirPath = context.Server.MapPath(strPath); //接收文件 HttpPostedFile imgFile = context.Request.Files[“imgFile”]; //取出文件扩展名 String fileExt = Path.GetExtension(imgFile.FileName).ToLower(); //重新命名文件 String newFileName = DateTime.Now.ToString(“yyyyMMddHHmmss_ffff”, DateTimeFormatInfo.InvariantInfo) + fileExt; //文件上传路径 String filePath = dirPath + newFileName; //保存文件 imgFile.SaveAs(filePath); //客户端输出 context.Response.Write(“{success:true,path:’” + strPath + newFileName + “‘}”); } public bool IsReusable { get { return false; } } } } 2.效果如下 3.说明： (1)上传域不光可以上传图片，还要以上传其他文件。这里我们以图片为例。 (2)在实际开发中，我们还要对图片格式，大小等进行校验，这个示例测重于上传，没有加入任何校验","tags":[{"name":"extjs","slug":"extjs","permalink":"http://yoursite.com/tags/extjs/"}]},{"title":"extjs-下拉列表联动","date":"2016-12-10T13:22:32.000Z","path":"2016/12/10/extjs-下拉列表联动/","text":"不管是几级下拉列表的联动实现本质上都是根据某个下拉列表的变化，去动态加载其他下拉列表，如：省、市、地区。 当我们监听到省变化时，向service端发送省的编号，service端根据收到的”省”编号到数据库中查询该省所对应的市信息， 地区同理，抓住这一点，我们只需要监听 combobox 的 select 事件并在其中实现逻辑即可。 1.代码如下： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;!--ExtJs框架开始--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/Ext/adapter/ext/ext-base.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/Ext/ext-all.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/Ext/src/locale/ext-lang-zh_CN.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/Ext/resources/css/ext-all.css&quot; /&gt; &lt;!--ExtJs框架结束--&gt; &lt;script type=&quot;text/javascript&quot;&gt; Ext.onReady(function () { //初始化标签中的Ext:Qtip属性。 Ext.QuickTips.init(); Ext.form.Field.prototype.msgTarget = &apos;side&apos;; //----------------------下拉列表开始----------------------// //创建市数据源 var combocitystore = new Ext.data.Store({ //设定读取的地址 proxy: new Ext.data.HttpProxy({ url: &apos;/App_Ashx/Demo/City.ashx&apos; }), //设定读取的格式 reader: new Ext.data.JsonReader({ root: &apos;data&apos; }, [{ name: &apos;id&apos; }, { name: &apos;name&apos;}]) }); //创建区数据源 var comboareastore = new Ext.data.Store({ //设定读取的地址 proxy: new Ext.data.HttpProxy({ url: &apos;/App_Ashx/Demo/Area.ashx&apos; }), reader: new Ext.data.JsonReader({ root: &apos;data&apos; }, [{ name: &apos;id&apos; }, { name: &apos;name&apos;}]) }); //创建市Combobox var comboboxcity = new Ext.form.ComboBox({ id: &apos;comboboxcity&apos;, fieldLabel: &apos;市&apos;, width: 120, store: combocitystore, displayField: &apos;name&apos;, valueField: &apos;id&apos;, triggerAction: &apos;all&apos;, emptyText: &apos;请选择...&apos;, allowBlank: false, blankText: &apos;请选择市&apos;, editable: false, mode: &apos;local&apos;, //该属性和以下方法为了兼容ie8 listeners: { &apos;render&apos;: function () { combocitystore.load(); } } }); //创建区Combobox var comboareacity = new Ext.form.ComboBox({ fieldLabel: &apos;区&apos;, width: 120, store: comboareastore, displayField: &apos;name&apos;, valueField: &apos;id&apos;, triggerAction: &apos;all&apos;, emptyText: &apos;请选择...&apos;, allowBlank: false, blankText: &apos;请选择区&apos;, editable: false }); //联动的实现 comboboxcity.on(&apos;select&apos;, function () { comboareastore.baseParams.id = comboboxcity.getValue(); comboareacity.setValue(&apos;&apos;); comboareastore.load(); }) //----------------------下拉列表结束----------------------// //表单 var form = new Ext.form.FormPanel({ frame: true, title: &apos;表单标题&apos;, style: &apos;margin:10px&apos;, items: [comboboxcity, comboareacity] }); //窗体 var win = new Ext.Window({ title: &apos;窗口&apos;, width: 476, height: 374, resizable: true, modal: true, closable: true, maximizable: true, minimizable: true, buttonAlign: &apos;center&apos;, items: form }); win.show(); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 说明：(1)var combocitystore = new Ext.data.Store():创建一个新的数据源。(2)proxy: new Ext.data.HttpProxy({ url: ‘/App_Ashx/Demo/City.ashx’ })：数据代理为http代理，地址为/App_Ashx/Demo/City.ashx。(3)reader: new Ext.data.JsonReader({ root: ‘data’ },[{ name: ‘id’ }, { name: ‘name’}]):读取json返回值根节点为data，对象列为id和name。 这里要结合client与service观察,我在service端的输出如下：{data:[{id:1,name:’北京’},{id:2,name:’上海’}]}(4)comboboxcity.on(‘select’, function () {}：市选择变化时触发事件。(5)comboareastore.baseParams.id = comboboxcity.getValue()：注意，前面的comboareastore是区的数据源， 当市变化时，我们给区的数据源加上个向service端发送的参数。(6)comboareacity.setValue(‘’)：把区的下拉列表设置为空，由于非空验证，Ext会提示用户“请选择区”，这个地方也可以把加载出来的第一个区 显示在区的下拉列表中，具体请自行实现吧。(7)comboareastore.load()：区的数据源重新加载。–&gt; 其中与service交互用到两个.net 一般处理程序文件，源码如下：(1)/App_Ashx/Demo/City.ashx using System.Web; namespace HZYT.ExtJs.WebSite.App_Ashx.Demo{ public class City : IHttpHandler { public void ProcessRequest(HttpContext context) { context.Response.Write(“{data:[{id:1,name:’北京’},{id:2,name:’上海’}]}”); } public bool IsReusable { get { return false; } } } } (2)/App_Ashx/Demo/Area.ashx using System.Web; namespace HZYT.ExtJs.WebSite.App_Ashx.Demo{ public class Area : IHttpHandler { public void ProcessRequest(HttpContext context) { //接收Client端传来的参数，交根据条件返回 if (context.Request.Form[“id”].ToString() == “1”) { context.Response.Write(“{data:[{id:1,name:’东城区’},{id:2,name:’西城区’},{id:2,name:’海淀区’}]}”); } else { context.Response.Write(“{data:[{id:1,name:’杨浦区’},{id:2,name:’虹口区’},{id:2,name:’闸北区’}]}”); } } public bool IsReusable { get { return false; } } } } 2.效果如下：","tags":[{"name":"extjs","slug":"extjs","permalink":"http://yoursite.com/tags/extjs/"}]},{"title":"extjs技巧","date":"2016-12-10T13:00:02.000Z","path":"2016/12/10/extjs技巧/","text":"extjs Ext.form.ComboBox 的设置默认值的问题 Ext.onReady(function(){ var dbConnectionRecord = Ext.data.Record.create([ {name: &apos;dbConnectionKey&apos;,type:&quot;string&quot;,mapping:&quot;dbConnectionKey&quot;}, {name: &apos;name&apos;,type:&quot;string&quot;,mapping:&quot;name&quot;} ]); var dataProxy=new Ext.data.HttpProxy({url:&quot;&lt;%=basePath%&gt;getDBConnection.action&quot;}); var theReader=new Ext.data.JsonReader({totalProperty: &apos;totalProperty&apos;,root:&apos;root&apos;,id:&quot;ecname&quot;},dbConnectionRecord); var dbstore=new Ext.data.Store({proxy:dataProxy,reader:theReader}); dbstore.load(); var dbcombo = new Ext.form.ComboBox({ id:&apos;dbCombo&apos;, renderTo:Ext.getBody(), store: dbstore, valueField:&apos;dbConnectionKey&apos;, displayField:&apos;name&apos;, typeAhead: true, emptyText:&apos;请选择&apos;, readOnly : true, mode: &apos;local&apos;, name:&quot;dbkey&quot;, hiddenName:&apos;dbkey&apos;, editable: false, triggerAction: &apos;all&apos;, selectOnFocus:true }); ////dbcombo.setValue(&quot;4&quot;); 肯定不行，参见后面的代码 }); 实现：写在store load的callback里 dbstore.load({ callback : function(records) { dbcombo.setValue(&quot;4&quot;); } }); //在分页组件前面添加组件 var page = new Ext.PagingToolbar({ store: store, displayInfo: true, pageSize: 10 }); page.insert(0, &apos;-&apos;); page.insert(0, { //添加一个日期组件 xtype: &apos;datefield&apos;, name: &apos;chatdate&apos;, format: &apos;Y-m-d&apos;, value: new Date() }); //树节点(TreeNode)图标动态修改 2009-11-22 15:36:52 var ui = node.getUI(); ui.removeClass(&apos;x-tree-node-leaf&apos;); //去掉之前的根节点样式 ui.addClass(&apos;x-tree-node-expanded&apos;); //设定已展开文件夹样式 //ui.addClass(&apos;x-tree-node-collapsed&apos;);//设定合并的文件夹样式 使用Ext.Ajaxt对象完成异步请求的交互，Ext.Ajax是单实例对象（非常重要，全局单一Ext.Ajax实例！）。注册Ext.Ajax的requestcomplete事件，每个ajax请求成功后首先响应该事件。在该事件的回调函数里面判断访问请求是否超时。使用Ext.Ajax对象的好处是，只需要引入一个包含了几行超时处理代码的js文件，就可以为当前应用增加超时处理功能，原有代码不需要做任何修改。 使用Ext.Ajaxt对象完成异步请求交互，假如checkUserSessionStatus是你的回调方法，每个页面引用： Js代码 Ext.Ajax.on(‘requestcomplete’,checkUserSessionStatus, this); function checkUserSessionStatus(conn,response,options){ //Ext重新封装了response对象 if(typeof response.getResponseHeader.sessionstatus != ‘undefined’){ //发现请求超时，退出处理代码… } } Ext.Ajax.on(‘requestcomplete’,checkUserSessionStatus, this); function checkUserSessionStatus(conn,response,options){ //Ext重新封装了response对象 if(typeof response.getResponseHeader.sessionstatus != ‘undefined’){ //发现请求超时，退出处理代码… } } 可以利用的几个特性：a）所有的ajax请求均带有x-requested-with:XMLHttpRequest头信息b）Ext.Ajax是单实例对象（非常重要，全局单一Ext.Ajax实例！）c）注册Ext.Ajax的requestcomplete事件，每个ajax请求成功后首先响应该事件（概念类似spring的aop拦截）。 对于其他的ajax框架，解决用户访问请求超时这个问题的思路是类似的。 二、如何设置DateField的默认值。 设置DateField的默认值，可以直接给value属性赋值，如：value: ‘01/01/2009’，如果要设置默认值为当天的日期，可以如下设置：value: new Date new Ext.form.DateField({ id: &apos;df&apos;, fieldLabel: &apos;日期&apos;, format: &apos;Y年m月d日&apos;, width: 150, //value: &apos;01/01/2009&apos; value: new Date }) 如何禁用或者启用某个菜单有的时候，有时会根据需要，启用或者禁用某个菜单项，在ExtJS中，可以通过如下的操作进行。 Ext.onReady(function() { Ext.BLANK_IMAGE_URL = &apos;resources/images/default/s.gif&apos;; Ext.QuickTips.init(); var tb = new Ext.Toolbar({ applyTo: &apos;tb&apos;, width: 400 }); var styleMenu = new Ext.menu.Menu({ items: [{ text: &apos;主题选择&apos;, id: &apos;style&apos;, menu: new Ext.menu.Menu({ items: [{ text: &apos;红色主题&apos;, checked: true, group: &apos;theme&apos; }, { text: &apos;蓝色主题&apos;, checked: false, group: &apos;theme&apos; }, { text: &apos;黑色主题&apos;, checked: false, group: &apos;theme&apos; }] }) }, { text: &apos;启用主题&apos;, checked: true, checkHandler: function() { Ext.getCmp(&apos;style&apos;).setDisabled(!this.checked) } }] }); tb.add({ text: &apos;主题&apos;, menu: styleMenu }); }); 一、从form中获取field的三个方法： １、Ext.getCmp(&apos;id&apos;); ２、FormPanel.getForm().findField(&apos;id/name&apos;); ３、Ext.get(&apos;id/name&apos;);//前提是FormPanel在界面上显示出来了。 二、ExtJS如何给textfield赋值的三个方法： var value=&quot;值&quot;; １、 fs.form.findField(id/name).setValue(value); ２、 Ext.get(id/name).setValue(value); ３、 Ext.getCmp(id).setValue(value); 三、Ext grid中得到选择行的方法 在Ext grid中假设有一个名称为grid的对象。 (1)grid.getStore().getRange(0,store.getCount());//得到grid所有的行 (2)grid.getSelectionModel().getSelections()//得到选择所有行 (3)grid.selModel.selections.items;//得到选择所有行 (4)grid.getSelectionModel().getSelected();//得到选择行的第一行 四、formPanel组件load数据时combo的自动赋值 combo有个hiddenName这个属*，这个属性是真正提交的值，在加载的时候你将这个属性的设置到reader中,就可以自动选择到指定的值了，比如说：hiddenName:’value’,那么你的reader中就应该有一个{name:’value’}. 五、ExtJS 重置表单的方法： 有三种方法能实现form表单的重置，假设var fs=new Ext.form.FormPanel({…});(1)fs.form.reset();//重置form(2)fs.getForm().getEl().dom.reset();//重置form(3)Ext.getCmp(‘fs’).form.reset();","tags":[{"name":"extjs","slug":"extjs","permalink":"http://yoursite.com/tags/extjs/"}]},{"title":"【Maven】Project configuration is not up-to-date with pom.xml错误解决方法","date":"2016-11-10T08:53:45.000Z","path":"2016/11/10/【Maven】Project-configuration-is-not-up-to-date-with-pom-xml错误解决方法/","text":"导入一个Maven项目之后发现有一个如下的错误：Project configuration is not up-to-date with pom.xml. Run project configuration update 其实这个问题解决非常简单：在项目上右键——【Maven】——【Update Project Configuration……】这时会打开一个（Update Maven Dependencies）的对话框，然后勾选住出错的项目，点击Ok这样就搞定了。","tags":[{"name":"maven","slug":"maven","permalink":"http://yoursite.com/tags/maven/"}]},{"title":"Tomcat报内存溢出","date":"2016-10-26T13:45:17.000Z","path":"2016/10/26/Tomcat报内存溢出/","text":"1、错误描述 严重：Exception occurred during processing request:null java.lang.reflect.InvocationTargetException. Caused by:java.lang.OutOfMemoryError:Java heap space. 2、错误原因 Tomcat在处理大数据时出现内存溢出 3、解决办法 编辑tomcat的catalina.bat文件，在第一行的后面增加一句： set JAVA_OPTS=-server -Xms512m -Xmx512m -XX:PermSize=128M -XX:MaxPermSize=256M","tags":[{"name":"tomcate","slug":"tomcate","permalink":"http://yoursite.com/tags/tomcate/"}]},{"title":"Docker的安装","date":"2016-10-26T12:44:32.000Z","path":"2016/10/26/Docker的安装/","text":"1，关于docker Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 摘自：http://dockerpool.com/static/books/docker_practice/introduction/what.html 2，安装centos 在使用virtualbox安装的时候需要把网络修改成【Bridged A’dapter】，方便获得上网ip，ssh连接到虚拟机。centos7 可以直接使用yum 安装docker最懒的方式，只是为了学习docker省去了折腾环境的麻烦。直接使用iso进行安装就行了。 3，安装docker 直接安装就可以了： yum install golang docker device-mapper-event-libs 必须安装 device-mapper-event-libs 否则docker启动不了，报错：Failed to start Docker Application Container Engine。配置&amp;启动服务 1:systemctl enable docker2:systemctl start docker docker服务就可以正常启动了。 4，docker hello world 虚拟安装一个MySQL，docker非常强大的时image。在官方搜索类库非常多。https://registry.hub.docker.com/search?q=librarydocker的注册中心，里面有很多做好的镜像库。mysql的安装：/mysql/”&gt;https://registry.hub.docker.com//mysql/ 安装mysql过程，设置数据库docker-mysql，版本5.5 1:# docker run –name docker-mysql -e MYSQL_ROOT_PASSWORD=docker-mysql -d mysql:5.52:Unable to find image ‘mysql:5.5’ locally3:Trying to pull repository docker.io/mysql …4:2f08318d65b3: Pulling dependent layers5:511136ea3c5a: Download complete6:4f903438061c: Download complete7:1265e16d0c28: Download complete8:ac1d5afd7b69: Download complete9:7c89455832dd: Downloading [===========================&gt; ] 4.434 MB/8.077 MB 34s 查看docker镜像： docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe59ad4702626 mysql:5.5 “/entrypoint.sh mysq 2 minutes ago Up 2 minutes 3306/tcp docker-mysql 查看mysql的docker服务器，直接登录到mysql容器，就安装好了mysql。同时服务也启动了，测试mysql docker启动成功。docker exec -it docker-mysql bash 1 docker exec -it docker-mysql bash2 root@e59ad4702626:/# mysql -uroot -pdocker-mysql3 Welcome to the MySQL monitor. Commands end with ; or \\g.4 Your MySQL connection id is 55 Server version: 5.5.43 MySQL Community Server (GPL)67 Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.89 Oracle is a registered trademark of Oracle Corporation and/or its10 affiliates. Other names may be trademarks of their respective11 owners.1213 Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the current input statement.1415 mysql&gt; show databases;16 +——————–+17 | Database |18 +——————–+19 | information_schema |20 | mysql |21 | performance_schema |22 +——————–+23 3 rows in set (0.00 sec)2425 mysql&gt; 同时这个是一个虚拟的服务器，上面安装的mysql。","tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"常用Git命令大全","date":"2016-09-21T13:04:33.000Z","path":"2016/09/21/常用Git命令大全/","text":"一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 十、其他 # 生成一个可供发布的压缩包 $ git archive","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"test","date":"2016-09-19T15:53:34.000Z","path":"2016/09/19/test/","text":"this is hexo test page","tags":[]}]