[{"title":"使用DaoCloud docker镜像加速器","date":"2018-01-10T06:10:46.000Z","path":"2018/01/10/使用DaoCloud docker镜像加速器/","text":"使用 Docker 的时候，需要经常从官方获取镜像，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用Docker的体验。由于国内访问直接访问dockerhub网速比较慢，拉取镜像的时间就会比较长，甚至下载失败。一般我们会使用镜像加速或者直接从国内的一些平台镜像仓库上拉取。我之前准备用阿里云的加速器的，试了好长时间没有成功，于是改用DaoCloud，下面向大家介绍在windows环境下使用docker toolbox来配置镜像加速器。在docker客户端执行如下命令 docker-machine ssh default sudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=加速地址 |g&quot; /var/lib/boot2docker/profile exit docker-machine restart default 1.使用docker客户端连接名为default的虚拟机2.配置DaoCloud加速器3.退出虚拟机到docker客户端4.名为default的虚拟机重启 如果你想在linux,MC上配置加速器，请参考配置 Docker 加速器","tags":[]},{"title":"Quartz学习——SSM和Quartz集成详解(四)","date":"2018-01-08T07:31:45.000Z","path":"2018/01/08/Quartz学习——SSM和Quartz集成详解-四/","text":"下面介绍SSM+Quartz的示例，项目地址: quartz-spring 一：环境介绍 123456工具：Spring Tool Suite + Mysql 框架：Spring+SpringMVC+Mybatis前端: easy ui 日志：logback 构建工具：Maven Quartz版本：2.2.3 二：SSM+Quartz集成详解1.项目结构 2.配置文件介绍（1）：在ApplicationContext.xml中添加下面的配置：123456&lt;bean name=&quot;quartzScheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;&lt;!-- 读取spring配置的数据库，不去加载quartz.properties --&gt; &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContextKey&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:quartz.properties&quot; /&gt;&lt;/bean&gt; （2）：添加quartz.properties配置文件12345678910111213141516171819202122232425# Default Properties file for use by StdSchedulerFactory # to create a Quartz Scheduler Instance, if a different # properties file is not explicitly specified. # org.quartz.scheduler.instanceName: DefaultQuartzScheduler#org.quartz.scheduler.instanceId = AUTO org.quartz.scheduler.rmi.export: false org.quartz.scheduler.rmi.proxy: false org.quartz.scheduler.wrapJobExecutionInUserTransaction: false org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool org.quartz.threadPool.threadCount: 10 org.quartz.threadPool.threadPriority: 5 org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true #持久化配置org.quartz.jobStore.misfireThreshold: 60000 org.quartz.jobStore.class: org.quartz.impl.jdbcjobstore.JobStoreTX org.quartz.jobStore.driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate org.quartz.jobStore.useProperties:true #指定前缀org.quartz.jobStore.tablePrefix: QRTZ_ 3.核心代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238package com.wyj.controller;import java.util.ArrayList;import java.util.List;import java.util.Set;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.commons.lang.StringUtils;import org.quartz.CronTrigger;import org.quartz.JobDataMap;import org.quartz.JobDetail;import org.quartz.JobKey;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.Trigger;import org.quartz.TriggerKey;import org.quartz.impl.matchers.GroupMatcher;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import com.alibaba.fastjson.JSON;import com.wyj.entity.JobDto;import com.wyj.entity.Retval;import com.wyj.service.QuartzService;/** * 定时任务 Controller * * * @author：WangYuanJun * @date：2018年1月7日 下午10:15:33 */@Controller@RequestMapping(value = &quot;/quartz&quot;)public class QuartzController &#123; private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private Scheduler quartzScheduler; @Autowired private QuartzService quartzService; @RequestMapping(&quot;/index&quot;) public String index() &#123; return &quot;/quartz/list&quot;; &#125; /** * 定时列表页 * * @return * @throws SchedulerException */ @ResponseBody @RequestMapping(value = &quot;/list&quot;) public String listJob(HttpServletRequest request, HttpServletResponse response) throws SchedulerException &#123; List&lt;JobDto&gt; jobInfos = this.getSchedulerJobInfo(); return JSON.toJSONString(jobInfos); &#125; /** * 新建job * * @param jobDto * @return */ @ResponseBody @RequestMapping(value = &quot;/add&quot;) public Retval save(JobDto jobDto) &#123; Retval retval = Retval.newInstance(); try &#123; quartzService.addJob(jobDto.getJobName(), jobDto.getJobGroupName(), jobDto.getTriggerName(), jobDto.getTriggerGroupName(), Class.forName(jobDto.getJobClass()), jobDto.getCronExpression()); &#125; catch (Exception e) &#123; logger.error(e.getMessage()); &#125; return retval; &#125; /** * 编辑job * * @param jobDto * @return */ @ResponseBody @RequestMapping(value = &quot;/edit&quot;, method = RequestMethod.POST) public Retval edit(JobDto jobDto) &#123; Retval retval = Retval.newInstance(); try &#123; boolean result = quartzService.modifyJobTime(jobDto.getOldJobName(), jobDto.getOldJobGroupName(), jobDto.getOldTriggerName(), jobDto.getOldTriggerGroupName(), jobDto.getJobName(), jobDto.getJobGroupName(), jobDto.getTriggerName(), jobDto.getTriggerGroupName(), jobDto.getCronExpression()); if (result) &#123; retval.put(&quot;message&quot;, &quot;修改任务成功!&quot;); &#125; else &#123; retval.put(&quot;message&quot;, &quot;修改任务失败!&quot;); &#125; &#125; catch (Exception e) &#123; logger.error(e.getMessage()); &#125; return retval; &#125; /** * 暂停job * * @param jobName * @param jobGroupName * @return */ @ResponseBody @RequestMapping(value = &quot;/stopJob&quot;, method = RequestMethod.POST) public Retval stopJob(@RequestParam(&quot;jobName&quot;) String jobName, @RequestParam(&quot;jobGroupName&quot;) String jobGroupName) &#123; Retval retval = Retval.newInstance(); if (StringUtils.isEmpty(jobName) || StringUtils.isEmpty(jobGroupName)) &#123; retval.fail(); retval.put(&quot;message&quot;, &quot;暂停失败&quot;); &#125; else &#123; try &#123; quartzService.pauseJob(jobName, jobGroupName); retval.put(&quot;message&quot;, &quot;暂停成功&quot;); &#125; catch (Exception e) &#123; logger.error(e.getMessage()); &#125; &#125; return retval; &#125; /** * 恢复job * * @param jobName * @param jobGroupName * @return */ @ResponseBody @RequestMapping(value = &quot;/resumeJob&quot;, method = RequestMethod.POST) public Retval resumeJob(@RequestParam(&quot;jobName&quot;) String jobName, @RequestParam(&quot;jobGroupName&quot;) String jobGroupName) &#123; Retval retval = Retval.newInstance(); if (StringUtils.isEmpty(jobName) || StringUtils.isEmpty(jobGroupName)) &#123; retval.fail(); retval.put(&quot;message&quot;, &quot;恢复失败&quot;); &#125; else &#123; try &#123; quartzService.resumeJob(jobName, jobGroupName); retval.put(&quot;message&quot;, &quot;恢复成功&quot;); &#125; catch (Exception e) &#123; logger.error(e.getMessage()); &#125; &#125; return retval; &#125; /** * 删除job * * @param jobName * @param jobGroupName * @param triggerName * @param triggerGroupName * @return */ @RequestMapping(value = &quot;/deleteJob&quot;, method = RequestMethod.POST) @ResponseBody public Retval deleteJob(@RequestParam(&quot;jobName&quot;) String jobName, @RequestParam(&quot;jobGroupName&quot;) String jobGroupName, @RequestParam(&quot;triggerName&quot;) String triggerName, @RequestParam(&quot;triggerGroupName&quot;) String triggerGroupName) &#123; Retval retval = Retval.newInstance(); if (StringUtils.isEmpty(jobName) || StringUtils.isEmpty(jobGroupName) || StringUtils.isEmpty(triggerName) || StringUtils.isEmpty(triggerGroupName)) &#123; retval.fail(); retval.put(&quot;message&quot;, &quot;删除失败&quot;); &#125; else &#123; try &#123; quartzService.removeJob(jobName, jobGroupName, triggerName, triggerGroupName); retval.put(&quot;message&quot;, &quot;删除成功&quot;); &#125; catch (Exception e) &#123; logger.error(e.getMessage()); &#125; &#125; return retval; &#125; private List&lt;JobDto&gt; getSchedulerJobInfo() throws SchedulerException &#123; List&lt;JobDto&gt; jobInfos = new ArrayList&lt;JobDto&gt;(); List&lt;String&gt; triggerGroupNames = quartzScheduler.getTriggerGroupNames(); for (String triggerGroupName : triggerGroupNames) &#123; Set&lt;TriggerKey&gt; triggerKeySet = quartzScheduler.getTriggerKeys(GroupMatcher.triggerGroupEquals(triggerGroupName)); for (TriggerKey triggerKey : triggerKeySet) &#123; Trigger t = quartzScheduler.getTrigger(triggerKey); if (t instanceof CronTrigger) &#123; CronTrigger trigger = (CronTrigger) t; JobKey jobKey = trigger.getJobKey(); JobDetail jd = quartzScheduler.getJobDetail(jobKey); JobDto jobInfo = new JobDto(); jobInfo.setJobName(jobKey.getName()); jobInfo.setJobGroupName(jobKey.getGroup()); jobInfo.setTriggerName(triggerKey.getName()); jobInfo.setTriggerGroupName(triggerKey.getGroup()); jobInfo.setCronExpression(trigger.getCronExpression()); jobInfo.setNextFireTime(trigger.getNextFireTime()); jobInfo.setPreviousFireTime(trigger.getPreviousFireTime()); jobInfo.setStartTime(trigger.getStartTime()); jobInfo.setEndTime(trigger.getEndTime()); jobInfo.setJobClass(jd.getJobClass().getCanonicalName()); // jobInfo.setDuration(Long.parseLong(jd.getDescription())); Trigger.TriggerState triggerState = quartzScheduler.getTriggerState(trigger.getKey()); jobInfo.setJobStatus(triggerState.toString());// NONE无, // NORMAL正常, // PAUSED暂停, // COMPLETE完全, // ERROR错误, // BLOCKED阻塞 JobDataMap map = quartzScheduler.getJobDetail(jobKey).getJobDataMap(); if (null != map &amp;&amp; map.size() != 0) &#123; jobInfo.setCount(Long.valueOf((String) map.get(&quot;count&quot;))); jobInfo.setJobDataMap(map); &#125; else &#123; jobInfo.setJobDataMap(new JobDataMap()); &#125; jobInfos.add(jobInfo); &#125; &#125; &#125; return jobInfos; &#125;&#125; 4.job12345678910111213141516171819202122package com.wyj.job;import java.util.Date;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;/** * Job任务 * * * @author：WangYuanJun * @date：2018年1月5日 下午10:22:42 */public class HelloWorldJob implements Job &#123; @Override public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println(&quot;----hello world---&quot; + new Date()); &#125;&#125; 三：运行效果介绍","tags":[{"name":"quartz","slug":"quartz","permalink":"http://wangyuanjun.cn/tags/quartz/"}]},{"title":"Quartz学习——Spring和Quartz集成详解(三)","date":"2018-01-08T06:46:30.000Z","path":"2018/01/08/Quartz学习——Spring和Quartz集成详解-三/","text":"下面介绍Spring集成Quartz的示例，项目地址: quartz-spring介绍Spring和Quartz集成存储方式使用的是RAM方式和JDBC方式！ jar包依赖&lt;properties&gt; &lt;!-- 项目构建源码编码方式 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;!-- 主要依赖库的版本定义 --&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.0.2.RELEASE&lt;/spring.version&gt; &lt;!-- 日志文件管理包版本 --&gt; &lt;slf4j.version&gt;1.7.7&lt;/slf4j.version&gt; &lt;junit.version&gt;4.11&lt;/junit.version&gt; &lt;jackson.version&gt;2.4.0&lt;/jackson.version&gt; &lt;mysql.version&gt;5.1.30&lt;/mysql.version&gt; &lt;quartz.version&gt;2.2.3&lt;/quartz.version&gt; &lt;fastjson.version&gt;1.1.41&lt;/fastjson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- spring核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 导入java ee jar 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- JSTL标签类 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志文件管理包 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.logback-extensions&lt;/groupId&gt; &lt;artifactId&gt;logback-ext-spring&lt;/artifactId&gt; &lt;version&gt;0.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 代码直接调用commons-logging会被桥接到slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 代码直接调用java.util.logging会被桥接到slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jul-to-slf4j&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 格式化对象，方便输出日志 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;${fastjson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit.version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 导入Mysql数据库链接jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- velocity --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity&lt;/artifactId&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-tools&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON begin --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-jaxb-annotations&lt;/artifactId&gt; &lt;version&gt;${jackson.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- freemarker --&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.27-incubating&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;${quartz.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;${quartz.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 配置文件spring-quartz.xmlRAM存储方式的xml配置文件（1）：配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- ====================================RAM版============================================== --&gt; &lt;!-- Spring整合Quartz进行配置遵循下面的步骤： 1：定义工作任务的Job 2：定义触发器Trigger，并将触发器与工作任务绑定 3：定义调度器，并将Trigger注册到Scheduler --&gt; &lt;!-- 1：定义任务的bean ，这里使用JobDetailFactoryBean,也可以使用MethodInvokingJobDetailFactoryBean ，配置类似--&gt; &lt;bean name=&quot;hwJob&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt; &lt;!-- 指定job的名称 --&gt; &lt;property name=&quot;name&quot; value=&quot;hw_job&quot;/&gt; &lt;!-- 指定job的分组 --&gt; &lt;property name=&quot;group&quot; value=&quot;hw_group&quot;/&gt; &lt;!-- 指定具体的job类 --&gt; &lt;property name=&quot;jobClass&quot; value=&quot;com.wyj.exampleRAM.RAMJob&quot;/&gt; &lt;!-- 必须设置为true，如果为false，当没有活动的触发器与之关联时会在调度器中会删除该任务 --&gt; &lt;property name=&quot;durability&quot; value=&quot;true&quot;/&gt; &lt;!-- 指定spring容器的key，如果不设定在job中的jobmap中是获取不到spring容器的 --&gt; &lt;property name=&quot;applicationContextJobDataKey&quot; value=&quot;applicationContext&quot;/&gt; &lt;/bean&gt; &lt;!-- 2.1：定义触发器的bean，定义一个Simple的Trigger，一个触发器只能和一个任务进行绑定 --&gt; &lt;!-- &lt;bean name=&quot;simpleTrigger&quot; class=&quot;org.springframework.scheduling.quartz.SimpleTriggerFactoryBean&quot;&gt; 指定Trigger的名称 &lt;property name=&quot;name&quot; value=&quot;hw_trigger&quot;/&gt; 指定Trigger的名称 &lt;property name=&quot;group&quot; value=&quot;hw_trigger_group&quot;/&gt; 指定Tirgger绑定的Job &lt;property name=&quot;jobDetail&quot; ref=&quot;hwJob&quot;/&gt; 指定Trigger的延迟时间 1s后运行 &lt;property name=&quot;startDelay&quot; value=&quot;1000&quot;/&gt; 指定Trigger的重复间隔 5s &lt;property name=&quot;repeatInterval&quot; value=&quot;5000&quot;/&gt; 指定Trigger的重复次数 &lt;property name=&quot;repeatCount&quot; value=&quot;5&quot;/&gt; &lt;/bean&gt; --&gt; &lt;!-- 2.2：定义触发器的bean，定义一个Cron的Trigger，一个触发器只能和一个任务进行绑定 --&gt; &lt;bean id=&quot;cronTrigger&quot; class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt; &lt;!-- 指定Trigger的名称 --&gt; &lt;property name=&quot;name&quot; value=&quot;hw_trigger&quot;/&gt; &lt;!-- 指定Trigger的名称 --&gt; &lt;property name=&quot;group&quot; value=&quot;hw_trigger_group&quot;/&gt; &lt;!-- 指定Tirgger绑定的Job --&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;hwJob&quot;/&gt; &lt;!-- 指定Cron 的表达式 ，当前是每隔1s运行一次 --&gt; &lt;property name=&quot;cronExpression&quot; value=&quot;0/1 * * * * ?&quot; /&gt; &lt;/bean&gt; &lt;!-- 3.定义调度器，并将Trigger注册到调度器中--&gt; &lt;bean name=&quot;scheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt;&lt;!-- &lt;ref bean=&quot;simpleTrigger&quot;/&gt; --&gt; &lt;ref bean=&quot;cronTrigger&quot;/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; （2）：运行结果CronScheduleBuilder： JDBC存储方式的xml配置文件（1）：配置文件 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&gt; &lt;!-- ====================================JDBC版============================================== --&gt; &lt;!-- 持久化数据配置，需要添加quartz.properties --&gt; &lt;bean name=&quot;scheduler&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContextKey&quot;/&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:quartz.properties&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; （2）：quartz.properties123456789101112131415161718192021222324252627282930313233343536# Default Properties file for use by StdSchedulerFactory # to create a Quartz Scheduler Instance, if a different # properties file is not explicitly specified. # #org.quartz.scheduler.instanceName: DefaultQuartzScheduler org.quartz.scheduler.instanceName: DefaultQuartzScheduler#org.quartz.scheduler.instanceId = AUTO org.quartz.scheduler.rmi.export: false org.quartz.scheduler.rmi.proxy: false org.quartz.scheduler.wrapJobExecutionInUserTransaction: false org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool org.quartz.threadPool.threadCount: 10 org.quartz.threadPool.threadPriority: 5 org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true #创建数据源org.quartz.jobStore.misfireThreshold: 60000 #JDBC连接方式org.quartz.jobStore.class: org.quartz.impl.jdbcjobstore.JobStoreTX #JDBC代理类 org.quartz.jobStore.driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate org.quartz.jobStore.useProperties:true #指定前缀org.quartz.jobStore.tablePrefix: QRTZ_#数据源名称org.quartz.jobStore.dataSource: qzDS #配置数据源属性 org.quartz.dataSource.qzDS.driver:com.mysql.jdbc.Driverorg.quartz.dataSource.qzDS.URL:jdbc:mysql://192.168.99.100:3306/quartz_test?useUnicode=true&amp;characterEncoding=utf-8org.quartz.dataSource.qzDS.user:rootorg.quartz.dataSource.qzDS.password:adminorg.quartz.dataSource.qzDS.maxConnections:10 （3）：job123456789101112131415161718192021222324252627282930313233package com.wyj.exampleJDBC;import java.text.SimpleDateFormat;import java.util.Date;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * JdbcJob * * * @author：WangYuanJun * @date：2017年12月29日 下午10:05:18 */public class JdbcJob implements Job&#123; private Logger logger = LoggerFactory.getLogger(JdbcJob.class); public void execute(JobExecutionContext arg0) throws JobExecutionException &#123; logger.debug(&quot;MyJDBCJob is start ...&quot;); logger.debug(&quot;MyJDBCJob quzrtz &quot;+new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss &quot;).format(new Date())); logger.debug(&quot;MyJDBCJob is end ...&quot;); &#125; &#125; （4）：jobTest123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109package com.wyj.exampleJDBC;import java.util.List;import org.quartz.CronScheduleBuilder;import org.quartz.CronTrigger;import org.quartz.JobBuilder;import org.quartz.JobDetail;import org.quartz.JobKey;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.SchedulerFactory;import org.quartz.SimpleScheduleBuilder;import org.quartz.SimpleTrigger;import org.quartz.Trigger;import org.quartz.TriggerBuilder;import org.quartz.impl.StdScheduler;import org.quartz.impl.StdSchedulerFactory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * JdbcJobtest * * * @author：WangYuanJun * @date：2017年12月29日 下午10:05:26 */public class QuartzJdbcTest &#123; private static Scheduler scheduler; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;spring-quartz.xml&quot;); scheduler = (StdScheduler)ac.getBean(&quot;scheduler&quot;); testStartSchedule(); &#125; /** * 开始一个simpleSchedule()调度 */ public static void testStartSchedule()&#123; try &#123; // 1、创建一个JobDetail实例，指定Quartz JobDetail jobDetail = JobBuilder.newJob(JdbcJob.class) // 任务执行类 .withIdentity(&quot;job_1&quot;, &quot;jGroup1&quot;)// 任务名，任务组 .build(); //触发器类型 //SimpleScheduleBuilder builder = SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForTotalCount(5); // 设置执行次数 CronScheduleBuilder builder = CronScheduleBuilder.cronSchedule(&quot;0/2 * * * * ?&quot;); // 2、创建Trigger Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(&quot;trigger_1&quot;,&quot;triggerGroup1&quot;) .withSchedule(builder) .build(); // 3、创建Scheduler Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.start(); // 4、调度执行 scheduler.scheduleJob(jobDetail,trigger); try &#123; Thread.sleep(60000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //关闭调度器 scheduler.shutdown(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 从数据库中找到已经存在的job，并重新开户调度 */ public static void resumeJob()&#123; try &#123; SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); JobKey jobKey = new JobKey(&quot;job1_1&quot;, &quot;jGroup1&quot;); List&lt;? extends Trigger&gt; triggers = scheduler.getTriggersOfJob(jobKey); //SELECT TRIGGER_NAME, TRIGGER_GROUP FROM &#123;0&#125;TRIGGERS WHERE SCHED_NAME = &#123;1&#125; AND JOB_NAME = ? AND JOB_GROUP = ? // 重新恢复在jGroup1组中，名为job1_1的 job的触发器运行 if(triggers.size() &gt; 0)&#123; for (Trigger tg : triggers) &#123; // 根据类型判断 if ((tg instanceof CronTrigger) || (tg instanceof SimpleTrigger)) &#123; // 恢复job运行 scheduler.resumeJob(jobKey); &#125; &#125; scheduler.start(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果：CronScheduleBuilder：","tags":[{"name":"quartz","slug":"quartz","permalink":"http://wangyuanjun.cn/tags/quartz/"}]},{"title":"Quartz学习——Quartz简单入门Demo(二)","date":"2018-01-03T07:50:18.000Z","path":"2018/01/03/Quartz学习——Quartz简单入门Demo-二/","text":"下面介绍Quartz入门的示例，项目地址: quartz-demo由于Quartz的存储方式分为RAM和JDBC，分别对这两种进行简单的说明。并附上代码！首先需要添加Quartz的依赖 ，我使用的是quartz.2.2.3版本！ &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.2.3&lt;/version&gt; &lt;/dependency&gt; RAM方式要测试RAMdemo的代码，请先删除demo中这个quartz.properties文件，或者重命名！否则会测试不成功！（1）：Job package com.wyj.exampleRAM; import java.util.Date; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * RAMjob * * * @author：WangYuanJun * @date：2017年12月28日 下午10:03:31 */ public class RAMJob implements Job{ private Logger logger = LoggerFactory.getLogger(RAMJob.class); public void execute(JobExecutionContext arg0) throws JobExecutionException { logger.debug(&quot;hello world ! hello Quartz - &quot;+new Date()); } } （2）：JobTest package com.wyj.exampleRAM; import java.util.Date; import org.quartz.CronScheduleBuilder; import org.quartz.JobBuilder; import org.quartz.JobDetail; import org.quartz.Scheduler; import org.quartz.SchedulerException; import org.quartz.SchedulerFactory; import org.quartz.Trigger; import org.quartz.TriggerBuilder; import org.quartz.impl.StdSchedulerFactory; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * RAMtest * * * @author：WangYuanJun * @date：2017年12月28日 下午10:03:50 */ public class RAMQuartzTest { private static Logger logger = LoggerFactory.getLogger(RAMJob.class); public static void main(String[] args) throws SchedulerException { //1.创建Scheduler的工厂 SchedulerFactory sf = new StdSchedulerFactory(); //2.从工厂中获取调度器实例 Scheduler scheduler = sf.getScheduler(); //3.创建JobDetail JobDetail jb = JobBuilder.newJob(RAMJob.class) .withDescription(&quot;this is hello job&quot;)//job的描述 .withIdentity(&quot;helloJob&quot;, &quot;helloGroup&quot;)//job 的name和group .build(); //任务运行的时间，SimpleSchedle类型触发器有效 long time= System.currentTimeMillis() + 3*1000L; //3秒后启动任务 Date statTime = new Date(time); //4.创建Trigger //使用SimpleScheduleBuilder或者CronScheduleBuilder Trigger trigger = TriggerBuilder.newTrigger() .withDescription(&quot;&quot;) .withIdentity(&quot;helloTrigger&quot;, &quot;helloTriggerGroup&quot;) .startAt(statTime)//默认当前时间启动 .withSchedule(CronScheduleBuilder.cronSchedule(&quot;0/2 * * * * ?&quot;))//两秒执行一次 .build(); //5.注册任务和定时器 scheduler.scheduleJob(jb, trigger); //6.启动 调度器 scheduler.start(); logger.debug(&quot;启动时间 ：&quot;+new Date()); } } 运行结果：SimpleScheduleBuilder： CronScheduleBuilder： JDBC方式使用jdbc方式，就要配置quartz.properties文件，并且在开始的时候在数据库中新增表！我使用的数据库是mysql，数据库中表在wyj-quartz-demo项目里面有，需要的请在里面下载！运行 tables_mysql.sql 这个文件。 #配置数据源属性 org.quartz.dataSource.qzDS.driver:com.mysql.jdbc.Driver org.quartz.dataSource.qzDS.URL:jdbc:mysql://192.168.99.100:3306/quartz_test?useUnicode=true&amp;characterEncoding=utf-8 org.quartz.dataSource.qzDS.user:root org.quartz.dataSource.qzDS.password:admin org.quartz.dataSource.qzDS.maxConnections:10 （1）job package com.wyj.exampleJDBC; import java.text.SimpleDateFormat; import java.util.Date; import org.quartz.Job; import org.quartz.JobExecutionContext; import org.quartz.JobExecutionException; import org.slf4j.Logger; import org.slf4j.LoggerFactory; /** * JdbcJob * * * @author：WangYuanJun * @date：2017年12月28日 下午10:04:03 */ public class JdbcJob implements Job{ private Logger logger = LoggerFactory.getLogger(JdbcJob.class); public void execute(JobExecutionContext arg0) throws JobExecutionException { logger.debug(&quot;MyJDBCJob is start ...&quot;); logger.debug(&quot;MyJDBCJob quzrtz &quot;+new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss &quot;).format(new Date())); logger.debug(&quot;MyJDBCJob is end ...&quot;); } } （2）jobTest package com.wyj.exampleJDBC; import java.util.List; import org.quartz.CronScheduleBuilder; import org.quartz.CronTrigger; import org.quartz.JobBuilder; import org.quartz.JobDetail; import org.quartz.JobKey; import org.quartz.Scheduler; import org.quartz.SchedulerFactory; import org.quartz.SimpleTrigger; import org.quartz.Trigger; import org.quartz.TriggerBuilder; import org.quartz.impl.StdSchedulerFactory; /** * JdbcJobtest * * * @author：WangYuanJun * @date：2017年12月28日 下午10:04:14 */ public class QuartzJdbcTest { public static void main(String[] args) { testStartSchedule(); // resumeJob(); } /** * 开始一个simpleSchedule()调度 */ public static void testStartSchedule(){ try { // 1、创建一个JobDetail实例，指定Quartz JobDetail jobDetail = JobBuilder.newJob(JdbcJob.class) // 任务执行类 .withIdentity(&quot;job_1&quot;, &quot;jGroup1&quot;)// 任务名，任务组 .build(); //触发器类型 // SimpleScheduleBuilder builder = SimpleScheduleBuilder.simpleSchedule().repeatSecondlyForTotalCount(5); // 设置执行次数 CronScheduleBuilder builder = CronScheduleBuilder.cronSchedule(&quot;0/2 * * * * ?&quot;); // 2、创建Trigger Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(&quot;trigger_1&quot;,&quot;triggerGroup1&quot;) .withSchedule(builder) .build(); // 3、创建Scheduler Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); scheduler.start(); // 4、调度执行 scheduler.scheduleJob(jobDetail,trigger); try { Thread.sleep(60000); } catch (Exception e) { e.printStackTrace(); } //关闭调度器 scheduler.shutdown(); } catch (Exception e) { e.printStackTrace(); } } /** * 从数据库中找到已经存在的job，并重新开户调度 */ public static void resumeJob(){ try { SchedulerFactory schedulerFactory = new StdSchedulerFactory(); Scheduler scheduler = schedulerFactory.getScheduler(); JobKey jobKey = new JobKey(&quot;job1_1&quot;, &quot;jGroup1&quot;); List&lt;? extends Trigger&gt; triggers = scheduler.getTriggersOfJob(jobKey); //SELECT TRIGGER_NAME, TRIGGER_GROUP FROM {0}TRIGGERS WHERE SCHED_NAME = {1} AND JOB_NAME = ? AND JOB_GROUP = ? // 重新恢复在jGroup1组中，名为job1_1的 job的触发器运行 if(triggers.size() &gt; 0){ for (Trigger tg : triggers) { // 根据类型判断 if ((tg instanceof CronTrigger) || (tg instanceof SimpleTrigger)) { // 恢复job运行 scheduler.resumeJob(jobKey); } } scheduler.start(); } } catch (Exception e) { e.printStackTrace(); } } } 运行结果：数据库信息： 控制台信息： 注意:Cron和Simple类型，Simple类型的如果JobDetail没有设置.storeDurably(true)，则job在运行完成之后会在数据库中删除！","tags":[{"name":"quartz","slug":"quartz","permalink":"http://wangyuanjun.cn/tags/quartz/"}]},{"title":"Docker之创建并进入mysql容器","date":"2018-01-03T02:11:52.000Z","path":"2018/01/03/Docker之创建并进入mysql容器/","text":"本文介绍docker如何创建并进入MYSQL容器。 运行”docker pull mysql”获取mysql镜像[root@localhost ~]# docker pull mysql Using default tag: latest latest: Pulling from library/mysql 85b1f47fba49: Pull complete 5671503d4f93: Pull complete 3b43b3b913cb: Pull complete 4fbb803665d0: Pull complete 05808866e6f9: Pull complete 1d8c65d48cfa: Pull complete e189e187b2b5: Pull complete 02d3e6011ee8: Pull complete d43b32d5ce04: Pull complete 2a809168ab45: Pull complete Digest: sha256:1a2f9361228e9b10b4c77a651b460828514845dc7ac51735b919c2c4aec864b7 Status: Downloaded newer image for mysql:latest 在后台启动mysql容器(–name指定了容器的名称，方便之后进入容器的命令行，MYSQL_ROOT_PASSWORD=admin指定了mysql的root密码，-d表示在后台运行)Administrator@SKY-20170607FIJ MINGW64 ~ $ docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=admin -d mysql c6215e8c1fd73bc395a0c92e93f7e7145baedbe99c7ff639ccc9f5641bddf583 进入容器bash并进入mysql命令行：Administrator@SKY-20170607FIJ MINGW64 ~ $ docker exec -it mysql bash root@c6215e8c1fd7:/# mysql -uroot -padmin mysql: [Warning] Using a password on the command line interface can be insecure. Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 5 Server version: 5.7.20 MySQL Community Server (GPL) Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type &apos;help;&apos; or &apos;\\h&apos; for help. Type &apos;\\c&apos; to clear the current input statement. mysql&gt; show databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | sys | +--------------------+ 4 rows in set (0.00 sec) mysql&gt; 退出mysql镜像输入 exit","tags":[{"name":"docker","slug":"docker","permalink":"http://wangyuanjun.cn/tags/docker/"}]},{"title":"常用mysql命令大全","date":"2018-01-03T01:40:56.000Z","path":"2018/01/03/常用mysql命令大全/","text":"1、连接Mysql格式： mysql -h主机地址 -u用户名 －p用户密码 1、连接到本机上的MYSQL。首先打开DOS窗口，然后进入目录mysql\\bin，再键入命令mysql -u root -p，回车后提示你输密码.注意用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码。 如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt; 2、连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令： mysql -h110.110.110.110 -u root -p 123;（注:u与root之间可以不用加空格，其它也一样） 3、退出MYSQL命令exit （回车） 2、修改密码格式：mysqladmin -u用户名 -p旧密码 password 新密码 1、给root加个密码ab12。首先在DOS下进入目录mysql\\bin，然后键入以下命令 mysqladmin -u root -password ab12 注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。 2、再将root的密码改为djg345。mysqladmin -u root -p ab12 password djg345 3、增加新用户注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符 格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码” 1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：grant select,insert,update,delete on *.* to [email=test1@”%]test1@”%[/email]” Identified by “abc”; 但增加的用户是十分危险的，你想如某个人知道test1的密码，那么他就可以在internet上的任何一台电脑上登录你的mysql数据库并对你的数据可以为所欲为了，解决办法见2。 2、增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机），这样用户即使用知道test2的密码，他也无法从internet上直接访问数据库，只能通过MYSQL主机上的web页来访问了。grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “abc”; 如果你不想test2有密码，可以再打一个命令将密码消掉。 grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “”; 4 数据库4.1 创建数据库注意：创建数据库之前要先连接Mysql服务器 命令：create database &lt;数据库名&gt; 例1：建立一个名为xhkdb的数据库 mysql&gt; create database xhkdb; 例2：创建数据库并分配用户 ①CREATE DATABASE 数据库名; ②GRANT SELECT,INSERT,UPDATE,DELETE,CREATE,DROP,ALTER ON 数据库名.* TO 数据库名@localhost IDENTIFIED BY ‘密码’; ③SET PASSWORD FOR ‘数据库名’@’localhost’ = OLD_PASSWORD(‘密码’); 依次执行3个命令完成数据库创建。注意：中文 “密码”和“数据库”是户自己需要设置的。 4.2 显示数据库命令：show databases （注意：最后有个s） mysql&gt; show databases; 注意：为了不再显示的时候乱码，要修改数据库默认编码。以下以GBK编码页面为例进行说明： 1、修改MYSQL的配置文件：my.ini里面修改default-character-set=gbk2、代码运行时修改： ①Java代码：jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=gbk ②PHP代码：header(“Content-Type:text/html;charset=gb2312”); ③C语言代码：int mysql_set_character_set( MYSQL mysql, char csname)；该函数用于为当前连接设置默认的字符集。字符串csname指定了1个有效的字符集名称。连接校对成为字符集的默认校对。该函数的工作方式与SET NAMES语句类似，但它还能设置mysql- &gt; charset的值，从而影响了由mysql_real_escape_string() 设置的字符集。 4.3 删除数据库命令：drop database &lt;数据库名&gt;例如：删除名为 xhkdb的数据库 mysql&gt; drop database xhkdb; 例子1：删除一个已经确定存在的数据库 mysql&gt; drop database drop_database; Query OK, 0 rows affected (0.00 sec) 例子2：删除一个不确定存在的数据库 mysql&gt; drop database drop_database; ERROR 1008 (HY000): Can’t drop database ‘drop_database’; database doesn’t exist //发生错误，不能删除’drop_database’数据库，该数据库不存在。 mysql&gt; drop database if exists drop_database; Query OK, 0 rows affected, 1 warning (0.00 sec)//产生一个警告说明此数据库不存在 mysql&gt; create database drop_database; Query OK, 1 row affected (0.00 sec) mysql&gt; drop database if exists drop_database;//if exists 判断数据库是否存在，不存在也不产生错误 Query OK, 0 rows affected (0.00 sec) 4.4 连接数据库命令： use &lt;数据库名&gt; 例如：如果xhkdb数据库存在，尝试存取它： mysql&gt; use xhkdb; 屏幕提示：Database changed use 语句可以通告MySQL把db_name数据库作为默认（当前）数据库使用，用于后续语句。该数据库保持为默认数据库，直到语段的结尾，或者直到发布一个不同的USE语句： mysql&gt; USE db1; mysql&gt; SELECT COUNT() FROM mytable; # selects from db1.mytable mysql&gt; USE db2; mysql&gt; SELECT COUNT() FROM mytable; # selects from db2.mytable 使用USE语句为一个特定的当前的数据库做标记，不会阻碍您访问其它数据库中的表。下面的例子可以从db1数据库访问作者表，并从db2数据库访问编辑表： mysql&gt; USE db1; mysql&gt; SELECT author_name,editor_name FROM author,db2.editor -&gt; WHERE author.editor_id = db2.editor.editor_id; USE语句被设立出来，用于与Sybase相兼容。 有些网友问到，连接以后怎么退出。其实，不用退出来，use 数据库后，使用show databases就能查询所有数据库，如果想跳到其他数据库，用 use 其他数据库名字就可以了。 4.5 当前选择的数据库命令：mysql&gt; select database(); MySQL中SELECT命令类似于其他编程语言里的print或者write，你可以用它来显示一个字符串、数字、数学表达式的结果等等。如何使用MySQL中SELECT命令的特殊功能？ 1.显示MYSQL的版本 mysql&gt; select version(); +-----------------------+ | version() | +-----------------------+ | 6.0.4-alpha-community | +-----------------------+ 1 row in set (0.02 sec) 2.显示当前时间 mysql&gt; select now(); +---------------------+ | now() | +---------------------+ | 2009-09-15 22:35:32 | +---------------------+ 1 row in set (0.04 sec) 3.显示年月日 SELECT DAYOFMONTH(CURRENT_DATE); +--------------------------+ | DAYOFMONTH(CURRENT_DATE) | +--------------------------+ | 15 | +--------------------------+ 1 row in set (0.01 sec) SELECT MONTH(CURRENT_DATE); +---------------------+ | MONTH(CURRENT_DATE) | +---------------------+ | 9 | +---------------------+ 1 row in set (0.00 sec) SELECT YEAR(CURRENT_DATE); +--------------------+ | YEAR(CURRENT_DATE) | +--------------------+ | 2009 | +--------------------+ 1 row in set (0.00 sec) 4.显示字符串 mysql&gt; SELECT &quot;welecome to my blog!&quot;; +----------------------+ | welecome to my blog! | +----------------------+ | welecome to my blog! | +----------------------+ 1 row in set (0.00 sec) 5.当计算器用 select ((4 * 4) / 10 ) + 25; +----------------------+ | ((4 * 4) / 10 ) + 25 | +----------------------+ | 26.60 | +----------------------+ 1 row in set (0.00 sec) 6.串接字符串 select CONCAT(f_name, &quot; &quot;, l_name) AS Name from employee_data where title = &apos;Marketing Executive&apos;; +---------------+ | Name | +---------------+ | Monica Sehgal | | Hal Simlai | | Joseph Irvine | +---------------+ 3 rows in set (0.00 sec) 注意：这里用到CONCAT()函数，用来把字符串串接起来。另外，我们还用到以前学到的AS给结果列’CONCAT(f_name, “ “, l_name)’起了个假名。 5 数据库表5.1 创建数据表命令：create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); 例如，建立一个名为MyClass的表，字段名 数字类型 数据宽度 是否为空 是否主键 自动增加 默认值id int 4 否 primary key auto_incrementname char 20 否sex int 4 否 0degree double 16 是 mysql&gt; create table MyClass( &gt; id int(4) not null primary key auto_increment, &gt; name char(20) not null, &gt; sex int(4) not null default &apos;0&apos;, &gt; degree double(16,2)); 5.2 删除数据表命令：drop table &lt;表名&gt; 例如：删除表名为 MyClass 的表 mysql&gt; drop table MyClass; DROP TABLE用于取消一个或多个表。您必须有每个表的DROP权限。所有的表数据和表定义会被取消，所以使用本语句要小心！ 注意：对于一个带分区的表，DROP TABLE会永久性地取消表定义，取消各分区，并取消储存在这些分区中的所有数据。DROP TABLE还会取消与被取消的表有关联的分区定义（.par）文件。 对与不存在的表，使用IF EXISTS用于防止错误发生。当使用IF EXISTS时，对于每个不存在的表，会生成一个NOTE。 RESTRICT和CASCADE可以使分区更容易。目前，RESTRICT和CASCADE不起作用。 5.3 表插入数据命令：insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )] 例如：往表 MyClass中插入二条记录, 这二条记录表示：编号为1的名为Tom的成绩为96.45, 编号为2 的名为Joan 的成绩为82.99， 编号为3 的名为Wang 的成绩为96.5。 mysql&gt; insert into MyClass values(1,’Tom’,96.45),(2,’Joan’,82.99), (2,’Wang’, 96.59); 注意：insert into每次只能向表中插入一条记录。 5.4 查询表中的数据1)、查询所有行命令： select &lt;字段1，字段2，…&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt;例如：查看表 MyClass 中所有数据 mysql&gt; select * from MyClass; 2）、查询前几行数据例如：查看表 MyClass 中前2行数据 mysql&gt; select * from MyClass order by id limit 0,2; select一般配合where使用，以查询更精确更复杂的数据。 5.5 删除表中数据命令：delete from 表名 where 表达式 例如：删除表 MyClass中编号为1 的记录mysql&gt; delete from MyClass where id=1; 下面是一个删除数据前后表的对比。FirstName LastName AgePeter Griffin 35Glenn Quagmire 33下面以PHP代码为例删除 “Persons” 表中所有 LastName=’Griffin’ 的记录： &lt;?php $con = mysql_connect(&quot;localhost&quot;,&quot;peter&quot;,&quot;abc123&quot;); if (!$con) { die(&apos;Could not connect: &apos; . mysql_error()); } mysql_select_db(&quot;my_db&quot;, $con); mysql_query(&quot;DELETE FROM Persons WHERE LastName=&apos;Griffin&apos;&quot;); mysql_close($con); ?&gt; 在这次删除之后，表是这样的： FirstName LastName Age Glenn Quagmire 33 5.6 修改表中数据语法：update 表名 set 字段=新值,… where 条件 mysql&gt; update MyClass set name=&apos;Mary&apos; where id=1; 例子1：单表的MySQL UPDATE语句： UPDATE [LOW_PRIORITY] [IGNORE] tbl_name SET col_name1=expr1 [, col_name2=expr2 ...] [WHERE where_definition] [ORDER BY ...] [LIMIT row_count] 例子2：多表的UPDATE语句： UPDATE [LOW_PRIORITY] [IGNORE] table_references SET col_name1=expr1 [, col_name2=expr2 ...] [WHERE where_definition] UPDATE语法可以用新值更新原有表行中的各列。SET子句指示要修改哪些列和要给予哪些值。WHERE子句指定应更新哪些行。如果没有WHERE子句，则更新所有的行。如果指定了ORDER BY子句，则按照被指定的顺序对行进行更新。LIMIT子句用于给定一个限值，限制可以被更新的行的数目。 5.7 增加字段命令：alter table 表名 add字段 类型 其他;例如：在表MyClass中添加了一个字段passtest，类型为int(4)，默认值为0 mysql&gt; alter table MyClass add passtest int(4) default &apos;0&apos; 加索引 mysql&gt; alter table 表名 add index 索引名 (字段名1[，字段名2 …]); 例子： mysql&gt; alter table employee add index emp_name (name); 加主关键字的索引 mysql&gt; alter table 表名 add primary key (字段名); 例子： mysql&gt; alter table employee add primary key(id); 加唯一限制条件的索引 mysql&gt; alter table 表名 add unique 索引名 (字段名); 例子： mysql&gt; alter table employee add unique emp_name2(cardnumber); 删除某个索引 mysql&gt; alter table 表名 drop index 索引名; 例子： mysql&gt;alter table employee drop index emp_name; 增加字段： mysql&gt; ALTER TABLE table_name ADD field_name field_type; 修改原字段名称及类型： mysql&gt; ALTER TABLE table_name CHANGE old_field_name new_field_name field_type; 删除字段： MySQL ALTER TABLE table_name DROP field_name; 5.8 修改表名命令：rename table 原表名 to 新表名; 例如：在表MyClass名字更改为YouClass mysql&gt; rename table MyClass to YouClass; 当你执行 RENAME 时，你不能有任何锁定的表或活动的事务。你同样也必须有对原初表的 ALTER 和 DROP 权限，以及对新表的 CREATE 和 INSERT 权限。 如果在多表更名中，MySQL 遭遇到任何错误，它将对所有被更名的表进行倒退更名，将每件事物退回到最初状态。 RENAME TABLE 在 MySQL 3.23.23 中被加入。 6、备份数据库命令在DOS的[url=file://\\mysql\\bin]\\mysql\\bin[/url]目录下执行 1.导出整个数据库导出文件默认是存在mysql\\bin目录下 mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 2.导出一个表 mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 3.导出一个数据库结构 mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 4.带语言参数导出 mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 例如，将aaa库备份到文件back_aaa中： [root@test1 root]# cd /home/data/mysql [root@test1 mysql]# mysqldump -u root -p –opt aaa &gt; back_aaa 7.1 一个建库和建表的实例1drop database if exists school; //如果存在SCHOOL则删除 create database school; //建立库SCHOOL use school; //打开库SCHOOL create table teacher //建立表TEACHER ( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default ‘深圳’, year date ); //建表结束 //以下为插入字段 insert into teacher values(”,’allen’,&apos;大连一中’,&apos;1976-10-10′); insert into teacher values(”,’jack’,&apos;大连二中’,&apos;1975-12-23′); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。1、你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\\下，并在DOS状态进入目录[url=file://\\mysql\\bin]\\mysql\\bin[/url]，然后键入以下命令： mysql -uroot -p密码 &lt; c:\\\\school.sql 如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 2、或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 7.2 一个建库和建表的实例2drop database if exists school; //如果存在SCHOOL则删除 create database school; //建立库SCHOOL use school; //打开库SCHOOL create table teacher //建立表TEACHER ( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default &apos;&apos;深圳&apos;&apos;, year date ); //建表结束 //以下为插入字段 insert into teacher values(&apos;&apos;&apos;&apos;,&apos;&apos;glchengang&apos;&apos;,&apos;&apos;深圳一中&apos;&apos;,&apos;&apos;1976-10-10&apos;&apos;); insert into teacher values(&apos;&apos;&apos;&apos;,&apos;&apos;jack&apos;&apos;,&apos;&apos;深圳一中&apos;&apos;,&apos;&apos;1975-12-23&apos;&apos;); 注：在建表中1、将ID设为长度为3的数字字段:int(3)；并让它每个记录自动加一:auto_increment；并不能为空:not null；而且让他成为主字段primary key。 2、将NAME设为长度为10的字符字段 3、将ADDRESS设为长度50的字符字段，而且缺省值为深圳。 4、将YEAR设为日期字段。 转载:Mysql命令大全","tags":[{"name":"mysql","slug":"mysql","permalink":"http://wangyuanjun.cn/tags/mysql/"}]},{"title":"Dubbo学习——Dubbo介绍(一)","date":"2017-12-28T01:40:51.000Z","path":"2017/12/28/Dubbo学习——Dubbo介绍-一/","text":"","tags":[]},{"title":"Quartz学习———Quartz介绍(一)","date":"2017-12-27T15:02:10.000Z","path":"2017/12/27/Quartz学习——Quartz介绍-一/","text":"一：介绍Quartz是OpenSymphony开源组织在Job scheduling领域又一个开源项目，是完全由java开发的一个开源的任务日程管理系统，“任务进度管理器”就是一个在预先确定（被纳入日程）的时间到达时，负责执行（或者通知）其他软件组件的系统。Quartz用一个小Java库发布文件（.jar文件），这个库文件包含了所有Quartz核心功能。这些功能的主要接口(API)是Scheduler接口。它提供了简单的操作，例如：将任务纳入日程或者从日程中取消，开始/停止/暂停日程进度。 二：quartz核心概念先来看一张图： Job( 任务，即被调度的任务)：要由表示要执行的“作业”的类实现的接口。只有一个方法 void execute(jobExecutionContext context) (jobExecutionContext 提供调度上下文各种信息，运行时数据保存在jobDataMap中) Job有个子接口StatefulJob ,代表有状态任务。 JobDetail：Quartz在每次执行Job时，都重新创建一个Job实例，所以它不直接接受一个Job的实例，相反它接收一个Job实现类，以便运行时通过newInstance()的反射机制实例化Job。因此需要通过一个类来描述Job的实现类及其它相关的静态信息，如Job名字、描述、关联监听器等信息，JobDetail承担了这一角色。 传递给定作业实例的详细信息属性。 JobDetails将使用JobBuilder创建/定义。 Trigger(触发器)：用于定义任务调度时间规则。是一个类，描述触发Job执行的时间触发规则。使用TriggerBuilder实例化实际触发器。主要有SimpleTrigger和CronTrigger这两个子类。当仅需触发一次或者以固定时间间隔周期执行，SimpleTrigger是最适合的选择；而CronTrigger则可以通过Cron表达式定义出各种复杂时间规则的调度方案：如每早晨9:00执行，周一、周三、周五下午5:00执行等； Calendar：org.quartz.Calendar和java.util.Calendar不同，它是一些日历特定时间点的集合（可以简单地将org.quartz.Calendar看作java.util.Calendar的集合——java.util.Calendar代表一个日历时间点，无特殊说明后面的Calendar即指org.quartz.Calendar）。一个Trigger可以和多个Calendar关联，以便排除或包含某些时间点。假设，我们安排每周星期一早上10:00执行任务，但是如果碰到法定的节日，任务则不执行，这时就需要在Trigger触发机制的基础上使用Calendar进行定点排除。 Scheduler(任务调度器)：这是Quartz Scheduler的主要接口，代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。一旦注册，调度程序负责执行作业，当他们的相关联的触发器触发（当他们的预定时间到达时）。 QuartzSchedulerThread ：负责执行向QuartzScheduler注册的触发Trigger的工作的线程。 ThreadPool：Scheduler使用一个线程池作为任务运行的基础设施，任务通过共享线程池中的线程提供运行效率。 QuartzSchedulerResources：包含创建QuartzScheduler实例所需的所有资源（JobStore，ThreadPool等）。 SchedulerFactory( 调度程序工厂) ：提供用于获取调度程序实例的客户端可用句柄的机制。 JobStore： 通过类实现的接口，这些类要为org.quartz.core.QuartzScheduler的使用提供一个org.quartz.Job和org.quartz.Trigger存储机制。作业和触发器的存储应该以其名称和组的组合为唯一性。 QuartzScheduler ：这是Quartz的核心，它是org.quartz.Scheduler接口的间接实现，包含调度org.quartz.Jobs，注册org.quartz.JobListener实例等的方法。 三：Quartz中的设计模式 Builder模式所有关键组件都有Builder模式来构建 如:JobBuilder、TriggerBuilder Factory模式最终由Scheduler的来进行组合各种组件 如SchedulerFactory 组件模式Quartz项目中大量使用组件模式，插件式设计，可插拔，耦合性低，易扩展，开发者可自行定义自己的Job、Trigger等组件 链式写法Quartz中大量使用链式写法，与jQuery的写法有几分相似，实现也比较简单，如： $(this).addClass(&quot;divCurrColor&quot;).next(&quot;.divContent&quot;).css(&quot;display&quot;,&quot;block&quot;); newTrigger().withIdentity( &quot;trigger3&quot;, &quot;group1&quot;).startAt( startTime) .withSchedule(simpleSchedule().withIntervalInSeconds(10).withRepeatCount(10)).build(); 四：Quartz体系结构三大核心 调度器 任务 触发器 重要组成1）任务： Job：表示一个工作，要执行的具体内容。此接口中只有一个方法。要创建一个任务，必须得实现这个接口。该接口只有一个execute方法，任务每次被调用的时候都会执行这个execute方法的逻辑，类似TimerTask的run方法，在里面编写业务逻辑。123456789public class TestJob implements Job &#123; /**把要执行的操作，写在execute方法中 */ @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;); System.out.println(&quot;I can do something...&quot;); System.out.println(sdf.format(new Date())); &#125; &#125; 生命周期：在每次调度器执行job时，它在调用execute方法前会创建一个新的job实例，当调用完成之后，关联的job对象实例会被释放，释放的实例会被垃圾回收机制回收。 JobBuilder：可向任务传递数据,通常情况下,我们使用它就可向任务类发送数据了，如有特别复杂的传递参数,它提供了一个传递递:JobDataMap对象的方法 1JobDetail jobDetail = JobBuilder.newJob(TestJob.class).withIdentity(&quot;testJob&quot;,&quot;group1&quot;).build(); JobDetail：用来保存我们任务的详细信息。一个JobDetail可以有多个Trigger，但是一个Trigger只能对应一个JobDetail。下面是JobDetail的一些常用的属性和含义： JobStore：负责跟踪所有你给scheduler的“工作数据”：jobs, triggers, calendars, 等。 RAMJobStore：是使用最简单的也是最高效(依据CPU时间)的JobStore 。RAMJobStore 正如它名字描述的一样，它保存数据在RAM。缺点是你的应用结束之后所有的数据也丢失了–这意味着RAMJobStore 不具有保持job和trigger持久的能力。对于一些程序是可以接受的，甚至是期望的，但对于其他的程序可能是灾难性的。使用RAMJobStore配置Quartz：配置如下 1org.quartz.jobStore.class = org.quartz.simpl.RAMJobStore：是使用最简单的也是最高效 JDBCJobStore：以JDBC的方式保存数据在数据库中。它比RAMJobStore的配置复杂一点，也没有RAMJobStore快。然而,性能缺点不是糟透了,特别是如果你在数据库表主键上建立了索引。在机器之间的LAN(在scheduler 和数据库之间)合理的情况下，检索和更新一个被触发的Trigger花费的时间少于10毫秒。几乎适用于所有的数据库，广泛用于 Oracle。PostgreSQL, MySQL, MS SQLServer, HSQLDB, 和DB2。使用JDBCJobStore之前你必须首先创建一系列Quartz要使用的表。你可以发现表创建语句在Quartz发布目录的 “docs/dbTables”下面。你需要确定你的应用要使用的事务类型。如果你不想绑定调度命令(例如增加和移除Trigger)到其他的事务，你可以使用JobStoreTX (最常用的选择)作为你的Jobstore。如果你需要Quartz和其他的事务(例如在J2EE应用服务器中)一起工作，你应该使用JobStoreCMT ，Quartz 将让应用服务器容器管理这个事务。使用JobStoreTx配置Quartz： 123456org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate #配置表的前缀 org.quartz.jobStore.tablePrefix = QRTZ_ #使用JNDI数据源的时候，数据源的名字 org.quartz.jobStore.dataSource = myDS TerracottaJobStore：提供了一个方法：在不使用数据库的情况下使它具有收缩性和强壮性。可以是集群的也可以是非集群的，在这两种情况下为你的job数据提供了一个存储机制用于应用程序重启之间持久,因为数据是存储在Terracotta服务器。它的性能比使用数据库访问JDBCJobStore好一点儿(大约是一个数量级)，但是明显比RAMJobStore慢。使用TerracottaJobStore配置Quartz： 12org.quartz.jobStore.class = org.terracotta.quartz.TerracottaJobStore org.quartz.jobStore.tcConfigUrl = localhost:9510 JobDataMap：中可以包含不限量的（序列化的）数据对象，在job实例执行的时候，可以使用其中的数据；JobDataMap是Java Map接口的一个实现，额外增加了一些便于存取基本类型的数据的方法。 存： 1JobDetail jobDetail = JobBuilder.newJob(TestJob.class).withIdentity(&quot;testJob&quot;,&quot;group1&quot;).usingJobData(&quot;date1&quot;,&quot;存内容&quot;).build(); 取： 123456789public class TestJob implements Job &#123; /**把要执行的操作，写在execute方法中 */ @Override public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; JobKey key = jobExecutionContext.getJobDetail().getKey(); JobDataMap jobDataMap = jobExecutionContext.getJobDetail().getJobDataMap(); String date1 = jobDataMap.getString(&quot;date1&quot;); &#125; &#125; 2）触发器：用来触发执行Job2.1）触发器通用属性： Jobkey：表示job实例的标识，触发器被触发时，该指定的job实例会被执行 StartTime：表示触发器的时间表首次被触发的时间，它的值类型为：java.util.Date EndTime：指定触发器的不再被触发的时间，它的值类型为：java.util.Date 2.2）触发器类型： SimpleTrigger： 主要是针对一些相对简单的时间触发进行配置使用，比如在指定的时间开始然后在一定的时间间隔之内重复执行一个Job，同时可以任意指定重复的次数。用来触发只需执行一次或者在给定时间触发并且重复N次且每次执行延迟一定时间的任务。 下面就是使用一个SimpleTrigger的例子:12345678910111213141516//创建触发器 每3秒钟执行一次(无开始时间和结束时间) Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(&quot;trigger1&quot;, &quot;group3&quot;) .withSchedule( SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(3).repeatForever()).build(); //创建触发器 每3秒钟执行一次(有开始时间和结束时间) long now = new Date().getTime(); Date start = new Date(now+6000); Date end = new Date(now+12000); //创建触发器 每3秒钟执行一次 Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(&quot;trigger1&quot;, &quot;group3&quot;) .startAt(start) .endAt(end) .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(3).repeatForever()).build(); SimpleTrigger具有丰富的构造函数，根据业务需求构造不同的构造函数。 CronTrigger： 可以配置更复杂的触发时刻表，基于日历的作业触发器，而不像SimpleTrigger那样精确指定间隔时间，按照日历触发，例如“每个周五”，每个月10日中午或者10：15分。比SimpleTrigger更加常用。 Cron表达式：用于配置CronTrigger实例，是由7个表达式组成的字符串，描述了时间表的详细信息。 格式为：[秒][分][时][日][月][周][年] Cron表达式特殊字符意义对应表：通配符说明：Cron表达式例子： TriggerBuilder.newTrigger().withIdentity(&quot;trigger2&quot;,&quot;group2&quot;).withSchedule(CronScheduleBuilder.cronSchedule(&quot;0 0 9 ? * 6L *&quot;)).build(); Cron表达式小技巧： ‘L’和‘W’可以一起组合使用 周字段英文字母不区分大小写即MOM与mom相同 利用工具，在线生成cron表达式：cron.qqe2.com/ NthIncludedDayTrigger：是 Quartz 开发团队最新加入到框架中的一个 Trigger。它设计用于在每一间隔类型的第几天执行 Job。例如，你要在每个月的 15 号执行开票的 Job，用 NthIncludedDayTrigger就再合适不过了。 123NthIncludedDayTrigger trigger = new NthIncludedDayTrigger(&quot;NthIncludedDayTrigger&quot;,Scheduler.DEFAULT_GROUP); trigger.setN(15); trigger.setIntervalType(NthIncludedDayTrigger.INTERVAL_TYPE_MONTHLY); 3）调度器Scheduler 代表一个Quartz的独立运行容器，Trigger和JobDetail可以注册到Scheduler中，两者在Scheduler中拥有各自的组及名称，组及名称是Scheduler查找定位容器中某一对象的依据，Trigger的组及名称必须唯一，JobDetail的组和名称也必须唯一（但可以和Trigger的组和名称相同，因为它们是不同类型的）。Scheduler定义了多个接口方法，允许外部通过组及名称访问和控制容器中Trigger和JobDetail。 Scheduler可以将Trigger绑定到某一JobDetail中，这样当Trigger触发时，对应的Job就被执行。一个Job可以对应多个Trigger，但一个Trigger只能对应一个Job。 可以通过SchedulerFactory创建一个Scheduler实例。Scheduler拥有一个SchedulerContext，它类似于ServletContext，保存着Scheduler上下文信息，Job和Trigger都可以访问SchedulerContext内的信息。SchedulerContext内部通过一个Map，以键值对的方式维护这些上下文数据，SchedulerContext为保存和获取数据提供了多个put()和getXxx()的方法。可以通过Scheduler# getContext()获取对应的SchedulerContext实例；123456789SchedulerFactory schedulerfactory=new StdSchedulerFactory(); Scheduler scheduler = schedulerfactory.getScheduler(); DirectSchedulerFactory factory = DirectSchedulerFactory.getInstance(); try &#123; Scheduler scheduler = factory.getScheduler(); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; 4)SchedulerFactory: 使用一组参数（java.util.Properties）来创建和出书啊Quartz调度器 配置参数一般存储在quartz.properties中 调用getScheduler方法就能创建和初始化调度器 5)quartz.properties: Quartz-Job的quartz.properties配置文件说明，此文件在quartz的jar包有，可直接拿过来使用不过只有基本的几个配置 自己可根据需要进行扩充；另外如果项目中没有对该配置文件重写，则Quartz会加载自己jar包中的quartz.properties文件。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# Default Properties file for use by StdSchedulerFactory # to create a Quartz Scheduler Instance, if a different # properties file is not explicitly specified. # # =========================================================================== # Configure Main Scheduler Properties 调度器属性 # =========================================================================== org.quartz.scheduler.instanceName: DefaultQuartzScheduler #org.quartz.scheduler.instanceid:AUTO org.quartz.scheduler.rmi.export: false org.quartz.scheduler.rmi.proxy: false org.quartz.scheduler.wrapJobExecutionInUserTransaction: false # =========================================================================== # Configure ThreadPool 线程池属性 # =========================================================================== #线程池的实现类（一般使用SimpleThreadPool即可满足几乎所有用户的需求） org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPool #指定线程数，至少为1（无默认值）(一般设置为1-100直接的整数合适) org.quartz.threadPool.threadCount: 10 #设置线程的优先级（最大为java.lang.Thread.MAX_PRIORITY 10，最小为Thread.MIN_PRIORITY 1，默认为5） org.quartz.threadPool.threadPriority: 5 #设置SimpleThreadPool的一些属性 #设置是否为守护线程 #org.quartz.threadpool.makethreadsdaemons = false #org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread: true #org.quartz.threadpool.threadsinheritgroupofinitializingthread=false #线程前缀默认值是：[Scheduler Name]_Worker #org.quartz.threadpool.threadnameprefix=swhJobThead; # 配置全局监听(TriggerListener,JobListener) 则应用程序可以接收和执行 预定的事件通知 # =========================================================================== # Configuring a Global TriggerListener 配置全局的Trigger监听器 # MyTriggerListenerClass 类必须有一个无参数的构造函数，和 属性的set方法，目前2.2.x只支持原始数据类型的值（包括字符串） # =========================================================================== #org.quartz.triggerListener.NAME.class = com.swh.MyTriggerListenerClass #org.quartz.triggerListener.NAME.propName = propValue #org.quartz.triggerListener.NAME.prop2Name = prop2Value # =========================================================================== # Configuring a Global JobListener 配置全局的Job监听器 # MyJobListenerClass 类必须有一个无参数的构造函数，和 属性的set方法，目前2.2.x只支持原始数据类型的值（包括字符串） # =========================================================================== #org.quartz.jobListener.NAME.class = com.swh.MyJobListenerClass #org.quartz.jobListener.NAME.propName = propValue #org.quartz.jobListener.NAME.prop2Name = prop2Value # =========================================================================== # Configure JobStore 存储调度信息（工作，触发器和日历等） # =========================================================================== # 信息保存时间 默认值60秒 org.quartz.jobStore.misfireThreshold: 60000 #保存job和Trigger的状态信息到内存中的类 org.quartz.jobStore.class: org.quartz.simpl.RAMJobStore # =========================================================================== # Configure SchedulerPlugins 插件属性 配置 # =========================================================================== # 自定义插件 #org.quartz.plugin.NAME.class = com.swh.MyPluginClass #org.quartz.plugin.NAME.propName = propValue #org.quartz.plugin.NAME.prop2Name = prop2Value #配置trigger执行历史日志（可以看到类的文档和参数列表） org.quartz.plugin.triggHistory.class = org.quartz.plugins.history.LoggingTriggerHistoryPlugin org.quartz.plugin.triggHistory.triggerFiredMessage = Trigger &#123;1&#125;.&#123;0&#125; fired job &#123;6&#125;.&#123;5&#125; at: &#123;4, date, HH:mm:ss MM/dd/yyyy&#125; org.quartz.plugin.triggHistory.triggerCompleteMessage = Trigger &#123;1&#125;.&#123;0&#125; completed firing job &#123;6&#125;.&#123;5&#125; at &#123;4, date, HH:mm:ss MM/dd/yyyy&#125; with resulting trigger instruction code: &#123;9&#125; #配置job调度插件 quartz_jobs(jobs and triggers内容)的XML文档 #加载 Job 和 Trigger 信息的类 （1.8之前用：org.quartz.plugins.xml.JobInitializationPlugin） org.quartz.plugin.jobInitializer.class = org.quartz.plugins.xml.XMLSchedulingDataProcessorPlugin #指定存放调度器(Job 和 Trigger)信息的xml文件，默认是classpath下quartz_jobs.xml org.quartz.plugin.jobInitializer.fileNames = my_quartz_job2.xml #org.quartz.plugin.jobInitializer.overWriteExistingJobs = false org.quartz.plugin.jobInitializer.failOnFileNotFound = true #自动扫描任务单并发现改动的时间间隔,单位为秒 org.quartz.plugin.jobInitializer.scanInterval = 10 #覆盖任务调度器中同名的jobDetail,避免只修改了CronExpression所造成的不能重新生效情况 org.quartz.plugin.jobInitializer.wrapInUserTransaction = false # =========================================================================== # Sample configuration of ShutdownHookPlugin ShutdownHookPlugin插件的配置样例 # =========================================================================== #org.quartz.plugin.shutdownhook.class = \\org.quartz.plugins.management.ShutdownHookPlugin #org.quartz.plugin.shutdownhook.cleanShutdown = true # # Configure RMI Settings 远程服务调用配置 # #如果你想quartz-scheduler出口本身通过RMI作为服务器，然后设置“出口”标志true(默认值为false)。 #org.quartz.scheduler.rmi.export = false #主机上rmi注册表(默认值localhost) #org.quartz.scheduler.rmi.registryhost = localhost #注册监听端口号（默认值1099） #org.quartz.scheduler.rmi.registryport = 1099 #创建rmi注册，false/never：如果你已经有一个在运行或不想进行创建注册 # true/as_needed:第一次尝试使用现有的注册，然后再回来进行创建 # always:先进行创建一个注册，然后再使用回来使用注册 #org.quartz.scheduler.rmi.createregistry = never #Quartz Scheduler服务端端口，默认是随机分配RMI注册表 #org.quartz.scheduler.rmi.serverport = 1098 #true:链接远程服务调度(客户端),这个也要指定registryhost和registryport，默认为false # 如果export和proxy同时指定为true，则export的设置将被忽略 #org.quartz.scheduler.rmi.proxy = false 五：存储方式RAMJobStore:优点：不要外部数据库，配置容易，运行速度快缺点：因为调度程序信息是存储在被分配给JVM的内存里面，所以，当应用程序停止运行时，所有调度信息将被丢失。另外因为存储到JVM内存里面，所以可以存储多少个Job和Trigger将会受到限制JDBCJobStore:优点：支持集群，因为所有的任务信息都会保存到数据库中，可以控制事物，还有就是如果应用服务器关闭或者重启，任务信息都不会丢失，并且可以恢复因服务器关闭或者重启而导致执行失败的任务缺点：运行速度的快慢取决与连接数据库的快慢 表关系和解释 Tables Means qrtz_blob_triggers Trigger作为Blob类型存储(用于Quartz用户用JDBC创建他们自己定制的Trigger类型，JobStore 并不知道如何存储实例的时候) qrtz_calendars 以Blob类型存储Quartz的Calendar日历信息， quartz可配置一个日历来指定一个时间范围 qrtz_cron_triggers 存储Cron Trigger，包括Cron表达式和时区信息。 qrtz_fired_triggers 存储与已触发的Trigger相关的状态信息，以及相联Job的执行信息 qrtz_job_details 存储每一个已配置的Job的详细信息 qrtz_locks 存储程序的非观锁的信息(假如使用了悲观锁) qrtz_paused_trigger_graps 存储已暂停的Trigger组的信息 qrtz_scheduler_state 存储少量的有关 Scheduler的状态信息，和别的 Scheduler 实例(假如是用于一个集群中) qrtz_simple_triggers 存储简单的 Trigger，包括重复次数，间隔，以及已触的次数 qrtz_triggers 存储已配置的 Trigger的信息 qrzt_simprop_triggers 思想// 1、工厂模式 构建Scheduler的Factory，其中STD为Quartz默认的Factory // 开发者亦可自行实现自己的Factory;Job、Trigger等组件 SchedulerFactory sf = new StdSchedulerFactory(); // 2、通过SchedulerFactory构建Scheduler对象 Scheduler sched = sf.getScheduler(); // 3、org.quartz.DateBuilder.evenMinuteDate -- 通过DateBuilder构建Date Date runTime = evenMinuteDate( new Date()); // 4、org.quartz.JobBuilder.newJob &lt;下一分钟&gt; --通过JobBuilder构建Job JobDetail job = newJob(HelloJob.class).withIdentity(&quot;job1&quot;,&quot;group1&quot;).build(); // 5、通过TriggerBuilder进行构建Trigger Trigger trigger = newTrigger().withIdentity(&quot;trigger1&quot;,&quot;group1&quot;) .startAt(runTime).build(); // 6、工厂模式，组装各个组件&lt;JOB，Trigger&gt; sched.scheduleJob (job, trigger); // 7、start sched.start(); try { Thread.sleep(65L * 1000L); } catch (Exception e) { } // 8、通过Scheduler销毁内置的Trigger和Job sched.shutdown(true); 一句话看懂Quartz 创建调度工厂(); //工厂模式 根据工厂取得调度器实例(); //工厂模式 Builder模式构建子组件 // builder模式, 如JobBuilder、TriggerBuilder、DateBuilder 通过调度器组装子组件 调度器.组装&lt;子组件1,子组件2…&gt; //工厂模式 调度器.start(); //工厂模式 参考:quartz详解2：quartz由浅入深Quartz使用总结Quartz深入浅出(一)Quartz学习——Quartz大致介绍（一）深入解读Quartz任务调度器","tags":[{"name":"quartz","slug":"quartz","permalink":"http://wangyuanjun.cn/tags/quartz/"}]},{"title":"Oracle VM VirtualBox配置虚拟网卡(桥接),实现主机-虚拟机网络互通","date":"2017-12-25T09:01:52.000Z","path":"2017/12/25/Oracle-VM-VirtualBox配置虚拟网卡-桥接-实现主机-虚拟机网络互通/","text":"桥接网卡 首先打开虚拟机 右键点击右下角 网络连接 在弹出框内点击 网络 在设置界面依次点击-网络-连接方式选择 -桥接网卡-确定 编辑网卡 打开centos虚拟机终端，就是命令行 切换到root用户，对网卡文件进行编辑 shell#cd /etc/sysconfig/network-scripts/ shell# vim ifcfg-enp0s3 BOOTPROTO=dhcp,ONBOOT=yes(dhcp为动态获取ip，ONBOOT=yes为开机启动) 保存退出！ 重启服务器shell#service network restart 或者 shell#systemctl restart network (centos7版本命令) 参考:VirtualBox linux虚拟机如何实现“桥接”上网","tags":[{"name":"Oracle VM VirtualBox","slug":"Oracle-VM-VirtualBox","permalink":"http://wangyuanjun.cn/tags/Oracle-VM-VirtualBox/"},{"name":"linux","slug":"linux","permalink":"http://wangyuanjun.cn/tags/linux/"}]},{"title":"解决虚拟机安装linux后首次输入ifconfig IP地址显示为127.0.0.1","date":"2017-12-25T08:34:13.000Z","path":"2017/12/25/解决虚拟机安装linux后首次输入ifconfig-IP地址显示为127-0-0-1/","text":"使用虚拟机Oracle VM VirtualBox安装linux首次输入ifconfig IP地址显示为127.0.0.1，解决方法如下:在linux系统中输入命令: vi /etc/sysconfig/network-scripts/ifcfg-eth0 显示如下: 将其中的ONBOOT=no改为yes,保存并退出。 最后输入命令: service network restart（重启服务命令） 重启服务器,会出现正在配置IP的提示,待自动配置成功后,输入命令ifconfig即可。","tags":[{"name":"Oracle VM VirtualBox","slug":"Oracle-VM-VirtualBox","permalink":"http://wangyuanjun.cn/tags/Oracle-VM-VirtualBox/"},{"name":"linux","slug":"linux","permalink":"http://wangyuanjun.cn/tags/linux/"}]},{"title":"解决项目war包部署到linux系统的tomcat中访问页面报404错误","date":"2017-12-25T05:56:46.000Z","path":"2017/12/25/解决项目war包部署到linux系统的tomcat中访问页面报404错误/","text":"","tags":[]},{"title":"Java Web项目导出war包并部署到linux系统的tomcat中","date":"2017-12-25T04:15:54.000Z","path":"2017/12/25/Java-Web项目导出war包并部署到linux系统的tomcat中/","text":"使用eclpise导出war包右击项目–&gt;Export–&gt;选择WAR file–&gt;选择导出目录,导出，如下图所示: 使用maven导出war包右击项目–&gt;Run as–&gt;Maven install，如下图所示: 将war包部署至tomcat中我的电脑系统是windows，为了模拟linux环境，使用Oracle VM VirtualBox虚拟机及centos6.9搭建linux环境。在linux上安装tomcate及jdk，配置环境变量 将spring-demo.war放到Tomcat的webapps目录下。在windows上安装ssh,通过它将war包上传到linux上 启动tomcat使用 ./catalina.sh run 命令可查看tomcate启动日志 启动没报错，使用 ./startup.sh 命令启动tomcate，如果不能访问请关闭linux防火墙或者到防火墙中添加可访问的域名及端口。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://wangyuanjun.cn/tags/nginx/"}]},{"title":"SpringBoot发布HttpClient服务和客户端调用HttpClient服务","date":"2017-12-23T06:28:27.000Z","path":"2017/12/23/SpringBoot发布HttpClient服务和客户端调用HttpClient服务/","text":"之前在做公司项目的一个功能需要写WebSerice接口，写完之后我们老大说也可以用HttpClient来写接口，所以写了一个接口例子。 添加依赖&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wyj&lt;/groupId&gt; &lt;artifactId&gt;wyj-interface-client&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;wyj-interface-client Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- http --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!--webservice cxf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;3.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;wyj-interface-client&lt;/finalName&gt; &lt;/build&gt; &lt;/project&gt; HttpClient客户端可以传输json和map数据，可以使用get和post请求，详情见备注 package http; import java.io.IOException; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Map.Entry; import org.apache.http.HttpStatus; import org.apache.http.NameValuePair; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.ContentType; import org.apache.http.entity.StringEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils; import org.junit.Test; import com.alibaba.fastjson.JSON; /** * http客户端 * * * @author：WangYuanJun * @date：2017年12月20日 下午8:26:51 */ public class HttpClientTest { /** * post请求传输map数据 * * @param url * @param map * @param encoding * @return * @throws ClientProtocolException * @throws IOException */ public static String sendPostDataByMap(String url, Map&lt;String, String&gt; map, String encoding) throws ClientProtocolException, IOException { String result = &quot;&quot;; // 创建httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建post方式请求对象 HttpPost httpPost = new HttpPost(url); // 装填参数 List&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;NameValuePair&gt;(); if (map != null) { for (Entry&lt;String, String&gt; entry : map.entrySet()) { nameValuePairs.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); } } // 设置参数到请求对象中 httpPost.setEntity(new UrlEncodedFormEntity(nameValuePairs, encoding)); // 设置header信息 // 指定报文头【Content-type】、【User-Agent】 httpPost.setHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); httpPost.setHeader(&quot;User-Agent&quot;, &quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;); // 执行请求操作，并拿到结果（同步阻塞） CloseableHttpResponse response = httpClient.execute(httpPost); // 获取结果实体 // 判断网络连接状态码是否正常(0--200都数正常) if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;); } // 释放链接 response.close(); return result; } /** * post请求传输json数据 * * @param url * @param json * @param encoding * @return * @throws ClientProtocolException * @throws IOException */ public static String sendPostDataByJson(String url, String json, String encoding) throws ClientProtocolException, IOException { String result = &quot;&quot;; // 创建httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建post方式请求对象 HttpPost httpPost = new HttpPost(url); // 设置参数到请求对象中 StringEntity stringEntity = new StringEntity(json, ContentType.APPLICATION_JSON); stringEntity.setContentEncoding(&quot;utf-8&quot;); httpPost.setEntity(stringEntity); // 执行请求操作，并拿到结果（同步阻塞） CloseableHttpResponse response = httpClient.execute(httpPost); // 获取结果实体 // 判断网络连接状态码是否正常(0--200都数正常) if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;); } // 释放链接 response.close(); return result; } /** * get请求传输数据 * * @param url * @param encoding * @return * @throws ClientProtocolException * @throws IOException */ public String sendGetData(String url, String encoding) throws ClientProtocolException, IOException { String result = &quot;&quot;; // 创建httpclient对象 CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建get方式请求对象 HttpGet httpGet = new HttpGet(url); httpGet.addHeader(&quot;Content-type&quot;, &quot;application/json&quot;); // 通过请求对象获取响应对象 CloseableHttpResponse response = httpClient.execute(httpGet); // 获取结果实体 // 判断网络连接状态码是否正常(0--200都数正常) if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) { result = EntityUtils.toString(response.getEntity(), &quot;utf-8&quot;); } // 释放链接 response.close(); return result; } @Test public void testSendPostDataByMap() throws ClientProtocolException, IOException { String url = &quot;http://localhost:8080/httpService/sendPostDataByMap&quot;; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;name&quot;, &quot;wyj&quot;); map.put(&quot;city&quot;, &quot;南京&quot;); String body = sendPostDataByMap(url, map, &quot;utf-8&quot;); System.out.println(&quot;响应结果：&quot; + body); } @Test public void testSendPostDataByJson() throws ClientProtocolException, IOException { String url = &quot;http://localhost:8080/httpService/sendPostDataByJson&quot;; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(&quot;name&quot;, &quot;wyj&quot;); map.put(&quot;city&quot;, &quot;南京&quot;); String body = sendPostDataByJson(url, JSON.toJSONString(map), &quot;utf-8&quot;); System.out.println(&quot;响应结果：&quot; + body); } @Test public void testSendGetData() throws ClientProtocolException, IOException { String url = &quot;http://localhost:8080/httpService/sendGetData?name=wyj&amp;city=南京&quot;; String body = sendGetData(url, &quot;utf-8&quot;); System.out.println(&quot;响应结果：&quot; + body); } } HttpClient服务端package com.wyj.http; import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse; import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController; import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONObject; /** * http服务端 * * * @author：WangYuanJun * @date：2017年12月21日 下午8:27:08 */ @RestController @RequestMapping(&quot;/httpService&quot;) public class HttpServiceTest { @RequestMapping(value = &quot;/sendPostDataByMap&quot;, method = RequestMethod.POST) public String sendPostDataByMap(HttpServletRequest request, HttpServletResponse response) { String result = &quot;调用成功：数据是 &quot; + &quot;name:&quot; + request.getParameter(&quot;name&quot;) + &quot; city:&quot; + request.getParameter(&quot;city&quot;); return JSON.toJSONString(result); } @RequestMapping(value = &quot;/sendPostDataByJson&quot;, method = RequestMethod.POST) public String sendPostDataByJson(HttpServletRequest request, HttpServletResponse response, @RequestBody String requestBody) { JSONObject jsonObject = JSONObject.parseObject(requestBody); String result = &quot;调用成功：数据是 &quot; + &quot;name:&quot; + jsonObject.getString(&quot;name&quot;) + &quot; city:&quot; + jsonObject.getString(&quot;city&quot;); return JSON.toJSONString(result); } @RequestMapping(value = &quot;/sendGetData&quot;, method = RequestMethod.GET) public String sendGetData(HttpServletRequest request, HttpServletResponse response) { String result = &quot;调用成功：数据是 &quot; + &quot;name:&quot; + request.getParameter(&quot;name&quot;) + &quot; city:&quot; + request.getParameter(&quot;city&quot;); return JSON.toJSONString(result); } } 调用后返回结果输出为 项目地址SpringBoot整合的HttpClient客户端地址SpringBoot整合的HttpClient服务端地址","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://wangyuanjun.cn/tags/SpringBoot/"},{"name":"HttpClient","slug":"HttpClient","permalink":"http://wangyuanjun.cn/tags/HttpClient/"}]},{"title":"SpringBoot整合cxf发布WebService服务和客户端调用WebService服务","date":"2017-12-21T05:19:10.000Z","path":"2017/12/21/SpringBoot整合cxf发布WebService服务和客户端调用WebService服务/","text":"最近在做公司项目的一个功能需要写WebSerice接口，为了系统得学习WebService，决定写一个测试接口的例子。测试项目中使用的是SpringBoot(spring整合cxf需添加cxf-rt-frontend-jaxws，cxf-rt-transports-http依赖) 添加依赖&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.wyj&lt;/groupId&gt; &lt;artifactId&gt;wyj-interface-service&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;wyj-interface-service&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- http --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.1.41&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 热部署模块 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 这个需要为 true 热部署才有效 --&gt; &lt;/dependency&gt; &lt;!-- CXF webservice --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-spring-boot-starter-jaxws&lt;/artifactId&gt; &lt;version&gt;3.1.11&lt;/version&gt; &lt;/dependency&gt; &lt;!-- CXF webservice --&gt; &lt;dependency&gt; &lt;groupId&gt;org.scala-lang&lt;/groupId&gt; &lt;artifactId&gt;scala-library&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 服务端接口package com.wyj.webservice; import javax.jws.WebMethod; import javax.jws.WebParam; import javax.jws.WebResult; import javax.jws.WebService; /** * webservice测试接口 * * * @author：WangYuanJun * @date：2017年12月19日 下午9:36:49 */ @WebService(name = &quot;TestService&quot;, // 暴露服务名称 targetNamespace = &quot;http://service.wyj.com&quot;// 命名空间,一般是接口的包名倒序 ) public interface TestService { @WebMethod @WebResult(name = &quot;String&quot;, targetNamespace = &quot;&quot;) String sendMessage(@WebParam(name = &quot;username&quot;) String username); } 服务端接口实现package com.wyj.webservice; import javax.jws.WebService; import org.springframework.stereotype.Component; /** * webservice测试接口实现 * * * @author：WangYuanJun * @date：2017年12月19日 下午9:37:20 */ @WebService(serviceName = &quot;TestService&quot;, // 与接口中指定的name一致 targetNamespace = &quot;http://service.wyj.com&quot;, // 与接口中的命名空间一致,一般是接口的包名倒 endpointInterface = &quot;com.wyj.webservice.TestService&quot;// 接口地址 ) @Component public class TestServiceImpl implements TestService { @Override public String sendMessage(String username) { return &quot;hello &quot;+username; } } cxf配置package com.wyj.webservice; import javax.xml.ws.Endpoint; import org.apache.cxf.Bus; import org.apache.cxf.jaxws.EndpointImpl; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * cxf配置 * * * @author：WangYuanJun * @date：2017年12月19日 下午9:38:24 */ @Configuration public class CxfConfig { @Autowired private Bus bus; @Autowired private TestService testService; @Bean public Endpoint endpoint(){ EndpointImpl endpoint = new EndpointImpl(bus, testService); endpoint.publish(&quot;/TestService&quot;); return endpoint; } } 默认服务在Host:port/services/*路径下将TestService接口发布在了路径/services/TestService下,wsdl文档路径为，http://localhost:8080/services/TestService?wsdl TestService的wsdl信息&lt;?xml version=&apos;1.0&apos; encoding=&apos;UTF-8&apos;?&gt;&lt;wsdl:definitions xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot; xmlns:tns=&quot;http://service.wyj.com&quot; xmlns:soap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot; xmlns:ns1=&quot;http://schemas.xmlsoap.org/soap/http&quot; name=&quot;TestService&quot; targetNamespace=&quot;http://service.wyj.com&quot;&gt; &lt;wsdl:types&gt; &lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:tns=&quot;http://service.wyj.com&quot; elementFormDefault=&quot;unqualified&quot; targetNamespace=&quot;http://service.wyj.com&quot; version=&quot;1.0&quot;&gt; &lt;xs:element name=&quot;sendMessage&quot; type=&quot;tns:sendMessage&quot;/&gt; &lt;xs:element name=&quot;sendMessageResponse&quot; type=&quot;tns:sendMessageResponse&quot;/&gt; &lt;xs:complexType name=&quot;sendMessage&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element minOccurs=&quot;0&quot; name=&quot;username&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name=&quot;sendMessageResponse&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element minOccurs=&quot;0&quot; name=&quot;String&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt; &lt;/xs:schema&gt; &lt;/wsdl:types&gt; &lt;wsdl:message name=&quot;sendMessage&quot;&gt; &lt;wsdl:part element=&quot;tns:sendMessage&quot; name=&quot;parameters&quot;&gt; &lt;/wsdl:part&gt; &lt;/wsdl:message&gt; &lt;wsdl:message name=&quot;sendMessageResponse&quot;&gt; &lt;wsdl:part element=&quot;tns:sendMessageResponse&quot; name=&quot;parameters&quot;&gt; &lt;/wsdl:part&gt; &lt;/wsdl:message&gt; &lt;wsdl:portType name=&quot;TestService&quot;&gt; &lt;wsdl:operation name=&quot;sendMessage&quot;&gt; &lt;wsdl:input message=&quot;tns:sendMessage&quot; name=&quot;sendMessage&quot;&gt; &lt;/wsdl:input&gt; &lt;wsdl:output message=&quot;tns:sendMessageResponse&quot; name=&quot;sendMessageResponse&quot;&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:portType&gt; &lt;wsdl:binding name=&quot;TestServiceSoapBinding&quot; type=&quot;tns:TestService&quot;&gt; &lt;soap:binding style=&quot;document&quot; transport=&quot;http://schemas.xmlsoap.org/soap/http&quot;/&gt; &lt;wsdl:operation name=&quot;sendMessage&quot;&gt; &lt;soap:operation soapAction=&quot;&quot; style=&quot;document&quot;/&gt; &lt;wsdl:input name=&quot;sendMessage&quot;&gt; &lt;soap:body use=&quot;literal&quot;/&gt; &lt;/wsdl:input&gt; &lt;wsdl:output name=&quot;sendMessageResponse&quot;&gt; &lt;soap:body use=&quot;literal&quot;/&gt; &lt;/wsdl:output&gt; &lt;/wsdl:operation&gt; &lt;/wsdl:binding&gt; &lt;wsdl:service name=&quot;TestService&quot;&gt; &lt;wsdl:port binding=&quot;tns:TestServiceSoapBinding&quot; name=&quot;TestServiceImplPort&quot;&gt; &lt;soap:address location=&quot;http://localhost:8080/services/TestService&quot;/&gt; &lt;/wsdl:port&gt; &lt;/wsdl:service&gt; &lt;/wsdl:definitions&gt; 基于cxf的客户端调用webservice接口package webservice; import org.apache.cxf.endpoint.Client; import org.apache.cxf.jaxws.endpoint.dynamic.JaxWsDynamicClientFactory; import org.junit.Test; /** * webservice客户端 * * * @author：WangYuanJun * @date：2017年12月19日 下午9:39:49 */ public class WebServiceTest { @Test public void testSend1(){ // 创建动态客户端 JaxWsDynamicClientFactory dcf = JaxWsDynamicClientFactory.newInstance(); Client client = dcf.createClient(&quot;http://localhost:8080/services/TestService?wsdl&quot;); // 需要密码的情况需要加上用户名和密码 // client.getOutInterceptors().add(new ClientLoginInterceptor(USER_NAME,PASS_WORD)); Object[] objects = new Object[0]; try { // invoke(&quot;方法名&quot;,参数1,参数2,参数3....); objects = client.invoke(&quot;sendMessage&quot;, &quot;wyj&quot;); System.out.println(&quot;返回数据:&quot; + objects[0]); } catch (java.lang.Exception e) { e.printStackTrace(); } } } 调用后返回结果输出为 项目地址SpringBoot整合cxf的WebService客户端地址SpringBoot整合cxf的WebService服务端地址","tags":[{"name":"WebService","slug":"WebService","permalink":"http://wangyuanjun.cn/tags/WebService/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://wangyuanjun.cn/tags/SpringBoot/"}]},{"title":"github-hexo搭建博客之hexo提交百度搜索引擎","date":"2017-12-18T09:13:23.000Z","path":"2017/12/18/github-hexo搭建博客之hexo提交百度搜索引擎/","text":"前几天在整理自己的博客想添加一个评论的功能，希望我写的博客能被广大人员所知，突然发现自己写的博客在百度上搜索不到，那我添加评论功能就没有意义，百度一下才知道github禁止了百度爬虫，晕死。折腾了好久才解决，接下来我向大家介绍我的解决方法。 域名1.注册域名：我是在dnspod中注册域名的，下面我以dnspod为例；2.绑定域名绑定域名分2种情况：CNAME和A记录。 A记录：A记录填写IP，由于不带www方式只能采用A记录，所以必须先才cmd的ping一下你的用户名.github.io的IP，然后到你的域名DNS设置页，将A记录指向你ping出来的IP CNAME：将CNAME指向你的用户名.github.io，这样可以保证无论是否添加www都可以访问 3.跳转在source文件夹中新建一个CNAME文件（无后缀名），然后用文本编辑器打开，在首行添加你的网站域名，如 http://xxxx.com ，注意前面没有 http:// ，也没有www，然后使用hexo g &amp;&amp; hexo d上传部署。在你绑定了新域名之后，原来的你的用户名.github.io并没有失效，而是会自动跳转到你的新域名。 验证网站1.百度搜索引擎入口：百度搜索引擎入口 2.文件验证:先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的public/下面 。然后部署到服务器,输入地址：http://wangyuanjun008.github.io/baidu_verify_oLfvXCaeZ4.html 能访问到就可以点验证按钮(按照百度的引导步骤就好)。 3.网页抓取:(1.主动推送 2.自动推送 3.sitemap 4.手动提交 )我选择的是自动推送 自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度，可将代码添加到\\themes\\landscape\\layout_partial\\after_footer.ejs中的最下面就行。 代码如下： &lt;script&gt; (function(){ var bp = document.createElement(&apos;script&apos;); var curProtocol = window.location.protocol.split(&apos;:&apos;)[0]; if (curProtocol === &apos;https&apos;) { bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;; } else { bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;; } var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(bp, s); })(); &lt;/script&gt; 参考: hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌）","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wangyuanjun.cn/tags/hexo/"}]},{"title":"github-hexo搭建博客之畅言实现博客的评论","date":"2017-12-18T07:16:28.000Z","path":"2017/12/18/github-hexo搭建博客之畅言实现博客的评论/","text":"前几天在整理自己的博客想添加一个评论的功能，希望我写的博客能被广大人员所知，解决了域名添加百度搜索引擎之后，我决定用畅言作为我的评论插件。 注册畅言进入畅言官网 , 点击右上角 “免费注册”，并填写注册信息 绑定域名详情见之前的博客github-hexo搭建博客之hexo提交百度搜索引擎 登录并进入畅言后台注册完后，登录进入畅言官网，获取你的畅言 app id 和 app key。 使用畅言系统在主题的目录下_config.yml，添加上changyan_appid和changyan_conf的值。 #Cmments comment: cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: xxxxxxxxxxx appkey: xxxxxxxxxxxxxxxxxxxxxxxx 效果:","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wangyuanjun.cn/tags/hexo/"}]},{"title":"使用element ui select下拉框多选，编辑状态下回显数据","date":"2017-12-07T14:55:20.000Z","path":"2017/12/07/使用element-ui-select下拉框多选，编辑状态下回显数据/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中使用的是 element ui 组件库，在使用select多选下拉框时，编辑页面不知道怎么为其赋值回显数据。下拉框的代码如下: &lt;el-form-item label=&quot;可选角色&quot;&gt; &lt;el-select v-model=&quot;commonForm.roles&quot; multiple placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;item in rolesItems&quot; :key=&quot;item.id&quot; :label=&quot;item.text&quot; :value=&quot;item.id&quot; &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; 猜想:多选下拉框是多条数据，将数据放到数组里面，将数据赋值给多选下拉框，就会有效果。 验证:将多选数据以数组的形式从后台返回到前台，后台字段类型是List返回结果如下: 查看页面多选回显数据成功 参考地址: https://github.com/wangyuanjun008/wyj-vue-security/blob/master/src/view/user/user.vue","tags":[{"name":"element ui","slug":"element-ui","permalink":"http://wangyuanjun.cn/tags/element-ui/"}]},{"title":"webpack引入jquery以及插件的方法(如ztree)","date":"2017-12-06T15:27:16.000Z","path":"2017/12/06/webpack引入jquery以及插件的方法-如ztree/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中需要用到树插件，但是我觉得element ui 自带的树组件不好用，最主要的问题就是后台返回到前台的数据用到递归，不太好做，所以想到了用ztree树插件来做。 安装 ztree (会自动下载依赖的 jquery ，所以不用下 jquery ) npm install ztree --save-dev 在需要的地方引入资源 import $ from &apos;jquery&apos; import &apos;ztree&apos; 但是报错说ztree找不到jquery，报错如下: 配置jquery由于 ztree 依赖于 jQuery，所以在代码中 import jQuery from ‘jquery’ 是不够的，这只是解决了自己代码对 jQuery 的依赖，在此处使用了webpack.ProvidePlugin 解决方案：在 webpack.base.conf.js 头部添加 var webpack = require(&apos;webpack&apos;) 在 resolve 后边添加 plugins: [ new webpack.ProvidePlugin({ $: &quot;jquery&quot;, jQuery: &quot;jquery&quot;, &quot;window.jQuery&quot;: &quot;jquery&quot; }) ] 引入ztree在 main.js 中，加入如下代码 import &apos;ztree/css/zTreeStyle/zTreeStyle.css&apos; import &apos;ztree&apos; 项目效果:","tags":[{"name":"webpack","slug":"webpack","permalink":"http://wangyuanjun.cn/tags/webpack/"}]},{"title":"解决element ui select下拉框不回显数据问题","date":"2017-12-05T14:06:34.000Z","path":"2017/12/05/解决element-ui-select下拉框不回显数据问题/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中用到 el-select 时遇到一个问题，就是在编辑表单时，下拉框的不显示数据，前台代码如下: &lt;el-select v-model=&quot;commonForm.status&quot; clearable placeholder=&quot;请选择&quot;&gt; &lt;el-option v-for=&quot;item in items&quot; :key=&quot;item.id&quot; :label=&quot;item.text&quot; :value=&quot;item.id&quot; &gt;&lt;/el-option&gt; &lt;/el-select&gt; 在浏览器中查看列表返回的数据: 在浏览器中查看下拉框数据源的数据: 发现select下拉的id和v-model里边的id类型不一致，修改后台下拉框数据源返回类型，下拉框显示数据成功。","tags":[{"name":"element ui","slug":"element-ui","permalink":"http://wangyuanjun.cn/tags/element-ui/"}]},{"title":"解决SpringMVC接收不到axios发送post请求的数据问题","date":"2017-12-04T13:10:03.000Z","path":"2017/12/04/解决SpringMVC接收不到axios发送post请求的数据问题/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中需要用到axios与后端接口交互的时候，使用POST请求时，后台接收不到前台传的数据js代码如下: export const addDataGroup = params =&gt; { return axios.post(`/remote/dataGroup/add`, params ); }; 请求的数据是: 后台代码代码如下: 解决如下:方法一 ：在项目中安装qs库作为格式化的依赖： npm install qs --save-dev 修改js代码: export const addDataGroup = params =&gt; { return axios.post(`/remote/dataGroup/add`, qs.stringify(params) ); }; 方法二：如果不想修改前端代码的话，需要对后台的代码做修改：通过翻看axios的文档得知：在axios使用Post发送数据时，默认是直接把json放到请求体中提交到后端的，而后端获取数据的方式有两种，一种是@RequestParam（通过字符串中解析出参数）,另一种是@ResponseBody（从请求体中取参数），很显然，我们的后端用了第一种方式。 参考文档：http://www.jzdlink.com/studynotes/201709141385.html","tags":[{"name":"axios","slug":"axios","permalink":"http://wangyuanjun.cn/tags/axios/"}]},{"title":"在vue中使用axios跨域访问数据，用proxyTable解决跨域问题","date":"2017-12-04T13:04:58.000Z","path":"2017/12/04/在vue中使用axios跨域访问数据，用proxyTable解决跨域问题/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,使用webpack构建vue-cli全家桶在项目中需要用到axios与后端接口交互的时候，遇到了跨域的问题，浏览器报错如下: 能看到是有数据数据返回到前台的，说明前台没有接收到 解决方法: 进入你的vue项目下 -&gt; config -&gt; index.js，里面的dev对象下有一个proxyTable的属性，这个参数主要是一个地址映射表，可以帮助我们将复杂的url简化。 如果请求的地址是 http://127.0.0.1:8081/remote/1 ，使用proxyTable配置，请求的地址变为 /remote/1。在proxyTable中有个参数是changeOrigin，如果设置为true,那么本地会虚拟一个服务端接收你的请求并代你发送该请求，这样就不会有跨域问题了，当然这只适用于开发环境。 参考文档：https://vuejs-templates.github.io/webpack/proxy.html","tags":[{"name":"axios","slug":"axios","permalink":"http://wangyuanjun.cn/tags/axios/"}]},{"title":"使用webpack构建vue-cli项目,写scss脚本语言报错","date":"2017-11-28T06:44:20.000Z","path":"2017/11/28/使用webpack构建vue-cli项目-写scss脚本语言报错/","text":"最近在做一个项目,项目的后端是地址: https://github.com/wangyuanjun008/wyj-springboot.github.com前端地址是 https://github.com/wangyuanjun008/wyj-vue-security.git ,使用的前端语言是vue,但是我在使用webpack构建vue项目的时候，使用scss脚本语言是报错,错误如下: error in ./src/components/home.vue Syntax Error: Unclosed block @ ./node_modules/vue-style-loader!./node_modules/css-loader?{&quot;sourceMap&quot;:false}!./node_modules/vue-loader/lib/style-compiler?{&quot;vue&quot;:true,&quot;id&quot;:&quot;data-v-7cbbe74f&quot;,&quot;scoped&quot;:false,&quot;hasInlineConfig&quot;:false}!./node_modules/vue-loader/lib/selector.js?type=styles&amp;index=0&amp;bustCache!./src/components/home.vue 4:14-317 13:3-17:5 14:22-325 @ ./src/components/home.vue @ ./src/router/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:8080 webpack/hot/dev-server ./src/main.js 后来上网查询，如果你需要使用sass/scss定义样式，那么为了能正常编译，还需要做如下配置： //因为sass-loader依赖于node-sass，所以还要安装node-sass npm install --save-dev node-sass //在项目下，运行下列命令行 npm install --save-dev scss-loader npm install --save-dev sass-loader 因为资源是到国外下载的，如果长时间未响应或者报错，可以试用淘宝镜像 npm install --save node-sass --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/dist --sass-binary-site=http://npm.taobao.org/mirrors/node-sass","tags":[{"name":"webpack","slug":"webpack","permalink":"http://wangyuanjun.cn/tags/webpack/"}]},{"title":"Springboot RedisTemplate 报No qualifying bean of type... 不能按类型装配注入","date":"2017-11-23T09:40:09.000Z","path":"2017/11/23/Springboot-RedisTemplate-报No-qualifying-bean-of-type-不能按类型装配注入/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-springboot.github.com在项目中与redis集成，使用的依赖是: &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 在Controller中使用如下: @Autowired private RedisTemplate&lt;String, DataGroup&gt; redisTemplate; 项目启动报错如下: Description: Field redisTemplate in com.wyj.controller.data.DataGroupController required a bean of type &apos;org.springframework.data.redis.core.RedisTemplate&apos; that could not be found. - Bean method &apos;redisTemplate&apos; in &apos;RedisAutoConfiguration.RedisConfiguration&apos; not loaded because @ConditionalOnMissingBean (names: redisTemplate; SearchStrategy: all) found bean &apos;redisTemplate&apos; Action: Consider revisiting the conditions above or defining a bean of type &apos;org.springframework.data.redis.core.RedisTemplate&apos; in your configuration. 2017-11-23 17:36:38.299 ERROR 5784 --- [ main] o.s.test.context.TestContextManager : Caught exception while allowing TestExecutionListener [org.springframework.test.context.web.ServletTestExecutionListener@3b2cf7ab] to prepare test instance [com.wyj.WyjSpringbootApplicationTests@6cc8adff] java.lang.IllegalStateException: Failed to load ApplicationContext at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:124) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.support.DefaultTestContext.getApplicationContext(DefaultTestContext.java:83) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.web.ServletTestExecutionListener.setUpRequestContextIfNecessary(ServletTestExecutionListener.java:189) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.web.ServletTestExecutionListener.prepareTestInstance(ServletTestExecutionListener.java:131) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.TestContextManager.prepareTestInstance(TestContextManager.java:230) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.createTest(SpringJUnit4ClassRunner.java:228) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner$1.runReflectiveCall(SpringJUnit4ClassRunner.java:287) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.methodBlock(SpringJUnit4ClassRunner.java:289) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:247) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.runChild(SpringJUnit4ClassRunner.java:94) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58) [junit-4.12.jar:4.12] at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.statements.RunBeforeTestClassCallbacks.evaluate(RunBeforeTestClassCallbacks.java:61) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.junit4.statements.RunAfterTestClassCallbacks.evaluate(RunAfterTestClassCallbacks.java:70) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.junit.runners.ParentRunner.run(ParentRunner.java:363) [junit-4.12.jar:4.12] at org.springframework.test.context.junit4.SpringJUnit4ClassRunner.run(SpringJUnit4ClassRunner.java:191) [spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.apache.maven.surefire.junit4.JUnit4Provider.execute(JUnit4Provider.java:283) [surefire-junit4-2.18.1.jar:2.18.1] at org.apache.maven.surefire.junit4.JUnit4Provider.executeWithRerun(JUnit4Provider.java:173) [surefire-junit4-2.18.1.jar:2.18.1] at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:153) [surefire-junit4-2.18.1.jar:2.18.1] at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:128) [surefire-junit4-2.18.1.jar:2.18.1] at org.apache.maven.surefire.booter.ForkedBooter.invokeProviderInSameClassLoader(ForkedBooter.java:203) [surefire-booter-2.18.1.jar:2.18.1] at org.apache.maven.surefire.booter.ForkedBooter.runSuitesInProcess(ForkedBooter.java:155) [surefire-booter-2.18.1.jar:2.18.1] at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:103) [surefire-booter-2.18.1.jar:2.18.1] Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &apos;dataGroupController&apos;: Unsatisfied dependency expressed through field &apos;redisTemplate&apos;; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;org.springframework.data.redis.core.RedisTemplate&lt;java.lang.String, com.wyj.entity.data.DataGroup&gt;&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:588) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:88) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:366) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1264) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:483) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:761) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867) ~[spring-context-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:543) ~[spring-context-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:693) ~[spring-boot-1.5.8.RELEASE.jar:1.5.8.RELEASE] at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:360) ~[spring-boot-1.5.8.RELEASE.jar:1.5.8.RELEASE] at org.springframework.boot.SpringApplication.run(SpringApplication.java:303) ~[spring-boot-1.5.8.RELEASE.jar:1.5.8.RELEASE] at org.springframework.boot.test.context.SpringBootContextLoader.loadContext(SpringBootContextLoader.java:120) ~[spring-boot-test-1.5.8.RELEASE.jar:1.5.8.RELEASE] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContextInternal(DefaultCacheAwareContextLoaderDelegate.java:98) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.test.context.cache.DefaultCacheAwareContextLoaderDelegate.loadContext(DefaultCacheAwareContextLoaderDelegate.java:116) ~[spring-test-4.3.12.RELEASE.jar:4.3.12.RELEASE] ... 26 common frames omitted Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type &apos;org.springframework.data.redis.core.RedisTemplate&lt;java.lang.String, com.wyj.entity.data.DataGroup&gt;&apos; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoMatchingBeanFound(DefaultListableBeanFactory.java:1493) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:1104) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:1066) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:585) ~[spring-beans-4.3.12.RELEASE.jar:4.3.12.RELEASE] ... 44 common frames omitted 苦思冥想多时，上网查阅资料，看springboot文档，结果如下 If you add a @Bean of your own of any of the auto-configured types it will replace the default (except in the case of RedisTemplate the exclusion is based on the bean name ‘redisTemplate’ not its type). 将代码改成: @Resource private RedisTemplate&lt;String, DataGroup&gt; redisTemplate; 项目启动不报错，完美解决!","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://wangyuanjun.cn/tags/SpringBoot/"}]},{"title":"SpringMVC中使用aop注解无效的问题","date":"2017-09-28T06:47:46.000Z","path":"2017/09/28/SpringMVC中使用aop注解无效的问题/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-parent.git写日志注解完，进行测试时，发现日志注解没有生效，代码如下: 定义注解: @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface SysLog { String action() default &quot;&quot;;//动作 } 切面: @Aspect @Component public class SysLogAspect { @Autowired private SysLogService sysLogService; @Pointcut(&quot;@annotation(com.wyj.annotation.SysLog)&quot;) public void pointCut(){} @Around(&quot;pointCut()&quot;) public Object aroud(ProceedingJoinPoint joinPoint) throws Throwable{ // 开始时间 long beginTime = System.currentTimeMillis(); //执行目标方法 Object result = joinPoint.proceed(); //执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; //保存日志 saveSysLog(joinPoint, time); return result; } } applicationContext.xml 配置: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=&quot;com.wyj&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.web.bind.annotation.ControllerAdvice&quot; /&gt; &lt;/context:component-scan&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; &lt;/beans&gt; controller代码: @Controller @RequestMapping(value = &quot;/user&quot;) public class UserController { private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private UserService userService; @SysLog(action=&quot;新增/编辑用户&quot;) @ResponseBody @RequestMapping(value = &quot;/add&quot;, method = RequestMethod.POST) public Retval save(User user) { Retval retval = Retval.newInstance(); try { if (user.getUserId() == null) { userService.saveUser(user); } else { userService.updateUser(user); } } catch (Exception e) { logger.error(e.getMessage(), e); } return retval; } } 和别人讨论了下，大致是Spring上下文的问题我的AOP配置是这样的：AOP命名空间和挪到SpringMVC自己的配置文件里面，AOP就生效了。 代码如下:springmvc-servlet.xml: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; default-lazy-init=&quot;true&quot;&gt; &lt;mvc:annotation-driven /&gt; &lt;mvc:annotation-driven content-negotiation-manager=&quot;contentNegotiationManager&quot;&gt; &lt;mvc:message-converters register-defaults=&quot;true&quot;&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;prettyPrint&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;bean id=&quot;contentNegotiationManager&quot; class=&quot;org.springframework.web.accept.ContentNegotiationManagerFactoryBean&quot;&gt; &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;defaultContentType&quot; value=&quot;application/json&quot; /&gt; &lt;property name=&quot;mediaTypes&quot;&gt; &lt;value&gt; json=application/json xml=application/xml &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;context:component-scan base-package=&quot;com.wyj&quot;&gt;&lt;/context:component-scan&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/views/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;mvc:resources location=&quot;/resources/**&quot; mapping=&quot;/resources/**&quot; /&gt; &lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; /&gt; &lt;/beans&gt; 另外以上所述的是对controller进行切面时的配置，如果是对service进行切面，那么 这两个注释就要用在ApplicationContext.xml里面了，注意此时不要开启aop的cglib代理模式。 解释： 1.SpringMVC这个框架简化了很多的配置，但是请注意@Controller和@Service都是SpringMVC框架包里面的，也就是说，这些类的实例化以及注入也是由SpringMVC这个框架完成的（确切的来说是这个框架自己有的上下文的IoC容器完成的）。 2.而对AOP和事务的支持是Spring框架本身完成的，是Spring框架的应用上下文所扫描并处理的。 从1.2可以得出一个结论，如果SpringMVC和Spring本身用的是一个应用上下文，一个Ioc容器，那随便你的和命名空间配置在哪里，无论是Spring的ApplicationContext.xml还是SpringMVC的springmvc-servlet.xml里面，反正都是一个容器，怎么扫描，怎么处理都能找到。 但关键的是以上假设不成立，总的来说SpringMVC的应用上下文的 “ 父 ” 上下文才是Spring的应用上下文。那么这个也就是说Spring的应用上下文初始化完成的时候，它开始扫描到底哪些Bean用了AspectJ的注解，哪些用了Transactional的注解，但是利用SpringMVC注解配置的这些Bean它是找不到的，因为用了这些注解的Bean还没有被实例化甚至是还没有被装载，为什么呢？因为管理这些bean的SpringMVC的上下文可能还没有完成初始化。OK，既然Spring的上下文找不到到底哪些Bean应用了注解，那他自然也没有办法给这些Bean提供声明式AOP和事务的支持了。 至于为什么SpringMVC的应用上下文的 “ 父 ” 上下文才是Spring的应用上下文，这里有大牛为我们详解：http://blog.csdn.net/c289054531/article/details/9196149 另外，Spring中的切面类固然要用@Aspect标注，但也不要忘了用@Componet标注，这样才能被注册到容器中","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://wangyuanjun.cn/tags/SpringMVC/"}]},{"title":"使用Spring配置shiro时,自定义Realm中属性无法使用注解注入解决办法","date":"2017-09-21T15:30:17.000Z","path":"2017/09/21/使用Spring配置shiro时-自定义Realm中属性无法使用注解注入解决办法/","text":"项目地址: https://github.com/wangyuanjun008/wyj-parent.github.com最近在使用shiro框架与系统集成的时候，启动报错如下: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;shiroFilter&apos; defined in class path resource [spring-context-shiro.xml]: Cannot resolve reference to bean &apos;securityManager&apos; while setting bean property &apos;securityManager&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;securityManager&apos; defined in class path resource [spring-context-shiro.xml]: Cannot resolve reference to bean &apos;userRealm&apos; while setting bean property &apos;realm&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userRealm&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.wyj.service.system.UserService com.wyj.shiro.realm.UserRealm.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:328) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:107) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1456) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1197) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:232) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:618) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:467) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:403) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106) [spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4729) [catalina.jar:na] at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5167) [catalina.jar:na] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) [catalina.jar:na] at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:725) [catalina.jar:na] at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:701) [catalina.jar:na] at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:717) [catalina.jar:na] at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:586) [catalina.jar:8.0.26.B] at org.apache.catalina.startup.HostConfig$DeployDescriptor.run(HostConfig.java:1750) [catalina.jar:8.0.26.B] at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) [na:1.8.0_77] at java.util.concurrent.FutureTask.run(FutureTask.java:266) [na:1.8.0_77] at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) [na:1.8.0_77] at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) [na:1.8.0_77] at java.lang.Thread.run(Thread.java:745) [na:1.8.0_77] Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;securityManager&apos; defined in class path resource [spring-context-shiro.xml]: Cannot resolve reference to bean &apos;userRealm&apos; while setting bean property &apos;realm&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userRealm&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.wyj.service.system.UserService com.wyj.shiro.realm.UserRealm.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:328) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:107) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1456) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1197) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:320) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 28 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;userRealm&apos;: Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.wyj.service.system.UserService com.wyj.shiro.realm.UserRealm.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:292) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1185) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:537) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:320) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 38 common frames omitted Caused by: org.springframework.beans.factory.BeanCreationException: Could not autowire field: private com.wyj.service.system.UserService com.wyj.shiro.realm.UserRealm.userService; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:508) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:87) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessPropertyValues(AutowiredAnnotationBeanPostProcessor.java:289) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 46 common frames omitted Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.wyj.service.system.UserService] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)} at org.springframework.beans.factory.support.DefaultListableBeanFactory.raiseNoSuchBeanDefinitionException(DefaultListableBeanFactory.java:1100) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:960) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:855) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:480) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 48 common frames omitted 在shiro.xml的配置是: &lt;bean id=&quot;userRealm&quot; class=&quot;com.wyj.shiro.realm.UserRealm&quot;/&gt; UserRealm.java的代码是: public class UserRealm extends AuthorizingRealm{ @Autowired private UserService userService; @Autowired private RoleService roleService; @Autowired private MenuService menuService; /** * 授权(验证权限时调用) * 为当前登陆成功的用户授予权限和角色，已经登陆成功了 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { ... return info; } /** * 认证(登录时调用) * 验证当前登录的用户，获取认证信息 */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException { ... return info; } } 纠结了几个小时终于找到了问题所在,因为shiro的realm属于Filter,简单说就是初始化realm时,spring还未加载相关业务Bean,那么解决办法就是将springmvc的配置文件加载提前。 解决办法打开web.xml文件","tags":[{"name":"shiro","slug":"shiro","permalink":"http://wangyuanjun.cn/tags/shiro/"}]},{"title":"树插件ztree异步加载数据与一次性加载全部数据的写法","date":"2017-09-18T13:12:47.000Z","path":"2017/09/18/树插件ztree异步加载数据与一次性加载全部数据的写法/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-parent.github.com用到了ztree树，给大家分享异步加载数据与一次性加载数据的写法 异步加载数据是为了防止大数据量而造成树卡死的情况,代码如下:前台js: &lt;div class=&quot;col-lg-12&quot; style=&quot;height:300px; overflow:scroll;&quot;&gt; &lt;ul id=&quot;treeDemo&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; &lt;/div&gt; function setting() { var setting = { async : { enable : true, type : &quot;get&quot;, url : &apos;${ctx}/menu/renderTree&apos;, autoParam : [ &quot;id&quot;, &quot;type&quot; ] }, callback : { onClick : zTreeOnClick } }; return setting; } $.fn.zTree.init($(&quot;#treeDemo&quot;), setting(treeUrl)); 后台java: @ResponseBody @RequestMapping(value = &quot;/renderTree&quot;, method = RequestMethod.GET) public List&lt;Map&lt;String, Object&gt;&gt; renderTree1(Long id, String type) { List&lt;Map&lt;String, Object&gt;&gt; returnList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); // 加载根节点 if (StringUtils.isEmpty(id)) { Map&lt;String, Object&gt; root = new HashMap&lt;String, Object&gt;(); root.put(&quot;id&quot;, 0);// 根节点的ID root.put(&quot;name&quot;, &quot;权限管理系统&quot;); // 根节点的名字 root.put(&quot;isParent&quot;, true);//// 设置根节点为父节点 // 加载一级节点 List&lt;Map&lt;String, Object&gt;&gt; returnList1 = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); List&lt;Menu&gt; menus = menuService.listOneNodeMenus(); for (Menu menu : menus) { Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;(); node.put(&quot;id&quot;, menu.getMenuId()); node.put(&quot;name&quot;, menu.getName()); node.put(&quot;isParent&quot;, menuService.isSubNodeById(menu.getMenuId())); returnList1.add(node); } root.put(&quot;children&quot;, returnList1); returnList.add(root); return returnList; } // 加载子节点 List&lt;Menu&gt; menus = null; if (id != null &amp;&amp; id &gt; 0L) { menus = menuService.listSubMenuByParentId(id); for (Menu menu : menus) { Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;(); node.put(&quot;id&quot;, menu.getMenuId()); node.put(&quot;name&quot;, menu.getName()); node.put(&quot;isParent&quot;, menuService.isSubNodeById(menu.getMenuId())); returnList.add(node); } } return returnList; } 加载全部数据:前台js &lt;div class=&quot;col-lg-12&quot; style=&quot;height:300px; overflow:scroll;&quot;&gt; &lt;ul id=&quot;treeDemo&quot; class=&quot;ztree&quot;&gt;&lt;/ul&gt; &lt;/div&gt; function setting() { var setting = { data : { simpleData : { enable : true, idKey : &quot;menuId&quot;, pIdKey : &quot;parentId&quot;, rootPId : null }, check: { enable: true, chkStyle: &quot;checkbox&quot;, chkboxType: { &quot;Y&quot;: &quot;ps&quot;, &quot;N&quot;: &quot;ps&quot; } } }; return setting; } } var jsonTree = getDataStore(&apos;${ctx}/auth/renderTree&apos;);//获得所有节点 var ztree=$.fn.zTree.init($(&quot;#treeDemo&quot;), setting(),jsonTree); 后台java: @ResponseBody @RequestMapping(value = &quot;/renderTree&quot;, method = RequestMethod.GET) public List&lt;Menu&gt; renderTree() { return menuService.listTree(); } 希望能对大家有所帮助!","tags":[{"name":"jquery","slug":"jquery","permalink":"http://wangyuanjun.cn/tags/jquery/"},{"name":"ztree","slug":"ztree","permalink":"http://wangyuanjun.cn/tags/ztree/"}]},{"title":"在java中调用存储过程","date":"2017-09-14T01:57:48.000Z","path":"2017/09/14/在java中调用存储过程/","text":"最近在做一个需要调用存储过程的功能，大多数的写法是: Connection conn=null; CallableStatement csmt=null; try { conn=JDBCUtils.getConnection(); conn.setAutoCommit(false); csmt=conn.prepareCall(&quot;call prc_1(?,?,?)&quot;); csmt.setInt(1,80); csmt.setString(2,&quot;ioc&quot;); csmt.setString(3,&quot;fhp&quot;); csmt.execute(); conn.commit(); System.out.println(&quot;success insert data&quot;); } catch (SQLException e) { e.printStackTrace(); } 但是在运用的过程是没有效果的，后来找了另外的方法，使用了jpa注解，代码如下: 存储过程需要依赖在实体上，在实体上加上@NamedStoredProcedureQueries注解，@NamedStoredProcedureQuery中name为java的方法名，procedureName为存储过程的名字，@StoredProcedureParameter中mode代表入参，name是参数名，type是参数类型 @Entity Table(name = &quot;d_cp_delivery&quot;) @NamedStoredProcedureQueries({ @NamedStoredProcedureQuery(name = &quot;closePurchaseorder&quot;, procedureName = &quot;SRMANLI.closePurchaseorder&quot;, parameters = { @StoredProcedureParameter(mode = ParameterMode.IN, name = &quot;i_deliveryid&quot;, type = Long.class) }) }) 2.调用方法如下 //java代码 EntityManager em; @Override @PersistenceContext(unitName = &quot;srment&quot;) public void setEntityManager(EntityManager em) { super.setEntityManager(em); this.em = em; } @Override public void closePurchaseorder(Long deliveryId) { Query qry = em.createNativeQuery(&quot;{call srmanli.closePurchaseorder(?1)}&quot;); qry.setParameter(1, deliveryId); qry.executeUpdate(); em.clear(); } //存储过程 procedure closePurchaseorder(i_deliveryid in number) is v_PurchaseorderDtlNum number; -- v_reqtime date := sysdate; --请求时间 v_err_msg clob; --异常 begin end;","tags":[{"name":"java","slug":"java","permalink":"http://wangyuanjun.cn/tags/java/"}]},{"title":"使用select2下拉框ajax加载数据时,编辑赋值的方法","date":"2017-09-13T16:19:44.000Z","path":"2017/09/14/使用select2下拉框ajax加载数据时-编辑赋值的方法/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-parent.github.com使用bootstrap select2下拉框插件，ajax从后台加载数据，保存编辑后，不知道怎么为下拉框赋值，下拉框代码如下: &lt;label class=&quot;col-sm-1 control-label&quot;&gt;使用状态:&lt;/label&gt; &lt;select id=&quot;sel_status&quot; name=&quot;status&quot; class=&quot;col-sm-3 form-control select2&quot;&gt;&lt;/select&gt; $(&quot;#sel_status&quot;).select2({ placeholder : &quot;--请选择--&quot;, dropdownParent : $(&quot;#myModal&quot;), allowClear : true, width : 150, ajax : { url : &apos;${ctx}/dataDict/getData?groupCode=&apos;+&apos;yesOrNo&apos;, dataType : &apos;json&apos;, type : &apos;get&apos;, data: function (params) { return { q: params.term, // search term 请求参数 page: params.page }; }, processResults: function (data, params) { params.page = params.page || 1; return { results: data,//itemList pagination: { more: (params.page * 30) &lt; data.total_count } }; }, cache: true } }); 通过查询api知道，在select4.0之后可以使用 $(“select”).val(“id”).trigger(“change”);为下拉框赋值你会发现下拉框中的数据是点击之后才会加载数据的，使用如上方法 ‘id’是未知的，原因是在编辑的时候下拉框的数据还没有加载出来 解决方法如下: function getDataByGroupCode(groupCode){ var dataStore; $.ajax({ dataType : &apos;json&apos;, type : &apos;get&apos;, url : model.dataURL+groupCode, async : false, success: function(data){ dataStore=data; } }); return dataStore; } var dataStore = getDataByGroupCode(&apos;yesOrNo&apos;); $(&quot;#sel_status&quot;).select2({ placeholder : &quot;--请选择--&quot;, dropdownParent : $(&quot;#myModal&quot;), allowClear : true, width : 150, minimumResultsForSearch: -1, data : dataStore }); 在页面加载的时候就加载下拉框数据，在编辑时就能为其赋值，问题解决!","tags":[{"name":"select2","slug":"select2","permalink":"http://wangyuanjun.cn/tags/select2/"}]},{"title":"mybatis使用PageHelper插件报错Error creating bean with name sqlSessionFactory defined in class path resource [spring-mybatis.xml]","date":"2017-08-17T13:23:57.000Z","path":"2017/08/17/mybatis使用PageHelper插件报错Error-creating-bean-with-name-sqlSessionFactory-defined-in-class-path-resource-spring-mybatis-xml/","text":"最近在做一个项目,项目地址: https://github.com/wangyuanjun008/wyj-parent.github.com在项目中使用mybatis的分页插件:PageHelper，整合spring后在启动后报错，错误如下: 2017-08-17 21:20:16.618 [ContainerBackgroundProcessor[StandardEngine[Catalina]]] ERROR org.springframework.web.context.ContextLoader - Context initialization failed org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;sqlSessionFactory&apos; defined in class path resource [spring-mybatis.xml]: Invocation of init method failed; nested exception is org.springframework.core.NestedIOException: Failed to parse config resource: class path resource [mybatis-config.xml]; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1553) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:539) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:304) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:300) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:195) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:681) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482) ~[spring-context-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoader.configureAndRefreshWebApplicationContext(ContextLoader.java:403) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:306) ~[spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.web.context.ContextLoaderListener.contextInitialized(ContextLoaderListener.java:106) [spring-web-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4729) [catalina.jar:na] at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5167) [catalina.jar:na] at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) [catalina.jar:na] at org.apache.catalina.core.StandardContext.reload(StandardContext.java:3746) [catalina.jar:na] at org.apache.catalina.loader.WebappLoader.backgroundProcess(WebappLoader.java:292) [catalina.jar:na] at org.apache.catalina.core.StandardContext.backgroundProcess(StandardContext.java:5528) [catalina.jar:na] at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1377) [catalina.jar:na] at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1381) [catalina.jar:na] at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1381) [catalina.jar:na] at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1349) [catalina.jar:na] at java.lang.Thread.run(Thread.java:745) [na:1.8.0_77] Caused by: org.springframework.core.NestedIOException: Failed to parse config resource: class path resource [mybatis-config.xml]; nested exception is org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:434) ~[mybatis-spring-1.2.2.jar:1.2.2] at org.mybatis.spring.SqlSessionFactoryBean.afterPropertiesSet(SqlSessionFactoryBean.java:340) ~[mybatis-spring-1.2.2.jar:1.2.2] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1612) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1549) ~[spring-beans-4.0.2.RELEASE.jar:4.0.2.RELEASE] ... 23 common frames omitted Caused by: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. Cause: java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor at org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XMLConfigBuilder.java:109) ~[mybatis-3.2.6.jar:3.2.6] at org.apache.ibatis.builder.xml.XMLConfigBuilder.parse(XMLConfigBuilder.java:92) ~[mybatis-3.2.6.jar:3.2.6] at org.mybatis.spring.SqlSessionFactoryBean.buildSqlSessionFactory(SqlSessionFactoryBean.java:428) ~[mybatis-spring-1.2.2.jar:1.2.2] ... 26 common frames omitted Caused by: java.lang.ClassCastException: com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor at org.apache.ibatis.builder.xml.XMLConfigBuilder.pluginElement(XMLConfigBuilder.java:142) ~[mybatis-3.2.6.jar:3.2.6] at org.apache.ibatis.builder.xml.XMLConfigBuilder.parseConfiguration(XMLConfigBuilder.java:100) ~[mybatis-3.2.6.jar:3.2.6] ... 28 common frames omitted spring与mybaits集成的配置文件 spring-mybaits.xml &lt;!-- =======================================================================引入配置文件============================================ --&gt; &lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt; &lt;property name=&quot;locations&quot;&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- =======================================================================配置数据源============================================ --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;${driver}&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt; &lt;!-- 初始化连接大小 --&gt; &lt;property name=&quot;initialSize&quot; value=&quot;${initialSize}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大数量 --&gt; &lt;property name=&quot;maxActive&quot; value=&quot;${maxActive}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最大空闲 --&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;${maxIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 连接池最小空闲 --&gt; &lt;property name=&quot;minIdle&quot; value=&quot;${minIdle}&quot;&gt;&lt;/property&gt; &lt;!-- 获取连接最大等待时间 --&gt; &lt;property name=&quot;maxWait&quot; value=&quot;${maxWait}&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- ================================================配置sessionfactory============================================================================== --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/wyj/mapping/auth/*.xml&quot;&gt;&lt;/property&gt; &lt;!-- 引入配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- =================================================装配dao接口================================================================================== --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.wyj.dao.auth&quot; /&gt;&lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- =================================================声明式事务管理================================================================================== --&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; mybatis-config.xml 配置文件(分页插件) &lt;configuration&gt; &lt;plugins&gt; &lt;!-- com.github.pagehelper为PageHelper类所在包名 --&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt; &lt;!-- 设置数据库类型 Oracle,Mysql,MariaDB,SQLite,Hsqldb,PostgreSQL六种数据库 --&gt; &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot; /&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用 --&gt; &lt;!-- 和startPage中的pageNum效果一样--&gt; &lt;property name=&quot;offsetAsPageNum&quot; value=&quot;true&quot;/&gt; &lt;!-- 该参数默认为false --&gt; &lt;!-- 设置为true时，使用RowBounds分页会进行count查询 --&gt; &lt;property name=&quot;rowBoundsWithCount&quot; value=&quot;true&quot;/&gt; &lt;!-- 设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果 --&gt; &lt;!-- （相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt; &lt;property name=&quot;pageSizeZero&quot; value=&quot;true&quot;/&gt; &lt;!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --&gt; &lt;!-- 启用合理化时，如果pageNum&lt;1会查询第一页，如果pageNum&gt;pages会查询最后一页 --&gt; &lt;!-- 禁用合理化时，如果pageNum&lt;1或pageNum&gt;pages会返回空数据 --&gt; &lt;property name=&quot;reasonable&quot; value=&quot;true&quot;/&gt; &lt;!-- 3.5.0版本可用 - 为了支持startPage(Object params)方法 --&gt; &lt;!-- 增加了一个`params`参数来配置参数映射，用于从Map或ServletRequest中取值 --&gt; &lt;!-- 可以配置pageNum,pageSize,count,pageSizeZero,reasonable,orderBy,不配置映射的用默认值 --&gt; &lt;!-- 不理解该含义的前提下，不要随便复制该配置 --&gt; &lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;&quot;/&gt; &lt;!-- 支持通过Mapper接口参数来传递分页参数 --&gt; &lt;property name=&quot;supportMethodsArguments&quot; value=&quot;true&quot;/&gt; &lt;!-- always总是返回PageInfo类型,check检查返回类型是否为PageInfo,none返回Page --&gt; &lt;property name=&quot;returnPageInfo&quot; value=&quot;check&quot;/&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; 经过查找，原来是与mybaitis的jar包版本相差过大，项目运用的是4.1.1的版本，换上5.0.4的版本，重新运行项目，不再抛错。 修改spring-mybatis.xml配置文件如下 修改 sqlSessionFactory &lt;!-- ================================================配置sessionfactory============================================================================== --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;!-- 自动扫描mapping.xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/wyj/mapping/auth/*.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean class=&quot;com.github.pagehelper.PageInterceptor&quot;&gt; &lt;property name=&quot;properties&quot;&gt; &lt;value&gt; &lt;!-- helperDialect：有别于3.0+版本，现在必须是helperDialect，否则spring启动加载时会报错 --&gt; helperDialect=mysql &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 启动不再报错!!!","tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://wangyuanjun.cn/tags/mybatis/"}]},{"title":"试用hexo,换电脑跟新博客","date":"2017-06-29T15:33:55.000Z","path":"2017/06/29/试用hexo-换电脑跟新博客/","text":"作者：skycrown链接：https://www.zhihu.com/question/21193762/answer/103097754来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 1、从官网Git下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建：（1）打开git bash，在用户主目录下运行：ssh-keygen -t rsa -C “youremail@example.com” 把其中的邮件地址换成自己的邮件地址，然后一路回车（2）最后完成后，会在用户主目录下生成.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH key密钥对，id_rsa是私钥，千万不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。（3）登陆GitHub，打开「Settings」-&gt;「SSH and GPG keys」，然后点击「new SSH key」，填上任意Title，在Key文本框里粘贴公钥id_rsa.pub文件的内容（千万不要粘贴成私钥了！），最后点击「Add SSH Key」，你就应该看到已经添加的Key。注意：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。2、下载Node.js，并安装3、打开git bash客户端，输入 npm install hexo-cli -g，开始安装hexo4、下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。（1）讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置_config.yml，theme文件夹里面的主题，以及source里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是scaffolds文件夹（文章的模板）、package.json（说明使用哪些包）和.gitignore（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行hexo init，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。总结：_config.yml，theme/，source/，scaffolds/，package.json，.gitignore，是需要拷贝的。（2）再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是.git文件，无论是在站点根目录下，还是主题目录下的.git文件，都可以删掉。然后是文件夹node_modules（在用npm install会重新生成），public（这个在用hexo g时会重新生成），.deploy_git文件夹（在使用hexo d时也会重新生成），db.json文件。其实上面这些文件也就是是.gitignore文件里面记载的可以忽略的内容。总结：.git/，node_modules/，public/，.deploy_git/，db.json文件需要删除。5、在git bash中切换目录到新拷贝的文件夹里，使用 npm install 命令，进行模块安装。很明显我们这里没用hexo init初始化，因为有的文件我们已经拷贝生成过来了，所以不必用hexo init去整体初始化，如果不慎在此时用了hexo init，则站点的配置文件_config.yml里面内容会被清空使用默认值，所以这一步一定要慎重，不要用hexo init。6、安装其他的一些必要组件，如果在node_modules里面有的，就不要重复安装了：（1）为了使用hexo d来部署到git上，需要安装npm install hexo-deployer-git –save（2）为了建立RSS订阅，需要安装npm install hexo-generator-feed –save（3）为了建立站点地图，需要安装npm install hexo-generator-sitemap –save插件安装后，有的需要对配置文件_config.yml进行配置，具体怎么配置，可以参考上面插件在github主页上的具体说明7、使用hexo g，然后使用hexo d进行部署，如果都没有出错，就转移成功了！","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wangyuanjun.cn/tags/hexo/"}]},{"title":"Hello World","date":"2017-06-29T15:21:26.034Z","path":"2017/06/29/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"修改Weblogic jdk版本","date":"2017-05-17T08:10:45.000Z","path":"2017/05/17/修改Weblogic-jdk版本/","text":"1、E:\\develop-tools\\toolsInstall\\weblogic是我的weblogic安装目录2、E:\\develop-tools\\toolsInstall\\weblogic\\user_projects\\domains\\base_domain是我的域创建目录 找到E:\\develop-tools\\toolsInstall\\weblogic\\user_projects\\domains\\base_domain\\binsetDomainEnv.cmd,修改红框标注的","tags":[{"name":"weblogic","slug":"weblogic","permalink":"http://wangyuanjun.cn/tags/weblogic/"}]},{"title":"Oracle数据库之PL/SQL游标","date":"2017-04-28T06:35:56.000Z","path":"2017/04/28/Oracle数据库之PL-SQL游标/","text":"原文 http://www.cnblogs.com/zf29506564/p/5772344.html 游标概念 字面意思是游动的光标，是指向上下文区域的句柄或指针。 在PL/SQL块中执行CRUD操作时，ORACLE会在内存中为其分配上下文区。用数据库语言来描述游标就是：映射在上下文区结果集中一行数据上的位置实体。 用户可以使用游标访问结果集中的任意一行数据，将游标指向某行后，即可对该行数据进行操作。游标为应用提供了一种对具有多行数据查询结果集中的每一行数据分别进行单独处理的方法，是设计嵌入式SQL语句的应用程序的常用编程方式。 在每个用户会话中，可以同时打开多个游标，其最大数量由数据库初始化参数文件中的OPEN_CURSORS参数定义。 游标可分为显式游标和隐式游标两类。 显式游标 显式游标使用主要有四个步骤： 声明/定义游标打开游标读取数据关闭游标2.1 声明/定义游标 语法： CURSOR cursor_name [(parameter_dec [, parameter_dec ]…)] [RETURN datatype] IS select_statement;示例： DECLARE CURSOR c1 RETURN departments%ROWTYPE; – 声明C1游标 CURSOR c2 IS – 声明C2游标并定义 SELECT employee_id, job_id, salary FROM employees WHERE salary &gt; 2000; CURSOR c1 RETURN departments%ROWTYPE IS – 定义C1游标 SELECT * FROM departments WHERE department_id = 110; CURSOR c3 RETURN locations%ROWTYPE; – 声明C3游标 CURSOR c3 IS – 定义C3游标 SELECT * FROM locations WHERE country_id = ‘JP’; CURSOR c4(sal number) IS – 声明C4游标并定义 SELECT employee_id, job_id, salary FROM employees WHERE salary &gt; sal;BEGIN NULL;END;说明： 在指定参数数据类型时，不能使用长度约束，如C4游标的参数，不能写为number(10,4)这种结构。 [RETURN datatype]是可选的，表示游标返回数据的数据。如果选择，则应该严格与select_statement中的选择列表在次序和数据类型上匹配。一般是记录数据类型（RECORD）或带“%ROWTYPE”的数据。 2.2 打开游标 执行游标所对应的SELECT语句，将其查询结果放入工作区，并且指针指向工作区的首部，标识游标结果集。 语法： OPEN cursor_name [ ( cursor_parameter [ [,] actual_cursor_parameter ]… ) ]示例： OPEN c4 (1300);2.3 读取数据 检索结果集合中的数据行，放入指定的输出变量中。 语法： FETCH { cursor | cursor_variable | :host_cursor_variable } { into_clause | bulk_collect_into_clause [ LIMIT numeric_expression ] } ;执行FETCH语句时，每次返回一个数据行，然后自动将游标移动指向下一个数据行。当检索到最后一行数据时，如果再次执行FETCH语句，将操作失败，并将游标属性%NOTFOUND置为TRUE。所以每次执行完FETCH语句后，检查游标属性%NOTFOUND就可以判断FETCH语句是否执行成功并返回一个数据行，以便确定是否给对应的变量赋了值。 示例： fetch c4 into eid, jid, sal;2.4 关闭游标 当处理完游标结果集合数据后，应及时关闭游标，以释放该游标所占用的系统资源。 关闭游标后不能再使用FETCH语句获取其中数据。关闭后的游标可以使用OPEN语句重新打开。 语法： CLOSE cursor_name;完整示例1： DECLARE – 定义游标 CURSOR c_cursor IS SELECT first_name || last_name, Salary FROM EMPLOYEES WHERE rownum&lt;11; – 声明变量 v_ename EMPLOYEES.first_name%TYPE; v_sal EMPLOYEES.Salary%TYPE;BEGIN – 打开游标 OPEN c_cursor; – 获取数据 FETCH c_cursor INTO v_ename, v_sal; – 处理数据 WHILE c_cursor%FOUND LOOP DBMS_OUTPUT.PUT_LINE(v_ename||’—‘||to_char(v_sal) ); FETCH c_cursor INTO v_ename, v_sal; END LOOP; – 关闭游标 CLOSE c_cursor;END;完整示例2： DECLARE – 定义RECORD记录类型 TYPE emp_record_type IS RECORD( f_name employees.first_name%TYPE, h_date employees.hire_date%TYPE); – 声明记录变量 v_emp_record EMP_RECORD_TYPE; – 定义游标，有参数与返回值 CURSOR c3(dept_id NUMBER, j_id VARCHAR2) RETURN EMP_RECORD_TYPE IS SELECT first_name, hire_date FROM employees WHERE department_id = dept_id AND job_id = j_id; BEGIN – 打开游标，传递参数值 OPEN c3(j_id =&gt; ‘AD_VP’, dept_id =&gt; 90); LOOP FETCH c3 INTO v_emp_record; – 获取数据 IF c3%FOUND THEN DBMS_OUTPUT.PUT_LINE(v_emp_record.f_name||’的雇佣日期是’||v_emp_record.h_date); ELSE DBMS_OUTPUT.PUT_LINE(‘已经处理完结果集了’); EXIT; – 处理完则退出循环 END IF; END LOOP; CLOSE c3; –关闭游标END; 显式游标属性 游标的状态（如是否打开，获取了多少行数据等）可以使用游标属性来获取。 游标属性以“%属性名”的形式加在游标名之后。显式游标属性有： 属性名 说明%FOUND 如果记录成功获取，返回TRUE，否则返回FALSE%NOTFOUND 如果记录获取失败，返回TRUE，否则返回FALSE%ROWCOUNT 返回已经从游标中获取的记录数%ISOPEN 如果游标是打开的，返回TRUE，否则返回FALSE示例： DECLARE v_empno EMPLOYEES.EMPLOYEE_ID%TYPE; v_sal EMPLOYEES.Salary%TYPE; – 定义游标 CURSOR c_cursor IS SELECT EMPLOYEE_ID, Salary FROM EMPLOYEES;BEGIN – 打开游标 OPEN c_cursor; LOOP – 获取数据 FETCH c_cursor INTO v_empno, v_sal; EXIT WHEN c_cursor%NOTFOUND; – 未读取到记录，则退出循环 IF v_sal&lt;=1200 THEN UPDATE EMPLOYEES SET Salary=Salary+50 WHERE EMPLOYEE_ID=v_empno; DBMS_OUTPUT.PUT_LINE(‘编码为’||v_empno||’工资已更新!’); END IF; DBMS_OUTPUT.PUT_LINE(‘记录数:’|| c_cursor %ROWCOUNT); END LOOP; – 关闭游标 CLOSE c_cursor;END; 基于游标定义记录变量 使用%ROWTYPE属性不仅可以基于表和视图定义记录变量，也可以基于游标定义记录变量。当基于游标定义记录变量时，记录成员名实际就是SELECT语句的列名和列别名。 为了简化显式游标的数据处理，建议使用基于游标的记录变量存放游标数据。基于游标定义记录变量，比声明记录类型变量要方便，不容易出错。 示例： DECLARE – 定义游标 CURSOR emp_cursor IS SELECT ename,sal FROM emp； emp_reocrd emp_cursor%ROWTYPE；– 游标变量BEGIN – 打开游标 OPEN emp_cursor； LOOP – 获取记录 FETCH emp_cursor INTO emp_record； EXIT WHEN emp_record%NOTFOUND； dbms_ouput.put_line(‘雇员名:’||emp_record.ename||’,雇员工资:’||emp_record.sal)； END LOOP； – 关闭游标 CLOSE emp_cursor；END； 隐式游标 如果在PL/SQL块中使用了SELECT语句进行操作，PL/SQL会隐含处理游标定义，而对于非查询语句，如修改、删除操作，则由ORACLE系统自动地为这些操作设置游标并创建其工作区。由系统隐含创建的游标称为隐式游标，隐式游标的名字为SQL。 对于隐式游标的操作，如定义、打开、取值及关闭操作，都由ORACLE 系统自动地完成，无需用户进行处理。用户只能通过隐式游标的相关属性，来完成相应的操作。在隐式游标的工作区中，所存放的数据是与用户自定义的显示游标无关的、最新处理的一条SQL语句所包含的数据。 隐式游标的属性： 属性名 说明SQL%FOUND 如果记录成功获取，返回TRUE，否则返回FALSESQL%NOTFOUND 如果记录获取失败，返回TRUE，否则返回FALSESQL%ROWCOUNT 返回已经从游标中获取的记录数SQL%ISOPEN 如果游标是打开的，返回TRUE，否则返回FALSE隐式游标在INSERT，UPDATE，DELETE，SELECT语句中不必明确定义游标。 示例： DECLARE v_rows NUMBER;BEGIN – 更新表数据 UPDATE employees SET salary = 5000 WHERE department_id = 90 AND job_id = ‘AD_VP’; – 获取受影响行数 v_rows := SQL%ROWCOUNT; DBMS_OUTPUT.PUT_LINE(‘更新了’||v_rows||’个员工的工资’);END; 游标FOR循环 游标FOR循环和显示游标的一种快捷使用方式，它使用FOR循环依次读取结果集中的行数据，当FOR循环开始时，游标自动打开（不需要OPEN）,每循环一次系统自动读取游标当前行的数据（不需要FETCH)，当退出FOR循环时，游标被自动关闭（不需要使用CLOSE）使用游标FOR循环的时候不能使用OPEN语句，FETCH语句和CLOSE语句，否则会产生错误。 语法： FOR index_variable IN cursor_name[(value[, value]…)] LOOP – 游标处理语句END LOOP;示例： DECLARE CURSOR emp_cur(vartype number) IS SELECT emp_no,emp_zc FROM cus_emp_basic WHERE com_no=vartype;BEGIN FOR person IN emp_cur(123) LOOP DBMS_OUTPUT.PUT_LINE(‘编号:’||person.emp_no||’,地址:’||person.emp_zc);END LOOP;END; 使用显示游标修改数据 在PL/SQL中依然可以使用UPDATE和DELETE语句更新或删除数据行。显式游标只有在需要获得多行数据的情况下使用。PL/SQL提供了仅仅使用游标就可以执行删除或更新记录的方法。 UPDATE或DELETE语句中的WHERE CURRENT OF子句专门处理要执行UPDATE或DELETE操作的表中取出的最近的数据。要使用这个方法，在声明游标时必须使用FOR UPDATE子句，当使用FOR UPDATE子句打开一个游标时，所有返回集中的数据行都将处于行级（ROW-LEVEL)独占式锁定，其他对象只能查询这些数据行，不能进行UPDATE、DELETE或SELECT…FOR UPDATE操作。 语法： FOR UPDATE [OF [schema.]table.column[,[schema.]table.column]..[NOWAIT]在多表查询中，使用OF子句来锁定特定的表,如果忽略了OF子句，那么所有表中选择的数据行都将被锁定。如果这些数据行已经被其他会话锁定，那么正常情况下ORACLE将等待，直到数据行解锁。当加上NOWAIT子句时，如果这些行真的被另一个会话锁定，则OPEN立即返回并给出： ORA-00054 ：resource busy and acquire with nowait specified.在UPDATE和DELETE中使用WHERE CURRENT OF子串的语法如下： WHERE{CURRENT OF cursor_name|search_condition}示例： DELCARE CURSOR c1 IS SELECT empno,salary FROM emp WHERE comm IS NULL FOR UPDATE OF comm; v_comm NUMBER(10,2);BEGIN FOR r1 IN c1 LOOP IF r1.salary&lt;500 THEN v_comm:=r1.salary0.25; ELSEIF r1.salary&lt;1000 THEN v_comm:=r1.salary0.20; ELSEIF r1.salary&lt;3000 THEN v_comm:=r1.salary0.15; ELSE v_comm:=r1.salary0.12; END IF; UPDATE emp SET comm=v_comm WHERE CURRENT OF c1; END LOOP;END 游标变量 与游标类似，游标变量指向多行查询的结果集的当前行。但是，游标与游标变量是不同的，就像常量和变量的关系一样。游标是静态的，游标变量是动态的，因为它不与特定的查询绑定在一起。 8.1 声明游标变量 语法： TYPE ref_type_name IS REF CURSOR [ RETURN return_type];说明： 游标变量类型有强类型定义和弱类型定义两种。强类型定义必须指定游标变量的返回值类型，而弱类型定义则不说明返回值类型。 return_type为游标变量的返回值类型，它必须为记录变量。 示例： – 定义一个REF CURSOU类型TYPE ref_cursor_type IS REF CURSOR;– 声明一个游标变量cv_ref REF_CURSOR_TYPE;8.2 游标变量的使用 与游标一样，游标变量操作也包括打开、提取和关闭三个步骤。 8.2.1 打开游标变量 语法： OPEN {cursor_variable_name | :host_cursor_variable_name}FOR select_statement;说明： host_cursor_variable_name为PL/SQL主机环境（如OCI: ORACLE Call Interface，Pro*c 程序等）中声明的游标变量。 OPEN…FOR 语句可以在关闭当前的游标变量之前重新打开游标变量，而不会导致CURSOR_ALREAD_OPEN异常错误。新打开游标变量时，前一个查询的内存处理区将被释放。 8.2.2 提取数据 语法： FETCH {cursor_variable_name | :host_cursor_variable_name}INTO {variable [, variable]…| record_variable};说明： 将提取到的数据放入普通变量和记录变量中存放。 8.2.3 关闭游标 语法： CLOSE {cursor_variable_name | :host_cursor_variable_name}说明： 如果应用程序试图关闭一个未打开的游标变量，则将导致INVALID_CURSOR异常错误。 示例1： DECLARETYPE ref_type_table IS REF CURSOR;v_cursor ref_type_table;emp_record emp%rowtype;BEGIN OPEN v_cursor FOR select * from emp where deptno=&no; LOOP FETCH v_cursor INTO emp_record; EXIT WHEN v_cursor%NOTFOUND; dbms_output.put_line(‘员工号：’||emp_record.ename||’部门号：’||emp_record.deptno); END LOOP; CLOSE v_cursor;END;示例2： DECLARE emp_record emp%rowtype; TYPE ref_type_table IS REF CURSOR RETURN emp%rowtype; v_cursor ref_type_table;BEGIN OPEN v_cursor FOR select * from emp where deptno=&no; LOOP FETCH v_cursor INTO emp_record; EXIT WHEN v_cursor%NOTFOUND; dbms_output.put_line(‘员工号：’||emp_record.ename||’部门号：’||emp_record.deptno); END LOOP; CLOSE v_cursor;END; DECLAREType emp_record_type IS RECORD( ename emp.ename%TYPE, salary emp.sal%TYPE, deptno emp.deptno%TYPE);emp_record emp_record_type; TYPE ref_type_table IS REF CURSOR RETURN emp_record_type;v_cursor ref_type_table;BEGIN OPEN v_cursor FOR select ename,sal,deptno from emp where deptno=&no; LOOP FETCH v_cursor INTO emp_record; EXIT WHEN v_cursor%NOTFOUND; dbms_output.put_line(‘员工号：’||emp_record.ename||’，部门号：’||emp_record.deptno||’，工资：’||emp_record.salary); END LOOP; CLOSE v_cursor;END; 使用游标批量获取 语法： FETCH … BULK COLLECT INTO …[LIMIT row_number];说明： 使用BULK COLLECT，我们可以用对数据库的一个来回，返回多行数据。BULK COLLECT减少了PL/SQL和SQL引擎之间的上下文开关数目，因而加速了数据获取的速度。 示例： DECLARE CURSOR emp_cursor(v_deptno number) IS SELECT * FROM EMP WHERE deptno = v_deptno; TYPE type_emp_table IS TABLE OF emp%ROWTYPE INDEX BY BINARY_INTEGER; emp_table type_emp_table; v_dno emp.deptno%TYPE;BEGIN v_dno := &no; OPEN emp_cursor(v_dno); FETCH emp_cursor BULK COLLECT INTO emp_table; CLOSE emp_cursor; FOR i IN 1..emp_table.COUNT LOOP dbms_output.put_line(‘员工号：’||emp_table(i).ename||’工资：’||emp_table(i).sal); END LOOP; CLOSE emp_cursor;END; 游标表达式 游标表达式作用是用于返回嵌套游标。语法： CURSOR(sub_query)示例： DECLARE CURSOR dept_emp_cursor(v_deptno number) IS SELECT dname,cursor(SELECT * FROM emp e WHERE e.deptno = d.deptno) FROM dept d WHERE deptno = v_deptno; TYPE emp_cursor_type IS REF CURSOR; emp_cursor emp_cursor_type; emp_record emp%ROWTYPE; v_name dept.dname%TYPE; v_dno emp.deptno%TYPE;BEGIN v_dno := &no; OPEN dept_emp_cursor(v_dno); loop FETCH dept_emp_cursor INTO v_name,emp_cursor; EXIT WHEN dept_emp_cursor%NOTFOUND; dbms_output.put_line(‘部门名称：’||v_name); LOOP FETCH emp_cursor INTO emp_record; EXIT WHEN emp_cursor%NOTFOUND; dbms_output.put_line(‘员工名称：’||emp_record.ename||’，工资：’||emp_record.sal); END LOOP; end loop; CLOSE dept_emp_cursor;END;","tags":[]},{"title":"跨Oracle数据库实现表级别的实时同步","date":"2017-04-28T05:49:50.000Z","path":"2017/04/28/跨Oracle数据库实现表级别的实时同步/","text":"一. 问题描述 有两个Oracle数据库，分别布置在不同的服务器上，系统均为windows2003； 这里暂且说成是一个主数据库和从数据库： (1) 主数据库: oracle_A ； (2) 从数据库: oracle_B ； 在oracle_A中有一个表table_A与oracle_B中的表table_B 结构相同 ； 我是处在oracle_B，oracle_A数据库分配给我有一个访问oracle_A表table_A的用户，该用户 只拥有查询的权限 ； 另外，需要 说明的一点 ，就是在oracle_B处,只需对table_B表进行查询的操作，不进行其他增删改的操作。 场景介绍完了， 我的问题 的是,如何在oracle_A中表table_A发生变化时,实时更新同步到oracle_B的table_B中? 我原来的处理方式: 通过建立远程连接DBLink+JOB定时任务+存储过程的方式,实现了定时同步 更新,但不能做到实时同步 。 二. 采用同义词+DB_Link的方式结果步骤 之所以能够选择采用同义词的方式，处理这个问题。主要还是源于在问题描述中提到一个点，那就是我们只需要对同步后的表进行 查询 操作。这点是使用同义词方式的重要要素。 下面详细模拟一下整个实验测试的过程： （1）首先在Oracle_A端创建一个对table_A只有查询功能的用户 创建用户 sqlplus /nolog conn /as sysdba; create user username identified by password; 查看所有的用户列表 用户创建完成后,查看用户是否创建成功 select * from all_users; 授予权限 为了能够保证能够登陆,必须赋予如下权限 –授予username用户创建session的权限,即登陆权限 grant create session to username; –授予username用户使用表空间的权限 grant unlimited tablespace to username; –oracle对权限管理比较严谨,普通用户之间也是默认不能互相访问的,需要互相授权. –如果scott用户要授权给username用户查看自己的test表的权限; sqlplus scott/tiget@localhost:1521/orcl –授予username用户查看指定的权限 grant select on test to username; –撤销权限 基本语法同grant,关键字为revoke;（2）验证用户是否可以成功登录，并进行访问授权的表 –使用sqlplus登录，并进行查询sqlplus username/password@localhost:1521/orcl;select * from scott.test;注意：查询表时，务必带上用户名，说明是哪个用户下的表。 （3）创建远程连接DB_Link 创建远程连接 db_linkcreate public database link db32 connect to tianzhi_test identified by “tianzhi_test” using ‘192.168.56.6:1521/ORCL’ 测试远程连接是否成功select * from tianzhi_smart.zh_item_news@db32;（4）在Oracle_B端创建同义词 使用sqlplus登录自己的用户sqlplus tianzhi_smart/tianzhi_smart@localhost:1521/orcl 创建同义词create or replace public synonym TEST1130 for scott.TEST@db32; 查询测试select * from TEST1130;可以看到这与在Oracle_A源数据库中查到的table_A表中的数据一样.注意事项: 当远程查询的数据库中包含BLOB字段时,会报出如下错误. ORA-22992: 无法使用从远程表选择的 LOB 定位器 当出现这个错误的时候，那是因为跨库连接查询中的表中存在BLOB类型的字段，所以一定要注意，所有表中存在blob类型字段， 不能用 select * from 连接的表不能将blob类型的字段出现在脚本中。如果这些blob类型的字段一定要导过来，可以先建立临时表再插入本地表，方法如下.在pl/sql中执行 第一步 建临时表 create global temporary table foo ( X BLOB ) on commit delete rows; 第二步 插入本地表 insert into foo select blobcolumn from remoteTable@dl_remote ;","tags":[{"name":"oracle","slug":"oracle","permalink":"http://wangyuanjun.cn/tags/oracle/"}]},{"title":" 解决“Dynamic Web Module 3.0 requires Java 1.6 or newer.”错误","date":"2017-03-30T13:23:16.000Z","path":"2017/03/30/解决“Dynamic-Web-Module-3-0-requires-Java-1-6-or-newer-”错误/","text":"eclipse maven在项目的pom.xml的标签中加入： org.apache.maven.plugins maven-compiler-plugin 2.3.2 1.6 1.6 保存，项目构建完成后在项目文件夹上点右键，选择Maven-&gt;Update Project Configuration，问题解决。","tags":[{"name":"maven","slug":"maven","permalink":"http://wangyuanjun.cn/tags/maven/"}]},{"title":"Extjs中textfield的悬浮提示","date":"2017-02-22T05:56:35.000Z","path":"2017/02/22/Extjs中textfield的悬浮提示/","text":"在Extjs中有时候我们需要textfield的提示信息，但是我们发现textfield并没有这样的配置项。这时候我们就要另想方法：我们需要在鼠标悬停在textfield组件的时候进行信息的提示，我们就需要在textfield中来监听，这里有两种进行textfield悬停提示的方法： 进行固定信息的提示：需要在监听中用render方法render: function (field, p) { Ext.QuickTips.init(); Ext.QuickTips.register({ target: field.el, text: &apos;这是textfield的固定信息提示！&apos; }) } 进行文本信息提示：提示信息为textfield的文本信息 var updateTip = function (field, t) { Ext.QuickTips.init(); Ext.QuickTips.register({ target: field.el, text: field.getValue() }) }; listeners: { // 鼠标移动到文本框显示悬浮框 render : function(p) { p.getEl().on(&apos;mouseover&apos;, function(p1) { updateTip(p); }); } }","tags":[{"name":"extjs","slug":"extjs","permalink":"http://wangyuanjun.cn/tags/extjs/"}]},{"title":"Redis基础命令","date":"2017-02-21T14:51:21.000Z","path":"2017/02/21/Redis基础命令/","text":"笔者最初接触Redis是因为了解了一些nosql方面的知识，觉得nosql是一个很有意思的方面。像其中的mongodb，redis等等。当初也没有深入的去了解Redis，直到自己前段时间在写一个web项目的时候需要用到缓存来进行性能优化我才仔细的来学习Redis。下面我就来说说我自己在学习Redis过程中的一些心得。 Redis是一个nosql数据库，它采用字典结构以键值对的形式将数据全部存储在内存中所以它读写的速度很快，因此很多项目用Redis做缓存用，我也是基于这个想法来学习Redis的。 Redis支持的数据类型分别是字符串(string)、散列(hash)、列表(list)、集合(set)、有序集合(sorted set)这五种。接下来我将仔细介绍下这几种数据结构的用法和对应的命令。 字符串类型 ：字符串类型是Redis中 最 基本 的数 据类型，是其他四种数据类型的基础。它能存储任何形式的字符串(二进制数据、Json对象、图片等)，它的最大数据容量是512MB。常用命令: set key value //赋值 get key //取值 keys * //查看所有的键 exists key //判断某个键是否存在 del key //删除一个键 type key //获取键的类型 incr/decr key //给键增加/减少一 incrby/decrby key increment/decrement //给键增加/减少一个整数 incrbyfloat key increment //增加浮点数 strlen key //返回键的长度 mset/mget //同时设置或者获取多个值 散列类型 ：散列类型的键值是一种字典结构，存储了字段和字段值的映射。但是字段值只能是字符串，不支持其他数据类型(Redis的其他数据类型也都不支持嵌套，只能是字符串。)。常用命令： hset key field value //赋值。不区分插入和更新操作，当键不存在是会自动建立。 hget key field //取值 hgetall key //取出所有的值 hexists key field //判断字段是否存在 hsetnx key field value //字段不存在时便赋值 hincrby key field increment //增加指定的数字，没有自增 hdel key field //删除一个或者多个字段，返回被删除的个数 hkeys key //只获取字段名 hvals key //只获取字段值 hlen key //只获取字段数量 列表类型 ：列表是个有序的字符串，向两端添加或者删除元素。它是使用双向链表实现的。常用命令: lpush/rpush list value //向左/右增加元素 lpop/rpop list //从左/右弹出元素 llen list //获列表的元素个数 lrange list start stop //获得列表片段(左边索引为0，如果为负则从右边开始) lrange key -1 0 则为获取所有的元素 lrem list count value //删除列表中前count个值为value的元素 rpoplpush oldlist newlist //将原列表的值放入新列表 集合类型 : 集合中的元素都是不同的，而且没有顺序。它可以求交集、并集、差集。常用命令: sadd set member //增加一个元素给集合(没有则创建) srem set member //删除一个或多个元素 smembers set //返回集合中所有的元素 sismember set member //判断元素是否存在于集合中 sdiff setA setB //求差集 sinter setA setB //求交集 sunion setA setB //求并集 sdiffstore destination setA setB //将求到的差集结果保存在destination中 srandmember set num //随机获取一个或多个元素(看后面加的参数) spop set //从集合中随机弹出一个元素 有序集合: 和集合相比给每个元素都关联了个分数。我们除了可以进行集合的操作外，还可以获取分数最高或者最低的几个元素。常用命令: zadd key score member //加入元素和对应分数，支持整数和双精度浮点，如果存在则修改。其中+inf和-inf代表正负无穷大 zscore key member //获得元素的分数 zrange/zrevrange key start stop //按分数从顺序/逆序排序 zrangebyscore key min (max //返回min和max之间的数左括号代表不包含 zincrby key increment member //给元素增加值 zcount key min max //获取指定范围元素的个数 zcard key //获取集合中元素的数量 zrem key member //删除元素 zremrangebyrank key start stop //按排名范围删除元素 zremrangebyscore key min max //删除分数范围值 zrank key member //元素按分数大小排名 zrevrank key member //从大到小排名 结语:个人学习总结有遗漏错误的地方还希望大家留言斧正，多多交流一起学习。","tags":[{"name":"redis","slug":"redis","permalink":"http://wangyuanjun.cn/tags/redis/"}]},{"title":"阿里巴巴 Java 开发手册 笔记及重点","date":"2017-02-21T13:58:21.000Z","path":"2017/02/21/阿里巴巴-Java-开发手册-笔记及重点/","text":"编程规约1. POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。假设定义一个 boolean 的 isSuccess 属性，它的方法 Getter 被IDE生成为 isSuccess()，RPC等三方框架在反向解析的时候，“以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。这点也是笔者之前遇到过的，查了很久哪里的错最后发现是这个问题，不过经历一次后基本后面就能避免。 2. 接口类中的方法和属性不要加任何修饰符号。包括在一些开源的代码里，笔者也经常看见在接口方法上声明 public 关键字的，这是冗余的，在Java规范中提到过。关于代码的规范及简洁性诸位可以参考《重构 改善既有代码的设计》 及 代码整洁之道。 3. 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。不过没有必要插入多行空格进行隔开。这样可读性会明显提高，笔者经常看到部分开发人员的代码在很长的代码块里完全没有一个空行，没有按逻辑进行换行，这种习惯是不太好的。 4. 所有的覆写方法，必须加 @Override 注解。这样IDE会检查合法性，有错误的话会及时提示。 5. 所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。比如 Integer 的-128至127之间被缓存的对象可以直接使用==判断，因为被缓存了，是同一对象，地址相等，而这个区间外的却不能使用==判断，这也是面试时的一个常考点。 6. 关于基本数据类型与包装数据类型：所有的POJO类属性必须使用包装数据类型，以便映射数据库中的NULL，局部变量推荐使用基本数据类型。 7. 关于 hashCode 和 equals 的处理，遵循如下规则：只要重写 equals，就必须重写 hashCode，具体原因可参考《Effective java 中文版（第2版）》。 8. 关于 ArrayList 里 subList 结果的注意事项，subList 只是 ArrayList 的一个视图，这部分大家可以参考JDK里的源码。 9. 不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。 10. 在 JDK7 版本以上，Comparator 要满足自反性，传递性，对称性，不然 Arrays.sort， Collections.sort 会报 IllegalArgumentException 异常。这个在《Effective java 中文版（第2版）》中也有说明，虽然笔者之前看过，但在刚实习时的一个用于省份排序的代码里使用 Comparator 时还是忘了处理值相等的情况，所以，还是要实战后才能加深记忆。 11. 集合初始化时，尽量指定集合初始值大小。这在笔者实习面试时也被问到，这块的话主要考察 ArrayList 的原理，内部机制，诸位看看JDK里 ArrayList 的原理就明白了。 12. 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 13. 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。概括为一句话就是：尽量降低锁的粒度。 14. 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。关于并发这块可以参考《Java并发编程实战》，个人认为这本在笔者看过Java并发的书籍里能算上乘之作，另外也可参考《Java并发编程的艺术》。 15. 通过双重检查锁(double-checked locking)(在并发场景)实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问题解决方案中较为简单一种(适用于 JDK5 及以上版本)，将目标属性声明为 volatile 型。这部分涉及到两个重点，一是双重检查锁，二是 volatile 的原理及Java的主内存及每个线程的内存之间的关系。volatile只能解决多线程时的内存可见性问题，无法解决线程安全问题。可参考Double checked locking 及 Initialization on demand holder idiom。 16. 注释掉的代码尽量要配合说明，而不是简单的注释掉。如果永久不用，建议直接删除，因为Git等版本控制系统保存了历史代码。 17. 好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免无用的注释。 18. 善用 TODO 及 FIXME，IDE可以方便的进行扫描。 19. 获取当前毫秒数使用 System.currentTimeMillis()，System.nanoTime()产生的值仅用于比较，同一时刻不同虚拟机System.nanoTime()返回的值可能不一样并且相差很大，笔者的同事已经踩过一次坑，关于 nanoTime 诸位可以看一看JavaDoc。 异常日志1. 不要捕获Java类库中定义的继承自 RuntimeException 的运行时异常类，如：IndexOutOfBoundsException / NullPointerException，这类异常由程序员预检查来规避，保证程序健壮性。说到这里，异常继承结构图也可以看下。 2. 捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 3. 避免出现重复的代码(Don’t Repeat Yourself)，即DRY原则。关于这部分可参考《程序员修炼之道》。 4. 谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。关于日志把server磁盘撑爆的问题，我司也出现过，后面加了相关监控来避免。 MySQL规约1. 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint (1表示是，0表示否)，此规则同样适用于odps建表。任何字段如果为非负数，必须是 unsigned。因为这样的话可用容量提升了一倍。 2. 表名不使用复数名词。表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。 3. 禁用保留字，如 desc、range、match、delayed 等，禁止在代码里对 SQL 关键字进行单独处理。 4. 唯一索引名为 uk_字段名，普通索引名则为 idx_字段名。这样能让开发人员一眼就知道相关索引。 5. 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 6. 表必备三字段:id, gmt_create, gmt_modified。其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create, gmt_modified 的类型均为 date_time 类型。创建时间与修改时间需要记录笔者理解，不理解的为什么要用 gmt 开头，北京时间应该是GMT + 8:00 啊。 7. 字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：不是频繁修改的字段；不是 varchar 超长字段，更不能是 text 字段。比如我司的很多表都冗余了 user_name 这个字段。 8. 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。 9. 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。即使在应用层做了非常完善的校验和控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 10. 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。关于 MySQL 的知识，诸位可参考《高性能MySQL》。 11. 利用延迟关联或者子查询优化超多分页场景。MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。 12. 建组合索引的时候，区分度最高的在最左边。 13. 不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)就是 SQL92 定义 的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。 14. 不得使用外键与级联，一切外键概念必须在应用层解决。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 15. 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 16. 数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。 工程规约1. 高并发服务器建议调小 TCP 协议的 time_wait 超时时间。 2. 调大服务器所支持的最大文件句柄数(File Descriptor，简写为fd)。 3. 给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。 安全规约1. 隶属于用户个人的页面或者功能必须进行权限控制校验。 2. 用户敏感数据禁止直接展示，必须对展示数据脱敏。 3. 用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入， 禁止字符串拼接 SQL 访问数据库。 4.用户请求传入的任何参数必须做有效性验证。 5.表单、AJAX 提交必须执行 CSRF 安全过滤。 6.在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制， 如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。 7.关于安全这块可以阅读《白帽子讲Web安全》。 阿里巴巴Java开发手册","tags":[{"name":"编码规范","slug":"编码规范","permalink":"http://wangyuanjun.cn/tags/编码规范/"}]},{"title":"spring 读取properties的两种方法","date":"2017-02-21T13:47:12.000Z","path":"2017/02/21/spring-读取properties的两种方法/","text":"1.在配置文件中配置PropertyPlaceholderConfigurer 然后在需要的地方直接以下方式引用： 2.在配置文件中加入beans的命名空间声明如下： 用到了xmlns:context=http://www.springframework.org/schema/context配置如下：","tags":[{"name":"spring","slug":"spring","permalink":"http://wangyuanjun.cn/tags/spring/"}]},{"title":"SpringMVC与LogBack集成","date":"2017-02-14T05:01:16.000Z","path":"2017/02/14/SpringMVC与LogBack集成/","text":"最近在做项目中需要用到日志，本来选取的是Log4j，最后经过对比之后还是发现LogBack在性能上比Log4j有优势。至于有什么好处，请参考下面这篇文章。从Log4j迁移到LogBack的理由 下面废话不多说了，就看一下，如何来把LogBack集成到我们的web项目中吧。本人前台用的是SpringMVC。 jar包配置 如果要使用LogBack做为日志的插件的话，需要的jar包有如下，直接看一下Maven依赖 org.slf4j slf4j-api 1.7.12 ch.qos.logback logback-classic 1.1.3 compile slf4j-api org.slf4j &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-access&lt;/artifactId&gt; &lt;version&gt;1.1.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/span&gt; Web.xml 在web项目中需要通过web.xml来加载我们所需要的LogBack.xml具体如下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- logback-begin --&gt; &lt;context-param&gt; &lt;param-name&gt;logbackConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:logback.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;com.util.LogbackConfigListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- logback-end --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:springMVC-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 这里一定要是/根据Servlet规范来的 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 上面的XML中用到了自定义的监听器，分别是三个类，如下所示 LogbackConfigListener类 package com.util; import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener; public class LogbackConfigListener implements ServletContextListener { public void contextInitialized(ServletContextEvent event) { LogbackWebConfigurer.initLogging(event.getServletContext()); } public void contextDestroyed(ServletContextEvent event) { LogbackWebConfigurer.shutdownLogging(event.getServletContext()); } } LogbackConfigurer类 package com.util; import java.io.File;import java.io.FileNotFoundException;import java.net.URL; import org.slf4j.LoggerFactory;import org.springframework.util.ResourceUtils;import org.springframework.util.SystemPropertyUtils; import ch.qos.logback.classic.LoggerContext;import ch.qos.logback.classic.joran.JoranConfigurator;import ch.qos.logback.core.joran.spi.JoranException; public abstract class LogbackConfigurer { /** Pseudo URL prefix for loading from the class path: &quot;classpath:&quot; */ public static final String CLASSPATH_URL_PREFIX = &quot;classpath:&quot;; /** Extension that indicates a logback XML config file: &quot;.xml&quot; */ public static final String XML_FILE_EXTENSION = &quot;.xml&quot;; private static LoggerContext lc = (LoggerContext) LoggerFactory .getILoggerFactory(); private static JoranConfigurator configurator = new JoranConfigurator(); /** * Initialize logback from the given file location, with no config file * refreshing. Assumes an XML file in case of a &quot;.xml&quot; file extension, and a * properties file otherwise. * * @param location * the location of the config file: either a &quot;classpath:&quot; * location (e.g. &quot;classpath:mylogback.properties&quot;), an absolute * file URL (e.g. * &quot;file:C:/logback.properties), or a plain absolute path in the file system (e.g. &quot; * C:/logback.properties&quot;) * @throws FileNotFoundException * if the location specifies an invalid file path */ public static void initLogging(String location) throws FileNotFoundException { String resolvedLocation = SystemPropertyUtils .resolvePlaceholders(location); URL url = ResourceUtils.getURL(resolvedLocation); if (resolvedLocation.toLowerCase().endsWith(XML_FILE_EXTENSION)) { // DOMConfigurator.configure(url); configurator.setContext(lc); lc.reset(); try { configurator.doConfigure(url); } catch (JoranException ex) { throw new FileNotFoundException(url.getPath()); } lc.start(); } // else { // PropertyConfigurator.configure(url); // } } /** * Shut down logback, properly releasing all file locks. * &lt;p&gt; * This isn&apos;t strictly necessary, but recommended for shutting down logback * in a scenario where the host VM stays alive (for example, when shutting * down an application in a J2EE environment). */ public static void shutdownLogging() { lc.stop(); } /** * Set the specified system property to the current working directory. * &lt;p&gt; * This can be used e.g. for test environments, for applications that * leverage logbackWebConfigurer&apos;s &quot;webAppRootKey&quot; support in a web * environment. * * @param key * system property key to use, as expected in logback * configuration (for example: &quot;demo.root&quot;, used as * &quot;${demo.root}/WEB-INF/demo.log&quot;) * @see org.springframework.web.util.logbackWebConfigurer */ public static void setWorkingDirSystemProperty(String key) { System.setProperty(key, new File(&quot;&quot;).getAbsolutePath()); } } LogbackWebConfigurer类 package com.util; import java.io.FileNotFoundException; import javax.servlet.ServletContext; import org.springframework.util.ResourceUtils;import org.springframework.util.SystemPropertyUtils;import org.springframework.web.util.WebUtils; public abstract class LogbackWebConfigurer { /** Parameter specifying the location of the logback config file */ public static final String CONFIG_LOCATION_PARAM = &quot;logbackConfigLocation&quot;; /** * Parameter specifying the refresh interval for checking the logback config * file */ public static final String REFRESH_INTERVAL_PARAM = &quot;logbackRefreshInterval&quot;; /** Parameter specifying whether to expose the web app root system property */ public static final String EXPOSE_WEB_APP_ROOT_PARAM = &quot;logbackExposeWebAppRoot&quot;; /** * Initialize logback, including setting the web app root system property. * * @param servletContext * the current ServletContext * @see WebUtils#setWebAppRootSystemProperty */ public static void initLogging(ServletContext servletContext) { // Expose the web app root system property. if (exposeWebAppRoot(servletContext)) { WebUtils.setWebAppRootSystemProperty(servletContext); } // Only perform custom logback initialization in case of a config file. String location = servletContext .getInitParameter(CONFIG_LOCATION_PARAM); if (location != null) { // Perform actual logback initialization; else rely on logback&apos;s // default initialization. try { // Return a URL (e.g. &quot;classpath:&quot; or &quot;file:&quot;) as-is; // consider a plain file path as relative to the web application // root directory. if (!ResourceUtils.isUrl(location)) { // Resolve system property placeholders before resolving // real path. location = SystemPropertyUtils .resolvePlaceholders(location); location = WebUtils.getRealPath(servletContext, location); } // Write log message to server log. servletContext.log(&quot;Initializing logback from [&quot; + location + &quot;]&quot;); // Initialize without refresh check, i.e. without logback&apos;s // watchdog thread. LogbackConfigurer.initLogging(location); } catch (FileNotFoundException ex) { throw new IllegalArgumentException( &quot;Invalid &apos;logbackConfigLocation&apos; parameter: &quot; + ex.getMessage()); } } } /** * Shut down logback, properly releasing all file locks and resetting the * web app root system property. * * @param servletContext * the current ServletContext * @see WebUtils#removeWebAppRootSystemProperty */ public static void shutdownLogging(ServletContext servletContext) { servletContext.log(&quot;Shutting down logback&quot;); try { LogbackConfigurer.shutdownLogging(); } finally { // Remove the web app root system property. if (exposeWebAppRoot(servletContext)) { WebUtils.removeWebAppRootSystemProperty(servletContext); } } } /** * Return whether to expose the web app root system property, checking the * corresponding ServletContext init parameter. * * @see #EXPOSE_WEB_APP_ROOT_PARAM */ private static boolean exposeWebAppRoot(ServletContext servletContext) { String exposeWebAppRootParam = servletContext .getInitParameter(EXPOSE_WEB_APP_ROOT_PARAM); return (exposeWebAppRootParam == null || Boolean .valueOf(exposeWebAppRootParam)); } } logback.XML配置下面来看一下这个xml是如何配置的 &lt;?xml version=”1.0” encoding=”UTF-8”?&gt; %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n ${log_dir}/error-log-%d{yyyy-MM-dd}.log ${maxHistory} %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n ${log_dir}/info-log-%d{yyyy-MM-dd}.log ${maxHistory} %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n ${log_dir}/access-log-%d{yyyy-MM-dd}.log ${maxHistory} %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n ${log_dir}/sys_user-log-%d{yyyy-MM-dd}.log ${maxHistory} %d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n 关于这个XML文件的详细讲解请参考http://blog.csdn.net/haidage/article/details/6794509","tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://wangyuanjun.cn/tags/SpringMVC/"}]},{"title":"如何相互转换逗号分隔的字符串和List","date":"2017-01-12T03:01:54.000Z","path":"2017/01/12/如何相互转换逗号分隔的字符串和List/","text":"将逗号分隔的字符串转换为List方法 1： 利用JDK的Arrays类String str = “a,b,c”;List result = Arrays.asList(str.split(“,”)); 方法 2： 利用Guava的SplitterString str = “a, b, c”;List result = Splitter.on(“,”).trimResults().splitToList(str); 方法 3： 利用Apache Commons的StringUtils （只是用了split)String str = “a,b,c”;List result = Arrays.asList(StringUtils.split(str,”,”)); 方法 4: 利用Spring Framework的StringUtilsString str = “a,b,c”;List str = Arrays.asList(StringUtils.commaDelimitedListToStringArray(str)); 将List转换为逗号分隔符方法 1: 不用工具类 public String listToString(List list, char separator) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; list.size(); i++) { if (i == list.size() - 1) { sb.append(list.get(i)); } else { sb.append(list.get(i)); sb.append(separator); } } return sb.toString(); } public String listToString(List list, char separator) { StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; list.size(); i++) { sb.append(list.get(i)).append(separator); } return sb.toString().substring(0,sb.toString().length()-1); } 方法 2： 利用Guava的JoinerList list = new ArrayList();list.add(“a”);list.add(“b”);list.add(“c”);String str = Joiner.on(“,”).join(list); 方法 3： 利用Apache Commons的StringUtilsList list = new ArrayList();list.add(“a”);list.add(“b”);list.add(“c”);String str = StringUtils.join(list.toArray(), “,”); 方法 4：利用Spring Framework的StringUtilsList list = new ArrayList();list.add(“a”);list.add(“b”);list.add(“c”);String str = StringUtils.collectionToDelimitedString(list, “,”); 比较下来，我的观点就是Guava库和StringUtils更灵活，适用面更广。","tags":[{"name":"java基础","slug":"java基础","permalink":"http://wangyuanjun.cn/tags/java基础/"}]},{"title":"extjs-上传图片","date":"2016-12-10T13:44:29.000Z","path":"2016/12/10/extjs-上传图片/","text":"&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;!--ExtJs框架开始--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/Ext/adapter/ext/ext-base.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/Ext/ext-all.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/Ext/src/locale/ext-lang-zh_CN.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/Ext/resources/css/ext-all.css&quot; /&gt; &lt;!--ExtJs框架结束--&gt; &lt;script type=&quot;text/javascript&quot;&gt; Ext.onReady(function () { //初始化标签中的Ext:Qtip属性。 Ext.QuickTips.init(); Ext.form.Field.prototype.msgTarget = &apos;side&apos;; //创建div组件 var imagebox = new Ext.BoxComponent({ autoEl: { style: &apos;width:150px;height:150px;margin:0px auto;border:1px solid #ccc; text-align:center;padding-top:20px;margin-bottom:10px&apos;, tag: &apos;div&apos;, id: &apos;imageshow&apos;, html: &apos;暂无图片&apos; } }); //创建文本上传域 var file = new Ext.form.TextField({ name: &apos;imgFile&apos;, fieldLabel: &apos;文件上传&apos;, inputType: &apos;file&apos;, allowBlank: false, blankText: &apos;请浏览图片&apos; }); //提交按钮处理方法 var btnsubmitclick = function () { if (form.getForm().isValid()) { form.getForm().submit({ waitTitle: &quot;请稍候&quot;, waitMsg: &apos;正在上传...&apos;, success: function (form, action) { Ext.MessageBox.alert(&quot;提示&quot;, &quot;上传成功！&quot;); document.getElementById(&apos;imageshow&apos;).innerHTML = &apos;&lt;img style=&quot;width:150px;height:150px&quot; src=&quot;&apos; + action.result.path + &apos;&quot;/&gt;&apos;; }, failure: function () { Ext.MessageBox.alert(&quot;提示&quot;, &quot;上传失败！&quot;); } }); } } //重置按钮&quot;点击时&quot;处理方法 var btnresetclick = function () { form.getForm().reset(); } //表单 var form = new Ext.form.FormPanel({ frame: true, fileUpload: true, url: &apos;/App_Ashx/Demo/Upload.ashx&apos;, title: &apos;表单标题&apos;, style: &apos;margin:10px&apos;, items: [imagebox, file], buttons: [{ text: &apos;保存&apos;, handler: btnsubmitclick }, { text: &apos;重置&apos;, handler: btnresetclick }] }); //窗体 var win = new Ext.Window({ title: &apos;窗口&apos;, width: 476, height: 374, resizable: true, modal: true, closable: true, maximizable: true, minimizable: true, buttonAlign: &apos;center&apos;, items: form }); win.show(); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 其中与service交互用上传图片的 一般处理程序文件，源码如下： /App_Ashx/Demo/Upload.ashx using System; using System.Web; using System.IO; using System.Globalization; namespace HZYT.ExtJs.WebSite.App_Ashx.Demo { public class Upload : IHttpHandler { public void ProcessRequest(HttpContext context) { //虚拟目录，建议写在配置文件中 String strPath = &quot;/Upload/Image/&quot;; //文件本地目录 String dirPath = context.Server.MapPath(strPath); //接收文件 HttpPostedFile imgFile = context.Request.Files[&quot;imgFile&quot;]; //取出文件扩展名 String fileExt = Path.GetExtension(imgFile.FileName).ToLower(); //重新命名文件 String newFileName = DateTime.Now.ToString(&quot;yyyyMMddHHmmss_ffff&quot;, DateTimeFormatInfo.InvariantInfo) + fileExt; //文件上传路径 String filePath = dirPath + newFileName; //保存文件 imgFile.SaveAs(filePath); //客户端输出 context.Response.Write(&quot;{success:true,path:&apos;&quot; + strPath + newFileName + &quot;&apos;}&quot;); } public bool IsReusable { get { return false; } } } } 2.效果如下 3.说明： (1)上传域不光可以上传图片，还要以上传其他文件。这里我们以图片为例。 (2)在实际开发中，我们还要对图片格式，大小等进行校验，这个示例测重于上传，没有加入任何校验","tags":[{"name":"extjs","slug":"extjs","permalink":"http://wangyuanjun.cn/tags/extjs/"}]},{"title":"extjs-下拉列表联动","date":"2016-12-10T13:22:32.000Z","path":"2016/12/10/extjs-下拉列表联动/","text":"不管是几级下拉列表的联动实现本质上都是根据某个下拉列表的变化，去动态加载其他下拉列表，如：省、市、地区。 当我们监听到省变化时，向service端发送省的编号，service端根据收到的”省”编号到数据库中查询该省所对应的市信息， 地区同理，抓住这一点，我们只需要监听 combobox 的 select 事件并在其中实现逻辑即可。 1.代码如下： &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;!--ExtJs框架开始--&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/Ext/adapter/ext/ext-base.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/Ext/ext-all.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;/Ext/src/locale/ext-lang-zh_CN.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/Ext/resources/css/ext-all.css&quot; /&gt; &lt;!--ExtJs框架结束--&gt; &lt;script type=&quot;text/javascript&quot;&gt; Ext.onReady(function () { //初始化标签中的Ext:Qtip属性。 Ext.QuickTips.init(); Ext.form.Field.prototype.msgTarget = &apos;side&apos;; //----------------------下拉列表开始----------------------// //创建市数据源 var combocitystore = new Ext.data.Store({ //设定读取的地址 proxy: new Ext.data.HttpProxy({ url: &apos;/App_Ashx/Demo/City.ashx&apos; }), //设定读取的格式 reader: new Ext.data.JsonReader({ root: &apos;data&apos; }, [{ name: &apos;id&apos; }, { name: &apos;name&apos;}]) }); //创建区数据源 var comboareastore = new Ext.data.Store({ //设定读取的地址 proxy: new Ext.data.HttpProxy({ url: &apos;/App_Ashx/Demo/Area.ashx&apos; }), reader: new Ext.data.JsonReader({ root: &apos;data&apos; }, [{ name: &apos;id&apos; }, { name: &apos;name&apos;}]) }); //创建市Combobox var comboboxcity = new Ext.form.ComboBox({ id: &apos;comboboxcity&apos;, fieldLabel: &apos;市&apos;, width: 120, store: combocitystore, displayField: &apos;name&apos;, valueField: &apos;id&apos;, triggerAction: &apos;all&apos;, emptyText: &apos;请选择...&apos;, allowBlank: false, blankText: &apos;请选择市&apos;, editable: false, mode: &apos;local&apos;, //该属性和以下方法为了兼容ie8 listeners: { &apos;render&apos;: function () { combocitystore.load(); } } }); //创建区Combobox var comboareacity = new Ext.form.ComboBox({ fieldLabel: &apos;区&apos;, width: 120, store: comboareastore, displayField: &apos;name&apos;, valueField: &apos;id&apos;, triggerAction: &apos;all&apos;, emptyText: &apos;请选择...&apos;, allowBlank: false, blankText: &apos;请选择区&apos;, editable: false }); //联动的实现 comboboxcity.on(&apos;select&apos;, function () { comboareastore.baseParams.id = comboboxcity.getValue(); comboareacity.setValue(&apos;&apos;); comboareastore.load(); }) //----------------------下拉列表结束----------------------// //表单 var form = new Ext.form.FormPanel({ frame: true, title: &apos;表单标题&apos;, style: &apos;margin:10px&apos;, items: [comboboxcity, comboareacity] }); //窗体 var win = new Ext.Window({ title: &apos;窗口&apos;, width: 476, height: 374, resizable: true, modal: true, closable: true, maximizable: true, minimizable: true, buttonAlign: &apos;center&apos;, items: form }); win.show(); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 说明：(1)var combocitystore = new Ext.data.Store():创建一个新的数据源。(2)proxy: new Ext.data.HttpProxy({ url: ‘/App_Ashx/Demo/City.ashx’ })：数据代理为http代理，地址为/App_Ashx/Demo/City.ashx。(3)reader: new Ext.data.JsonReader({ root: ‘data’ },[{ name: ‘id’ }, { name: ‘name’}]):读取json返回值根节点为data，对象列为id和name。 这里要结合client与service观察,我在service端的输出如下：{data:[{id:1,name:’北京’},{id:2,name:’上海’}]}(4)comboboxcity.on(‘select’, function () {}：市选择变化时触发事件。(5)comboareastore.baseParams.id = comboboxcity.getValue()：注意，前面的comboareastore是区的数据源， 当市变化时，我们给区的数据源加上个向service端发送的参数。(6)comboareacity.setValue(‘’)：把区的下拉列表设置为空，由于非空验证，Ext会提示用户“请选择区”，这个地方也可以把加载出来的第一个区 显示在区的下拉列表中，具体请自行实现吧。(7)comboareastore.load()：区的数据源重新加载。–&gt; 其中与service交互用到两个.net 一般处理程序文件，源码如下：(1)/App_Ashx/Demo/City.ashx using System.Web; namespace HZYT.ExtJs.WebSite.App_Ashx.Demo{ public class City : IHttpHandler { public void ProcessRequest(HttpContext context) { context.Response.Write(“{data:[{id:1,name:’北京’},{id:2,name:’上海’}]}”); } public bool IsReusable { get { return false; } } } } (2)/App_Ashx/Demo/Area.ashx using System.Web; namespace HZYT.ExtJs.WebSite.App_Ashx.Demo{ public class Area : IHttpHandler { public void ProcessRequest(HttpContext context) { //接收Client端传来的参数，交根据条件返回 if (context.Request.Form[“id”].ToString() == “1”) { context.Response.Write(“{data:[{id:1,name:’东城区’},{id:2,name:’西城区’},{id:2,name:’海淀区’}]}”); } else { context.Response.Write(“{data:[{id:1,name:’杨浦区’},{id:2,name:’虹口区’},{id:2,name:’闸北区’}]}”); } } public bool IsReusable { get { return false; } } } } 2.效果如下：","tags":[{"name":"extjs","slug":"extjs","permalink":"http://wangyuanjun.cn/tags/extjs/"}]},{"title":"extjs技巧","date":"2016-12-10T13:00:02.000Z","path":"2016/12/10/extjs技巧/","text":"extjs Ext.form.ComboBox 的设置默认值的问题 Ext.onReady(function(){ var dbConnectionRecord = Ext.data.Record.create([ {name: &apos;dbConnectionKey&apos;,type:&quot;string&quot;,mapping:&quot;dbConnectionKey&quot;}, {name: &apos;name&apos;,type:&quot;string&quot;,mapping:&quot;name&quot;} ]); var dataProxy=new Ext.data.HttpProxy({url:&quot;&lt;%=basePath%&gt;getDBConnection.action&quot;}); var theReader=new Ext.data.JsonReader({totalProperty: &apos;totalProperty&apos;,root:&apos;root&apos;,id:&quot;ecname&quot;},dbConnectionRecord); var dbstore=new Ext.data.Store({proxy:dataProxy,reader:theReader}); dbstore.load(); var dbcombo = new Ext.form.ComboBox({ id:&apos;dbCombo&apos;, renderTo:Ext.getBody(), store: dbstore, valueField:&apos;dbConnectionKey&apos;, displayField:&apos;name&apos;, typeAhead: true, emptyText:&apos;请选择&apos;, readOnly : true, mode: &apos;local&apos;, name:&quot;dbkey&quot;, hiddenName:&apos;dbkey&apos;, editable: false, triggerAction: &apos;all&apos;, selectOnFocus:true }); ////dbcombo.setValue(&quot;4&quot;); 肯定不行，参见后面的代码 }); 实现：写在store load的callback里 dbstore.load({ callback : function(records) { dbcombo.setValue(&quot;4&quot;); } }); //在分页组件前面添加组件 var page = new Ext.PagingToolbar({ store: store, displayInfo: true, pageSize: 10 }); page.insert(0, &apos;-&apos;); page.insert(0, { //添加一个日期组件 xtype: &apos;datefield&apos;, name: &apos;chatdate&apos;, format: &apos;Y-m-d&apos;, value: new Date() }); //树节点(TreeNode)图标动态修改 2009-11-22 15:36:52 var ui = node.getUI(); ui.removeClass(&apos;x-tree-node-leaf&apos;); //去掉之前的根节点样式 ui.addClass(&apos;x-tree-node-expanded&apos;); //设定已展开文件夹样式 //ui.addClass(&apos;x-tree-node-collapsed&apos;);//设定合并的文件夹样式 使用Ext.Ajaxt对象完成异步请求的交互，Ext.Ajax是单实例对象（非常重要，全局单一Ext.Ajax实例！）。注册Ext.Ajax的requestcomplete事件，每个ajax请求成功后首先响应该事件。在该事件的回调函数里面判断访问请求是否超时。使用Ext.Ajax对象的好处是，只需要引入一个包含了几行超时处理代码的js文件，就可以为当前应用增加超时处理功能，原有代码不需要做任何修改。 使用Ext.Ajaxt对象完成异步请求交互，假如checkUserSessionStatus是你的回调方法，每个页面引用： Js代码 Ext.Ajax.on(‘requestcomplete’,checkUserSessionStatus, this); function checkUserSessionStatus(conn,response,options){ //Ext重新封装了response对象 if(typeof response.getResponseHeader.sessionstatus != ‘undefined’){ //发现请求超时，退出处理代码… } } Ext.Ajax.on(‘requestcomplete’,checkUserSessionStatus, this); function checkUserSessionStatus(conn,response,options){ //Ext重新封装了response对象 if(typeof response.getResponseHeader.sessionstatus != ‘undefined’){ //发现请求超时，退出处理代码… } } 可以利用的几个特性：a）所有的ajax请求均带有x-requested-with:XMLHttpRequest头信息b）Ext.Ajax是单实例对象（非常重要，全局单一Ext.Ajax实例！）c）注册Ext.Ajax的requestcomplete事件，每个ajax请求成功后首先响应该事件（概念类似spring的aop拦截）。 对于其他的ajax框架，解决用户访问请求超时这个问题的思路是类似的。 二、如何设置DateField的默认值。 设置DateField的默认值，可以直接给value属性赋值，如：value: ‘01/01/2009’，如果要设置默认值为当天的日期，可以如下设置：value: new Date new Ext.form.DateField({ id: &apos;df&apos;, fieldLabel: &apos;日期&apos;, format: &apos;Y年m月d日&apos;, width: 150, //value: &apos;01/01/2009&apos; value: new Date }) 如何禁用或者启用某个菜单有的时候，有时会根据需要，启用或者禁用某个菜单项，在ExtJS中，可以通过如下的操作进行。 Ext.onReady(function() { Ext.BLANK_IMAGE_URL = &apos;resources/images/default/s.gif&apos;; Ext.QuickTips.init(); var tb = new Ext.Toolbar({ applyTo: &apos;tb&apos;, width: 400 }); var styleMenu = new Ext.menu.Menu({ items: [{ text: &apos;主题选择&apos;, id: &apos;style&apos;, menu: new Ext.menu.Menu({ items: [{ text: &apos;红色主题&apos;, checked: true, group: &apos;theme&apos; }, { text: &apos;蓝色主题&apos;, checked: false, group: &apos;theme&apos; }, { text: &apos;黑色主题&apos;, checked: false, group: &apos;theme&apos; }] }) }, { text: &apos;启用主题&apos;, checked: true, checkHandler: function() { Ext.getCmp(&apos;style&apos;).setDisabled(!this.checked) } }] }); tb.add({ text: &apos;主题&apos;, menu: styleMenu }); }); 一、从form中获取field的三个方法： １、Ext.getCmp(&apos;id&apos;); ２、FormPanel.getForm().findField(&apos;id/name&apos;); ３、Ext.get(&apos;id/name&apos;);//前提是FormPanel在界面上显示出来了。 二、ExtJS如何给textfield赋值的三个方法： var value=&quot;值&quot;; １、 fs.form.findField(id/name).setValue(value); ２、 Ext.get(id/name).setValue(value); ３、 Ext.getCmp(id).setValue(value); 三、Ext grid中得到选择行的方法 在Ext grid中假设有一个名称为grid的对象。 (1)grid.getStore().getRange(0,store.getCount());//得到grid所有的行 (2)grid.getSelectionModel().getSelections()//得到选择所有行 (3)grid.selModel.selections.items;//得到选择所有行 (4)grid.getSelectionModel().getSelected();//得到选择行的第一行 四、formPanel组件load数据时combo的自动赋值 combo有个hiddenName这个属*，这个属性是真正提交的值，在加载的时候你将这个属性的设置到reader中,就可以自动选择到指定的值了，比如说：hiddenName:’value’,那么你的reader中就应该有一个{name:’value’}. 五、ExtJS 重置表单的方法： 有三种方法能实现form表单的重置，假设var fs=new Ext.form.FormPanel({…});(1)fs.form.reset();//重置form(2)fs.getForm().getEl().dom.reset();//重置form(3)Ext.getCmp(‘fs’).form.reset();","tags":[{"name":"extjs","slug":"extjs","permalink":"http://wangyuanjun.cn/tags/extjs/"}]},{"title":"Maven集成 tomcat7-maven-plugin 部署Maven Web项目","date":"2016-12-09T07:54:44.000Z","path":"2016/12/09/Maven集成-tomcat7-maven-plugin-部署Maven-Web项目/","text":"在eclipse中使用tomcat部署项目，我们一般是到网上下载tomcat服务，然后与eclipse集成，这是我之前的做法。其实我们省略这个步骤，使用maven集成tomcat 在项目下pom.xml文件中的标签内加入： &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2-SNAPSHOT&lt;/version&gt; &lt;configuration&gt; &lt;path&gt;/${project.build.finalName}&lt;/path&gt; &lt;!-- 项目名 --&gt; &lt;server&gt;mytomcat7&lt;/server&gt; &lt;!-- 这里是本地tomcat，如果是远程服务器可以改成对应的地址，实现自动部署--&gt; &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt; &lt;/configuration&gt; &lt;/plugin&gt; 选择项目，然后debug As–&gt;maven build 部署发布成功 插件相关命令 命令 描述 tomcat7:deploy 部署一个web war包 tomcat7:reload 重新加载web war包 tomcat7:start 启动tomcat tomcat7:stop 停止tomcat tomcat7:undeploy 停止一个war包 tomcat7:run 启动嵌入式tomcat ，并运行当前项目 实现自动部署请看以下博文:Maven Tomcat7自动部署Maven tomcat7-maven-plugin 部署Maven Web 项目","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://wangyuanjun.cn/tags/tomcat/"},{"name":"maven","slug":"maven","permalink":"http://wangyuanjun.cn/tags/maven/"}]},{"title":"解决java.lang.ClassNotFoundException: ch.qos.logback.ext.spring.web.LogbackConfigListener 项目启动报错","date":"2016-12-01T07:08:40.000Z","path":"2016/12/01/解决java-lang-ClassNotFoundException-ch-qos-logback-ext-spring-web-LogbackConfigListener-项目启动报错/","text":"maven项目启动报错，如下: 1-Dec-2016 20:02:55.246 SEVERE [localhost-startStop-1] org.apache.catalina.core.StandardContext.listenerStart Error configuring application listener of class ch.qos.logback.ext.spring.web.LogbackConfigListener java.lang.ClassNotFoundException: ch.qos.logback.ext.spring.web.LogbackConfigListener at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1332) at org.apache.catalina.loader.WebappClassLoaderBase.loadClass(WebappClassLoaderBase.java:1166) at org.apache.catalina.core.DefaultInstanceManager.loadClass(DefaultInstanceManager.java:520) at org.apache.catalina.core.DefaultInstanceManager.loadClassMaybePrivileged(DefaultInstanceManager.java:501) at org.apache.catalina.core.DefaultInstanceManager.newInstance(DefaultInstanceManager.java:120) at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:4651) at org.apache.catalina.core.StandardContext.startInternal(StandardContext.java:5167) at org.apache.catalina.util.LifecycleBase.start(LifecycleBase.java:150) at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:725) at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:701) at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:717) at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:586) at org.apache.catalina.startup.HostConfig$DeployDescriptor.run(HostConfig.java:1750) at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511) at java.util.concurrent.FutureTask.run(FutureTask.java:266) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745) 错误原因tomcat部署过去的项目中lib等jar包没有部署过去 解决方法 选中项目右击Properties 检查tomcat部署过去的项目中lib等jar包有没有部署过去 如果没有添加，加进去，重新启动项目，问题解决!","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://wangyuanjun.cn/tags/tomcat/"},{"name":"maven","slug":"maven","permalink":"http://wangyuanjun.cn/tags/maven/"}]},{"title":"【Maven】Project configuration is not up-to-date with pom.xml错误解决方法","date":"2016-11-10T08:53:45.000Z","path":"2016/11/10/【Maven】Project-configuration-is-not-up-to-date-with-pom-xml错误解决方法/","text":"导入一个Maven项目之后发现有一个如下的错误：Project configuration is not up-to-date with pom.xml. Run project configuration update 其实这个问题解决非常简单：在项目上右键——【Maven】——【Update Project Configuration……】这时会打开一个（Update Maven Dependencies）的对话框，然后勾选住出错的项目，点击Ok这样就搞定了。","tags":[{"name":"maven","slug":"maven","permalink":"http://wangyuanjun.cn/tags/maven/"}]},{"title":"数据库SQL优化总结","date":"2016-11-08T02:09:02.000Z","path":"2016/11/08/数据库SQL优化总结/","text":"网上关于SQL优化的教程很多，但是比较杂乱。近日有空整理了一下，写出来跟大家分享一下，其中有错误和不足的地方，还请大家纠正补充。 数据库设计方面 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库。备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。 不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num = 0 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 与临时表一样，游标并不是不可使用。对小型数据集使用FAST_FORWARD。游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 SQL语句方面 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num=10 or Name = &apos;admin&apos; 可以这样查询： select id from t where num = 10 union all select id from t where Name = &apos;admin&apos; in 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’ 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num = @num 可以改为强制查询使用索引： select id from t with(index(索引名)) where num = @num 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where num/2=100 应改为: select id from t where num=100*2 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3) = ’abc’ -–name以abc开头的id select id from t where datediff(day,createdate,’2005-11-30′) = 0 -–‘2005-11-30’ --生成的id 应改为: select id from t where name like &apos;abc%&apos; select id from t where createdate &gt;= &apos;2005-11-30&apos; and createdate &lt; &apos;2005-12-1&apos; 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构： select col1,col2 into #t from t where 1=0 这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： create table #t(…) 很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b) 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num) 任何地方都不要使用 select * from t ， 用具体的字段列表代替“*”，不要返回用不到的任何字段。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 尽量避免大事务操作，提高系统并发能力。 Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。 select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。 尽量避免大事务操作，提高系统并发能力。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 java方面 尽可能的少造对象。 合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。 使用jDBC链接数据库操作数据。 控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理。 合理利用内存，有的数据要缓存。 如何优化数据库，如何提高数据库的性能? 硬件调整性能 最有可能影响性能的是磁盘和网络吞吐量,解决办法扩大虚拟内存，并保证有足够可以扩充的空间；把数据库服务器上的不必要服务关闭掉；把数据库服务器和主域服务器分开；把SQL数据库服务器的吞吐量调为最大；在具有一个以上处理器的机器上运行SQL。 调整数据库若对该表的查询频率比较高，则建立索引；建立索引时，想尽对该表的所有查询搜索操作， 按照where选择条件建立索引，尽量为整型键建立为有且只有一个簇集索引，数据在物理上按顺序在数据页上，缩短查找范围，为在查询经常使用的全部列建立非簇集索引，能最大地覆盖查询；但是索引不可太多，执行UPDATE DELETE INSERT语句需要用于维护这些索引的开销量急剧增加；避免在索引中有太多的索引键；避免使用大型数据类型的列为索引；保证每个索引键值有少数行。 使用存储过程应用程序的实现过程中，能够采用存储过程实现的对数据库的操作尽量通过存储过程来实现，因为存储过程是存放在数据库服务器上的一次性被设计、编码、测试，并被再次使用，需要执行该任务的应用可以简单地执行存储过程，并且只返回结果集或者数值，这样不仅可以使程序模块化，同时提高响应速度，减少网络流量，并且通过输入参数接受输入，使得在应用中完成逻辑的一致性实现。 应用程序结构和算法建立查询条件索引仅仅是提高速度的前提条件，响应速度的提高还依赖于对索引的使用。因为人们在使用SQL时往往会陷入一个误区，即太关注于所得的结果是否正确，特别是对数据量不是特别大的数据库操作时，是否建立索引和使用索引的好坏对程序的响应速度并不大，因此程序员在书写程序时就忽略了不同的实现方法之间可能存在的性能差异，这种性能差异在数据量特别大时或者大型的或是复杂的数据库环境中（如联机事务处理OLTP或决策支持系统DSS）中表现得尤为明显。在工作实践中发现，不良的SQL往往来自于不恰当的索引设计、不充份的连接条件和不可优化的where子句。在对它们进行适当的优化后，其运行速度有了明显地提高！ 实际案例分析拆分大的 DELETE 或INSERT 语句，批量提交SQL语句。如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top)条件是一个好的方法。下面是一个mysql示例： while(1){ //每次只做1000条 mysql_query(“delete from logs where log_date &lt;= ’2012-11-01’ limit 1000”); if(mysql_affected_rows() == 0){ //删除完成，退出！ break； } //每次暂停一段时间，释放表让其他进程/线程访问。 usleep(50000) } 参考:数据库SQL优化大总结之 百万级数据库优化方案在一个千万级的数据库查寻中，如何提高查询效率？","tags":[{"name":"mysql","slug":"mysql","permalink":"http://wangyuanjun.cn/tags/mysql/"},{"name":"oracle","slug":"oracle","permalink":"http://wangyuanjun.cn/tags/oracle/"}]},{"title":"Tomcat报内存溢出","date":"2016-10-26T13:45:17.000Z","path":"2016/10/26/Tomcat报内存溢出/","text":"1、错误描述 严重：Exception occurred during processing request:null java.lang.reflect.InvocationTargetException. Caused by:java.lang.OutOfMemoryError:Java heap space. 2、错误原因 Tomcat在处理大数据时出现内存溢出 3、解决办法 编辑tomcat的catalina.bat文件，在第一行的后面增加一句： set JAVA_OPTS=-server -Xms512m -Xmx512m -XX:PermSize=128M -XX:MaxPermSize=256M","tags":[{"name":"tomcat","slug":"tomcat","permalink":"http://wangyuanjun.cn/tags/tomcat/"}]},{"title":"Docker的安装","date":"2016-10-26T12:44:32.000Z","path":"2016/10/26/Docker的安装/","text":"1，关于docker Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。 Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。 在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。 摘自：http://dockerpool.com/static/books/docker_practice/introduction/what.html 2，安装centos 在使用virtualbox安装的时候需要把网络修改成【Bridged A’dapter】，方便获得上网ip，ssh连接到虚拟机。centos7 可以直接使用yum 安装docker最懒的方式，只是为了学习docker省去了折腾环境的麻烦。直接使用iso进行安装就行了。 3，安装docker 直接安装就可以了： yum install golang docker device-mapper-event-libs 必须安装 device-mapper-event-libs 否则docker启动不了，报错：Failed to start Docker Application Container Engine。配置&amp;启动服务 1:systemctl enable docker2:systemctl start docker docker服务就可以正常启动了。 4，docker hello world 虚拟安装一个MySQL，docker非常强大的时image。在官方搜索类库非常多。https://registry.hub.docker.com/search?q=librarydocker的注册中心，里面有很多做好的镜像库。mysql的安装：/mysql/”&gt;https://registry.hub.docker.com//mysql/ 安装mysql过程，设置数据库docker-mysql，版本5.5 1:# docker run –name docker-mysql -e MYSQL_ROOT_PASSWORD=docker-mysql -d mysql:5.52:Unable to find image ‘mysql:5.5’ locally3:Trying to pull repository docker.io/mysql …4:2f08318d65b3: Pulling dependent layers5:511136ea3c5a: Download complete6:4f903438061c: Download complete7:1265e16d0c28: Download complete8:ac1d5afd7b69: Download complete9:7c89455832dd: Downloading [===========================&gt; ] 4.434 MB/8.077 MB 34s 查看docker镜像： docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe59ad4702626 mysql:5.5 “/entrypoint.sh mysq 2 minutes ago Up 2 minutes 3306/tcp docker-mysql 查看mysql的docker服务器，直接登录到mysql容器，就安装好了mysql。同时服务也启动了，测试mysql docker启动成功。docker exec -it docker-mysql bash 1 docker exec -it docker-mysql bash2 root@e59ad4702626:/# mysql -uroot -pdocker-mysql3 Welcome to the MySQL monitor. Commands end with ; or \\g.4 Your MySQL connection id is 55 Server version: 5.5.43 MySQL Community Server (GPL)67 Copyright (c) 2000, 2015, Oracle and/or its affiliates. All rights reserved.89 Oracle is a registered trademark of Oracle Corporation and/or its10 affiliates. Other names may be trademarks of their respective11 owners.1213 Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the current input statement.1415 mysql&gt; show databases;16 +——————–+17 | Database |18 +——————–+19 | information_schema |20 | mysql |21 | performance_schema |22 +——————–+23 3 rows in set (0.00 sec)2425 mysql&gt; 同时这个是一个虚拟的服务器，上面安装的mysql。","tags":[{"name":"docker","slug":"docker","permalink":"http://wangyuanjun.cn/tags/docker/"}]},{"title":"Spring-Aop之xml配置实现日志管理","date":"2016-08-27T15:25:55.000Z","path":"2016/08/27/Spring-Aop之xml配置实现日志管理/","text":"最近项目要做一个日志功能，Spring Aop注解方式我已经实现了，以下是我用xml配置方式来实现。 创建日志注解package com.wyj.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * 日志注解 * * * @author：WangYuanJun * @date：2016年8月27日 下午8:39:42 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface SysLog { String action() default &quot;&quot;;//动作 } 创建切面通知类package com.wyj.aspect; import java.lang.reflect.Method; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.wyj.annotation.SysLog; import com.wyj.entity.SysLogEntity; import com.wyj.service.SysLogService; /** * 日志切面通知 * * * @author：WangYuanJun * @date：2016年8月26日 下午8:39:42 */ public class SysLogAspect { @Autowired private SysLogService sysLogService; /** * 环绕通知 * * @param joinPoint * @return * @throws Throwable */ public Object aroud(ProceedingJoinPoint joinPoint) throws Throwable { // 开始时间 long beginTime = System.currentTimeMillis(); // 执行目标方法 Object result = joinPoint.proceed(); // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; // 保存日志 saveSysLog(joinPoint, time); return result; } /** * 保存日志 * * @param joinPoint * @param time */ private void saveSysLog(ProceedingJoinPoint joinPoint, long time) { MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLogEntity sysLogEntity = new SysLogEntity(); SysLog sysLog = method.getAnnotation(SysLog.class); if (sysLog != null) { // 注解上的描述 sysLogEntity.setOperation(sysLog.action()); } // 获取目标类名 String className = joinPoint.getTarget().getClass().getName(); // 获取方法名 String methodName = signature.getName(); sysLogEntity.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;); // 请求的参数 Object[] args = joinPoint.getArgs(); if (args != null &amp;&amp; args.length != 0 &amp;&amp; args[0] != null) { sysLogEntity.setParams(args[0].toString()); } sysLogEntity.setTime(time); // 保存系统日志 sysLogService.save(sysLogEntity); } } AspectJ配置文件&lt;!-- 切面 --&gt; &lt;bean id=&quot;sysLogAspect&quot; class=&quot;com.wyj.aspect.SysLogAspect&quot;&gt;&lt;/bean&gt; &lt;aop:config&gt; &lt;aop:aspect ref=&quot;sysLogAspect&quot;&gt; &lt;aop:pointcut expression=&quot;@annotation(com.wyj.annotation.SysLog)&quot; id=&quot;sysLogPointcut&quot;/&gt; &lt;aop:around method=&quot;aroud&quot; pointcut-ref=&quot;sysLogPointcut&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 日志注解的应用 效果","tags":[{"name":"spring aop","slug":"spring-aop","permalink":"http://wangyuanjun.cn/tags/spring-aop/"},{"name":"spring","slug":"spring","permalink":"http://wangyuanjun.cn/tags/spring/"}]},{"title":"Spring Aop之AspectJ注解配置实现日志管理","date":"2016-08-26T15:25:55.000Z","path":"2016/08/26/Spring-Aop之AspectJ注解配置实现日志管理/","text":"最近项目要做一个日志功能，我用Spring Aop的注解方式来实现。 创建日志注解package com.wyj.annotation; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; /** * 日志注解 * * * @author：WangYuanJun * @date：2016年8月26日 下午8:25:35 */ @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface SysLog { String action() default &quot;&quot;;//动作 } 创建切面通知类记录操作的方法名，参数和花费的时间，使用环绕通知 package com.wyj.aspect; import java.lang.reflect.Method; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.aspectj.lang.reflect.MethodSignature; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; import com.wyj.annotation.SysLog; import com.wyj.entity.SysLogEntity; import com.wyj.service.SysLogService; /** * 日志切面通知 * * * @author：WangYuanJun * @date：2016年8月26日 下午10:28:57 */ @Aspect @Component public class SysLogAspect { @Autowired private SysLogService sysLogService; /** * 切入点 */ @Pointcut(&quot;@annotation(com.wyj.annotation.SysLog)&quot;) public void pointCut() {} /** * 环绕通知 * * @param joinPoint * @return * @throws Throwable */ @Around(&quot;pointCut()&quot;) public Object aroud(ProceedingJoinPoint joinPoint) throws Throwable { // 开始时间 long beginTime = System.currentTimeMillis(); // 执行目标方法 Object result = joinPoint.proceed(); // 执行时长(毫秒) long time = System.currentTimeMillis() - beginTime; // 保存日志 saveSysLog(joinPoint, time); return result; } /** * 保存日志 * * @param joinPoint * @param time */ private void saveSysLog(ProceedingJoinPoint joinPoint, long time) { MethodSignature signature = (MethodSignature) joinPoint.getSignature(); Method method = signature.getMethod(); SysLogEntity sysLogEntity = new SysLogEntity(); SysLog sysLog = method.getAnnotation(SysLog.class); if (sysLog != null) { // 注解上的描述 sysLogEntity.setOperation(sysLog.action()); } // 获取目标类名 String className = joinPoint.getTarget().getClass().getName(); // 获取方法名 String methodName = signature.getName(); sysLogEntity.setMethod(className + &quot;.&quot; + methodName + &quot;()&quot;); // 请求的参数 Object[] args = joinPoint.getArgs(); if (args != null &amp;&amp; args.length != 0 &amp;&amp; args[0] != null) { sysLogEntity.setParams(args[0].toString()); } sysLogEntity.setTime(time); // 保存系统日志 sysLogService.save(sysLogEntity); } } 扫描和启动aop注解 日志注解的应用 效果","tags":[{"name":"spring aop","slug":"spring-aop","permalink":"http://wangyuanjun.cn/tags/spring-aop/"},{"name":"spring","slug":"spring","permalink":"http://wangyuanjun.cn/tags/spring/"}]},{"title":"ztree实现拖拽功能","date":"2016-07-19T06:09:44.000Z","path":"2016/07/19/ztree实现拖拽功能/","text":"最近在做仓储的功能，需要实现对仓库树的拖拽功能，测试了很长时间才完成，后端使用了SpringMVC + Spring Data Jpa图片和代码展示如下： Jsp程序&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ include file=&quot;/common/taglibs.jsp&quot;%&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;title&gt;物品分类&lt;/title&gt; &lt;style&gt; .ztree * {font-size:14px !important;} &lt;/style&gt; &lt;/head&gt; &lt;body style=&quot;background: #f1f1f1;border:1px solid #f1f1f1;&quot;&gt; &lt;div class=&quot;row&quot; id=&quot;page_content&quot;&gt; &lt;div class=&quot;col-sm-12&quot;&gt; &lt;div class=&quot;ibox float-e-margins&quot;&gt; &lt;div class=&quot;ibox-title&quot;&gt; &lt;h3&gt;物品分类&lt;/h3&gt; &lt;/div&gt; &lt;div class=&quot;ibox-content&quot;&gt; &lt;div class=&quot;col-sm-12 no-padding&quot; id=&quot;tree&quot;&gt; &lt;div class=&quot;zTreeDemoBackground left&quot;&gt; &lt;ul id=&quot;treeDemo&quot; class=&quot;ztree&quot; url=&quot;${ctx}/baseinfo/wpfl/renderTree&quot;&gt;&lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type=&quot;hidden&quot; id=&quot;wpflOrCkgl&quot; value=&quot;wpfl&quot;&gt; &lt;script type=&quot;text/javascript&quot;&gt; var wpfl = true; var ckgl = false; var modal = { saveURL : &quot;${ctx}/baseinfo/wpfl&quot;, deleteURL: &quot;${ctx}/baseinfo/wpfl/delete&quot;, sameLevel: &quot;${ctx}/baseinfo/wpfl/sameLevel&quot;, differentLevel:&quot;${ctx}/baseinfo/wpfl/differentLevel&quot;, diffLevel:&quot;${ctx}/baseinfo/wpfl/diffLevel&quot;, checkURL:&quot;${ctx}/baseinfo/wpfl/check&quot; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; JS代码var setting = { view: { addHoverDom: addHoverDom, removeHoverDom: removeHoverDom, selectedMulti: false, showLine: false, showIcon: showIconForTree }, edit: { drag: { autoExpandTrigger: true, prev: dropPrev, inner: dropInner, next: dropNext }, enable: true, editNameSelectAll: true, showRemoveBtn : showRemoveBtn, showRenameBtn : showRenameBtn }, data: { simpleData: { enable: true } }, callback: { beforeDrag: beforeDrag, beforeEditName: beforeEditName, beforeRemove: beforeRemove, beforeRename: beforeRename, onRemove: onRemove, onRename: onRename, beforeDrop: beforeDrop, beforeDragOpen: beforeDragOpen, onDrag: onDrag, onDrop: onDrop, onExpand: onExpand, onAsyncSuccess: zTreeOnAsyncSuccess, }, async: { enable: true, type: &quot;get&quot;, //表示异步加载采用 post 方法请求 url: $(&quot;#treeDemo&quot;).attr(&quot;url&quot;), autoParam: [&quot;id&quot;, &quot;type&quot;] //传递节点的id 和 type值给后台(当异步加载数据时) } }; /**数异步加载成功*/ function zTreeOnAsyncSuccess(event, treeId, node, msg) { var treeObj = $.fn.zTree.getZTreeObj(&quot;treeDemo&quot;); var nodes = treeObj.getNodes(); // 异步展开一级子节点 if (nodes.length &gt; 0) { treeObj.expandNode(nodes[0], true, false, false); } } var log, className = &quot;dark&quot;; function beforeDrag(treeId, treeNodes) { return false; } function beforeEditName(treeId, treeNode) { className = (className === &quot;dark&quot; ? &quot;&quot;:&quot;dark&quot;); showLog(&quot;[ &quot;+getTime()+&quot; beforeEditName ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot; + treeNode.name); var zTree = $.fn.zTree.getZTreeObj(&quot;treeDemo&quot;); zTree.selectNode(treeNode); return; } function beforeRemove(treeId, treeNode) { className = (className === &quot;dark&quot; ? &quot;&quot;:&quot;dark&quot;); showLog(&quot;[ &quot;+getTime()+&quot; beforeRemove ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot; + treeNode.name); var zTree = $.fn.zTree.getZTreeObj(&quot;treeDemo&quot;); zTree.selectNode(treeNode); var flag = false; if(confirm(&quot;确认删除 节点 -- &quot; + treeNode.name + &quot; 吗？&quot;)){ // 删除节点 flag=delNode(modal,treeNode.id); } return flag; } function onRemove(e, treeId, treeNode) { showLog(&quot;[ &quot;+getTime()+&quot; onRemove ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot; + treeNode.name); } function beforeRename(treeId, treeNode, newName, isCancel) { className = (className === &quot;dark&quot; ? &quot;&quot;:&quot;dark&quot;); showLog((isCancel ? &quot;&lt;span style=&apos;color:red&apos;&gt;&quot;:&quot;&quot;) + &quot;[ &quot;+getTime()+&quot; beforeRename ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot; + treeNode.name + (isCancel ? &quot;&lt;/span&gt;&quot;:&quot;&quot;)); if (newName.length == 0) { alert(&quot;节点名称不能为空.&quot;); var zTree = $.fn.zTree.getZTreeObj(&quot;treeDemo&quot;); setTimeout(function(){zTree.editName(treeNode)}, 10); return false; } else if(newName.length &gt; 20){ confirm(&quot;名称长度在20字以内&quot;); return false; } // 修改的名字没变 if(treeNode.name == newName){ return true; } // 判断是否重名 var flag1 = check(newName); if(flag1 == false){ alert(&quot;名称不能重复&quot;); return false; } return true; } function onRename(e, treeId, treeNode, isCancel) { showLog((isCancel ? &quot;&lt;span style=&apos;color:red&apos;&gt;&quot;:&quot;&quot;) + &quot;[ &quot;+getTime()+&quot; onRename ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &quot; + treeNode.name + (isCancel ? &quot;&lt;/span&gt;&quot;:&quot;&quot;)); if(treeNode.type == &apos;add&apos;){ // 新增节点 nodeAdd(treeNode); treeNode.type=&apos;edit&apos;; }else{ // 编辑节点 nodeEdit(treeNode); } } function showIconForTree(treeId, treeNode) { return !treeNode.isParent; } function showLog(str) { if (!log) log = $(&quot;#log&quot;); log.append(&quot;&lt;li class=&apos;&quot;+className+&quot;&apos;&gt;&quot;+str+&quot;&lt;/li&gt;&quot;); if(log.children(&quot;li&quot;).length &gt; 8) { log.get(0).removeChild(log.children(&quot;li&quot;)[0]); } } function getTime() { var now= new Date(), h=now.getHours(), m=now.getMinutes(), s=now.getSeconds(), ms=now.getMilliseconds(); return (h+&quot;:&quot;+m+&quot;:&quot;+s+ &quot; &quot; +ms); } var newCount = 1; /** 是否显示编辑按钮 */ function showRenameBtn(treeId, treeNode){ // 根节点不显示编辑按钮 if(treeNode.level == 0){ return false; }else{ return true; } } /** 是否显示删除按钮 */ function showRemoveBtn(treeId, treeNode){ // 根节点不显示删除按钮 if(treeNode.level == 0){ return false; }else{ return true; } } /** 新增节点 */ function addHoverDom(treeId, treeNode) { if(wpfl == true &amp;&amp; treeNode.level == 3){ // 物品分类最多支持三级 return; }else if(ckgl == true &amp;&amp; treeNode.level == 2){ // 仓库管理最多支持二级 return; } var sObj = $(&quot;#&quot; + treeNode.tId + &quot;_span&quot;); if (treeNode.editNameFlag || $(&quot;#addBtn_&quot;+treeNode.tId).length&gt;0) return; var addStr = &quot;&lt;span class=&apos;button add&apos; id=&apos;addBtn_&quot; + treeNode.tId + &quot;&apos; title=&apos;新增&apos; onfocus=&apos;this.blur();&apos;&gt;&lt;/span&gt;&quot;; sObj.after(addStr); var btn = $(&quot;#addBtn_&quot;+treeNode.tId); if (btn) btn.bind(&quot;click&quot;, function(){ var zTree = $.fn.zTree.getZTreeObj(&quot;treeDemo&quot;); var newName = &quot;new node&quot; + (newCount++); zTree.addNodes(treeNode, {id:(100 + newCount), pId:treeNode.id, name:newName,type : &apos;add&apos;}); var newNode=treeNode.children[treeNode.children.length-1]; zTree.editName(newNode); return false; }); } function removeHoverDom(treeId, treeNode) { $(&quot;#addBtn_&quot;+treeNode.tId).unbind().remove(); } function selectAll() { var zTree = $.fn.zTree.getZTreeObj(&quot;treeDemo&quot;); zTree.setting.edit.editNameSelectAll = $(&quot;#selectAll&quot;).attr(&quot;checked&quot;); } function dropPrev(treeId, nodes, targetNode) { var pNode = targetNode.getParentNode(); if (pNode &amp;&amp; pNode.dropInner === false) { return false; } else { for (var i=0,l=curDragNodes.length; i&lt;l; i++) { var curPNode = curDragNodes[i].getParentNode(); if (curPNode &amp;&amp; curPNode !== targetNode.getParentNode() &amp;&amp; curPNode.childOuter === false) { return false; } } } return true; } function dropInner(treeId, nodes, targetNode) { if (targetNode &amp;&amp; targetNode.dropInner === false) { return false; } else { for (var i=0,l=curDragNodes.length; i&lt;l; i++) { if (!targetNode &amp;&amp; curDragNodes[i].dropRoot === false) { return false; } else if (curDragNodes[i].parentTId &amp;&amp; curDragNodes[i].getParentNode() !== targetNode &amp;&amp; curDragNodes[i].getParentNode().childOuter === false) { return false; } } } return true; } function dropNext(treeId, nodes, targetNode) { var pNode = targetNode.getParentNode(); if (pNode &amp;&amp; pNode.dropInner === false) { return false; } else { for (var i=0,l=curDragNodes.length; i&lt;l; i++) { var curPNode = curDragNodes[i].getParentNode(); if (curPNode &amp;&amp; curPNode !== targetNode.getParentNode() &amp;&amp; curPNode.childOuter === false) { return false; } } } return true; } var log, className = &quot;dark&quot;, curDragNodes, autoExpandNode; var dragId ; //拖拽节点的父节点的id /** 拖拽前执行 */ function beforeDrag(treeId, treeNodes) { className = (className === &quot;dark&quot; ? &quot;&quot;:&quot;dark&quot;); showLog(&quot;[ &quot;+getTime()+&quot; beforeDrag ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; drag: &quot; + treeNodes.length + &quot; nodes.&quot; ); for (var i=0,l=treeNodes.length; i&lt;l; i++) { dragId = treeNodes[i].pId; if (treeNodes[i].drag === false) { curDragNodes = null; return false; } else if (treeNodes[i].parentTId &amp;&amp; treeNodes[i].getParentNode().childDrag === false) { curDragNodes = null; return false; } } curDragNodes = treeNodes; return true; } function beforeDragOpen(treeId, treeNode) { autoExpandNode = treeNode; return true; } /** 拖拽释放之后执行 */ function beforeDrop(treeId, treeNodes, targetNode, moveType, isCopy) { className = (className === &quot;dark&quot; ? &quot;&quot;:&quot;dark&quot;); showLog(&quot;[ &quot;+getTime()+&quot; beforeDrop ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; moveType:&quot; + moveType); showLog(&quot;target: &quot; + (targetNode ? targetNode.name : &quot;root&quot;) + &quot; -- is &quot;+ (isCopy==null? &quot;cancel&quot; : isCopy ? &quot;copy&quot; : &quot;move&quot;)); if(dragId == targetNode.pId &amp;&amp; moveType != &apos;inner&apos;){// 同级位置调整 var data = &apos;pId=&apos;+dragId+&apos;&amp;currentNodeId=&apos;+treeNodes[0].id+&apos;&amp;newNodeId=&apos;+targetNode.id+&apos;&amp;moveType=&apos;+moveType; nodeExchange(data,modal.sameLevel); }else if(moveType == &apos;inner&apos;){ // 一个节点变成另一个节点的子节点 // 不能移到仓库管理第二节点,物品分类第三节点 if((ckgl == true &amp;&amp; targetNode.level == 2) || (wpfl == true &amp;&amp; targetNode.level == 3)){ return false; }else{ var data = &apos;currentNodeId=&apos;+treeNodes[0].id+&apos;&amp;newParentNodeId=&apos;+targetNode.id; } nodeExchange(data,modal.differentLevel); }else if(dragId != targetNode.pId &amp;&amp; moveType != &apos;inner&apos;){ // 不同级之间的调整 var flag1 = canMove(treeNodes[0].id); if(flag1 == false){ alert(&quot;您选择的节点已经被引用，不能被拖动&quot;); return false; } // 物品管理最高3级，仓库管理最高2级 isParent if(ckgl == true &amp;&amp; treeNodes[0].pId == 0 &amp;&amp; targetNode.level == 2){ alert(&quot;最多支持二级分类&quot;); return false; }else if((wpfl == true &amp;&amp; targetNode.level == 3 &amp;&amp; treeNodes[0].isParent == true) || (wpfl == true &amp;&amp; targetNode.level == 2 &amp;&amp; treeNodes[0].pId == 0)){ alert(&quot;最多支持三级分类&quot;); return false; } var data = &apos;currentNodeId=&apos;+treeNodes[0].id+&apos;&amp;newNodeId=&apos;+targetNode.id+&apos;&amp;moveType=&apos;+moveType; nodeExchange(data,modal.diffLevel); } return true; } function onDrag(event, treeId, treeNodes) { className = (className === &quot;dark&quot; ? &quot;&quot;:&quot;dark&quot;); showLog(&quot;[ &quot;+getTime()+&quot; onDrag ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; drag: &quot; + treeNodes.length + &quot; nodes.&quot; ); } function onDrop(event, treeId, treeNodes, targetNode, moveType, isCopy) { className = (className === &quot;dark&quot; ? &quot;&quot;:&quot;dark&quot;); showLog(&quot;[ &quot;+getTime()+&quot; onDrop ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; moveType:&quot; + moveType); showLog(&quot;target: &quot; + (targetNode ? targetNode.name : &quot;root&quot;) + &quot; -- is &quot;+ (isCopy==null? &quot;cancel&quot; : isCopy ? &quot;copy&quot; : &quot;move&quot;)) } function onExpand(event, treeId, treeNode) { if (treeNode === autoExpandNode) { className = (className === &quot;dark&quot; ? &quot;&quot;:&quot;dark&quot;); showLog(&quot;[ &quot;+getTime()+&quot; onExpand ]&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; + treeNode.name); } } function showLog(str) { if (!log) log = $(&quot;#log&quot;); log.append(&quot;&lt;li class=&apos;&quot;+className+&quot;&apos;&gt;&quot;+str+&quot;&lt;/li&gt;&quot;); if(log.children(&quot;li&quot;).length &gt; 8) { log.get(0).removeChild(log.children(&quot;li&quot;)[0]); } } function getTime() { var now= new Date(), h=now.getHours(), m=now.getMinutes(), s=now.getSeconds(), ms=now.getMilliseconds(); return (h+&quot;:&quot;+m+&quot;:&quot;+s+ &quot; &quot; +ms); } function setTrigger() { var zTree = $.fn.zTree.getZTreeObj(&quot;treeDemo&quot;); zTree.setting.edit.drag.autoExpandTrigger = $(&quot;#callbackTrigger&quot;).attr(&quot;checked&quot;); } /** 鼠标移入移出显示操作图标 */ function over(aa){ $(aa).children(&quot;.hides&quot;).css(&quot;display&quot;,&quot;block&quot;); } function out(aa){ $(aa).children(&quot;.hides&quot;).css(&quot;display&quot;,&quot;none&quot;); } function change_bgcolor(aa){ $(aa).addClass(&quot;active&quot;) .parent().siblings().children().removeClass(&quot;active&quot;); $(&quot;#table-body&quot;).animate({ scrollTop:&apos;0px&apos;, scrollLeft:&apos;0px&apos; },0); } /** 点击物品分类 */ function kind_click(a,b,c){ $(a).addClass(&quot;active&quot;).parent().siblings().children().removeClass(&quot;active&quot;); var oUl = $(a).parent().parent(); var oDiv = oUl.parent(); if(oUl.index() == 0){ $(&quot;.show_kind&quot;).children(&quot;span&quot;).html(&apos;&apos;); $(&quot;.show_kind&quot;).children(&quot;span&quot;).eq(0).html($(a).html()); } else if(oUl.index() == 1){ if(oDiv.children(&quot;ul&quot;).eq(0).find(&quot;.active&quot;).length){ $(&quot;.show_kind&quot;).children(&quot;span&quot;).eq(oUl.index()).html(&quot;-&gt; &quot;+$(a).html()); $(&quot;.show_kind&quot;).children(&quot;span&quot;).eq(2).html(&apos;&apos;); } else{ confirm(&quot;请选中上一级菜单，再点击&quot;); } }else{ if(oUl.index() == 2 &amp;&amp; oDiv.children(&quot;ul&quot;).eq(0).find(&quot;.active&quot;).length &amp;&amp; oDiv.children(&quot;ul&quot;).eq(1).find(&quot;.active&quot;).length){ $(&quot;.show_kind&quot;).children(&quot;span&quot;).eq(oUl.index()).html(&quot;-&gt; &quot;+$(a).html()); } else{ confirm(&quot;请选中上一级菜单，再点击&quot;); } } myKindClick(a,b,c); } /** 删除table记录 */ function delete_tr(p){ var y=p.parentNode.parentNode; y.parentNode.removeChild(y);//只能上找一层parentNode againPx(); } /** 重新排序 */ function againPx(){ var index = 1; $(&quot;td[name=&apos;px&apos;]&quot;).each(function(){ $(this).find(&apos;span&apos;).html(index); index++; }); } /** 新增节点 */ function nodeAdd(treeNode){ $.ajax({ type: &apos;post&apos;, url: modal.saveURL, data: { &apos;id&apos;:null, &apos;sjfl&apos;:treeNode.pId, &apos;mc&apos;:treeNode.name }, dataType: &apos;json&apos;, // async : false, traditional: true, success: function(result) { if (result.success) { var treeObj = $.fn.zTree.getZTreeObj(&quot;treeDemo&quot;); var obj=result.data.obj; treeNode.id = obj[&apos;id&apos;]; treeNode.pId = obj[&apos;sjfl&apos;]; treeObj.updateNode(treeNode); showRemindMsg(); try { mySave(modal); } catch(e) {} } else { alert(result.errorMsg); } }, error: function(XMLHttpRequest, textStatus, errorThrown) { btn.disabled = false; alert(&quot;请求异常&quot;); } }); } /** 编辑节点 */ function nodeEdit(treeNode){ $.ajax({ type: &apos;post&apos;, url: modal.saveURL, data: { &apos;id&apos;:treeNode.id, &apos;sjfl&apos;:treeNode.pId, &apos;mc&apos;:treeNode.name }, dataType: &apos;json&apos;, traditional: true, success: function(result) { // btn.disabled = false; if (result.success) { showRemindMsg(); try { mySave(modal); } catch(e) {} } else { alert(result.errorMsg); } }, error: function(XMLHttpRequest, textStatus, errorThrown) { btn.disabled = false; alert(&quot;请求异常&quot;); } }); } /**执行删除*/ function delNode(modal, id) { var flag=true; $.ajax({ type: &apos;post&apos;, url: modal.deleteURL, data: { ids: id }, async:false, dataType: &apos;json&apos;, traditional: true, success: function(result) { if (result.success) { showRemindMsg(); } else { flag = false; if (result.errorMsg.indexOf(&quot;ConstraintViolationException&quot;) &gt; 0) { alert(&quot;您选择的记录已经被引用，不能被删除&quot;); } } } }); return flag; } /** 节点位置调换 */ function nodeExchange(data,ways){ $.ajax({ type:&quot;get&quot;, data:data, url: ways, dataType:&apos;json&apos;, success: function(result) { if (result.success) { showRemindMsg(); try { mySave(modal); } catch(e) {} } else { alert(result.errorMsg); } }, error: function(XMLHttpRequest, textStatus, errorThrown) { alert(&quot;请求异常&quot;); } }); } /** * 验证节点名字唯一性 * * @param name * @returns {Boolean} */ function check(name){ var flag = true; $.ajax({ type: &apos;post&apos;, url: modal.checkURL, data: { name:name }, dataType: &apos;json&apos;, traditional: true, async:false, success: function(result) { if (result.success) { var check = result.data.check; if(check == false){ flag = false; }else{ flag = true; } try { mySave(modal); } catch(e) {} } else { alert(result.errorMsg); } }, error: function(XMLHttpRequest, textStatus, errorThrown) { btn.disabled = false; alert(&quot;请求异常&quot;); } }); return flag; } /** * 仓库管理二级节点被引用的不能被拖动 * @param kfkwId * @returns {Boolean} */ function canMove(kfkwId){ var flag = true; $.ajax({ type: &apos;get&apos;, url: modal.canMoveURL, data: { id:kfkwId }, dataType: &apos;json&apos;, traditional: true, async:false, success: function(result) { if (result.success) { var can = result.data.canMove; if(can == false){ flag = false; }else{ flag = true; } try { mySave(modal); } catch(e) {} } else { alert(result.errorMsg); } }, error: function(XMLHttpRequest, textStatus, errorThrown) { btn.disabled = false; alert(&quot;请求异常&quot;); } }); return flag; } Controller代码package com.dtyun.ccgl.web.controller.baseinfo; /** * 仓库管理Controller * * @author WangYuanJun */ @Controller @RequestMapping(value = &quot;/baseinfo/ckgl&quot;) @FunctionModule(value = &quot;仓库管理&quot;, entry = &quot;/baseinfo/ckgl&quot;, parent = &quot;基础数据&quot;) public class KfkwController extends BaseController { /** 仓库管理Service */ @Autowired private KfkwService kfkwService; /** 库存历史Service */ @Autowired private KcglHisService kcglHisService; /** 系统配置Service */ @Autowired private CcSysConfigService sysConfigService; private Logger logger = LoggerFactory.getLogger(this.getClass()); @RequestMapping(method = RequestMethod.GET) public String index(Model model) { CcSysConfigEntity sysConfigEntity= sysConfigService.findGjdmcBySchool(AuthUtils.getCurrentSchoolId()); Boolean boolean1 = false; // 设置了仓库根节点名称 if(sysConfigEntity != null){ boolean1 = true; } model.addAttribute(&quot;ssxx&quot;, AuthUtils.getCurrentSchoolId()); model.addAttribute(&quot;booleanSetGjdmc&quot;, boolean1); return &quot;/baseinfo/ckgl/ckgl&quot;; } /** * 添加物品分类 * * @param dto * @param result * @return */ @ResponseBody @RequestMapping(method = RequestMethod.POST) public Retval save(@Valid KfkwDto dto, BindingResult result) { Retval retval = Retval.newInstance(); // 表单校验 if (result.hasErrors()) { retval.fail(getErrorMessage(result)); return retval; } // 保存 try { // 当上级分类为0时，为一级目录 if (dto.getSjfl() == null || dto.getSjfl() == 0) { dto.setSjfl(null); } KfkwEntity kfkwEntity = kfkwService.save(dto); retval.put(&quot;obj&quot;, kfkwEntity); } catch (Exception e) { logger.error(e.getMessage(), e); retval.fail(e.getMessage()); } return retval; } /** * 删除物品分类 * * @param ids * @return */ @ResponseBody @RequestMapping(value = &quot;/delete&quot;, method = RequestMethod.POST) public Retval delete(@RequestParam Long[] ids) { Retval retval = Retval.newInstance(); try { kfkwService.deleteByIds(ids); } catch (DataIntegrityViolationException e) { retval.fail(e.getMessage()); } catch (Exception e) { logger.error(e.getMessage(), e); retval.fail(e.getMessage()); } return retval; } /** * 判断被引用的二级节点能否被移动 * * @param id * @return */ @ResponseBody @RequestMapping(value=&quot;/canMove&quot;,method=RequestMethod.GET) public Retval canMove(@RequestParam Long id){ Retval retval = Retval.newInstance(); Boolean boolean1 = kcglHisService.findKfkwById(id); retval.put(&quot;canMove&quot;, boolean1); return retval; } /** *同级之间拖拽 * * @param pId 拖拽节点父节点id * @param currentNodeId 拖拽节点id * @param newNodeId 目标节点id * @param moveType 拖拽类型 * @return */ @ResponseBody @RequestMapping(value = &quot;/sameLevel&quot;, method = RequestMethod.GET) public Retval sameLevel(@RequestParam Long pId, @RequestParam Long currentNodeId, @RequestParam Long newNodeId, @RequestParam String moveType) { Retval retval = Retval.newInstance(); try { kfkwService.sameLevel(pId, currentNodeId, newNodeId, moveType); } catch (Exception e) { logger.error(e.getMessage(), e); retval.fail(e.getMessage()); } return retval; } /** * 拖拽节点成为目标节点的子节点 * * @param currentNodeId 拖拽节点id * @param newParentNodeId 目标父节点id * @return */ @ResponseBody @RequestMapping(value = &quot;/differentLevel&quot;, method = RequestMethod.GET) public Retval differentLevel(@RequestParam Long currentNodeId, @RequestParam Long newParentNodeId) { Retval retval = Retval.newInstance(); try { kfkwService.differentLevel(currentNodeId, newParentNodeId); } catch (Exception e) { logger.error(e.getMessage(), e); retval.fail(e.getMessage()); } return retval; } /** * 不同级节点为位置调换 * * @param currentNodeId 被拖拽节点id * @param newNodeId 新的节点id * @param moveType * @return */ @ResponseBody @RequestMapping(value = &quot;/diffLevel&quot;, method = RequestMethod.GET) public Retval diffLevel(@RequestParam Long currentNodeId, @RequestParam Long newNodeId,@RequestParam String moveType) { Retval retval = Retval.newInstance(); try { kfkwService.diffLevel(currentNodeId, newNodeId, moveType); } catch (Exception e) { logger.error(e.getMessage(), e); retval.fail(e.getMessage()); } return retval; } /** * 加载树 * * @param id * @param type * @return * @throws Exception */ @ResponseBody @RequestMapping(value = &quot;/renderTree&quot;, method = RequestMethod.GET) public List&lt;Map&lt;String, Object&gt;&gt; renderTree(Long id, String type) throws Exception { List&lt;Map&lt;String, Object&gt;&gt; returnList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); CcSysConfigEntity sysConfigEntity= sysConfigService.findGjdmcBySchool(AuthUtils.getCurrentSchoolId()); // 加载根节点 if (StringUtils.isEmpty(id)) { Map&lt;String, Object&gt; root = new HashMap&lt;String, Object&gt;(); root.put(&quot;id&quot;, 0); root.put(&quot;name&quot;, sysConfigEntity.getCckcgjdmc()); root.put(&quot;isParent&quot;, true); // 加载一级节点 List&lt;Map&lt;String, Object&gt;&gt; returnList1 = new ArrayList&lt;Map&lt;String, Object&gt;&gt;(); List&lt;KfkwEntity&gt; list1 = kfkwService.findLeveL1Node(); for (KfkwEntity kfkw : list1) { Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;(); node.put(&quot;id&quot;, kfkw.getId()); node.put(&quot;name&quot;, kfkw.getMc()); Boolean isParent = kfkwService.hasSubNodeById(kfkw.getId()); node.put(&quot;isParent&quot;, isParent); returnList1.add(node); } root.put(&quot;children&quot;, returnList1); returnList.add(root); return returnList; } // 加载子节点 List&lt;KfkwEntity&gt; list = null; if (id != null &amp;&amp; id &gt; 0L) { list = kfkwService.findSubNodeById(id); for (KfkwEntity kfkw : list) { Map&lt;String, Object&gt; node = new HashMap&lt;String, Object&gt;(); node.put(&quot;id&quot;, kfkw.getId()); node.put(&quot;name&quot;, kfkw.getMc()); Boolean isParent = kfkwService.hasSubNodeById(kfkw.getId()); node.put(&quot;isParent&quot;, isParent); returnList.add(node); } } return returnList; } /** * 查重 * * @param name * @return */ @ResponseBody @RequestMapping(value = &quot;/check&quot;, method = RequestMethod.POST) public Retval check(@RequestParam String name) { Retval retval = Retval.newInstance(); Boolean boolean1 = kfkwService.check(name); retval.put(&quot;check&quot;, boolean1); return retval; } } service代码/** * 仓库管理Service * * @author WangYuanJun */ @Service public class KfkwService extends BaseService{ /** 物品分类Dao */ @Autowired private KfkwDao kfkwDao; /** * 找该级的子目录 * * @param sjfl * @return */ public List&lt;KfkwEntity&gt; findByMaxPx(Long sjfl) { Sort sort = new Sort(Direction.DESC,&quot;px&quot;); return kfkwDao.findAll(spc3(sjfl),sort); } public Specification&lt;KfkwEntity&gt; spc3(Long sjfl) { Specification&lt;KfkwEntity&gt; sp = new Specification&lt;KfkwEntity&gt;() { @Override public Predicate toPredicate(Root&lt;KfkwEntity&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; predicates = Lists.newArrayList(); if(sjfl == null){ Predicate pSjfl = cb.isNull(root.get(&quot;sjfl&quot;).as(Long.class)); predicates.add(pSjfl); }else{ Predicate pSjfl = cb.equal(root.get(&quot;sjfl&quot;).as(Long.class), sjfl); predicates.add(pSjfl); } Predicate pXx = cb.equal(root.get(&quot;ssxx&quot;).as(Long.class), getSchoolId());// 所属学校 predicates.add(pXx); query.where(cb.and(predicates.toArray(new Predicate[predicates.size()]))); return query.getRestriction(); } }; return sp; } /** * 同级之间拖拽 * * @param pId 父节点 * @param currentNodeId 拖拽的id * @param newNodeId 拖拽新的id */ @Transactional public void sameLevel(Long pId, Long currentNodeId, Long newNodeId, String moveType) { // 将他们中间的影响的记录跟新 if (&quot;next&quot;.equals(moveType)) { KfkwEntity currentKfkw = kfkwDao.findOne(currentNodeId); KfkwEntity newKfkw = kfkwDao.findOne(newNodeId); // 向下拖拽 if(currentKfkw.getPx()&lt;newKfkw.getPx()){ // 跟新受影响的记录 List&lt;KfkwEntity&gt; kfkwList = findInfluenceData(pId, currentKfkw.getPx(), newKfkw.getPx()); for (int i = 0; i &lt; kfkwList.size(); i++) { KfkwEntity kfkw = kfkwList.get(i); if (!(kfkw.getId().equals(currentKfkw.getId())) &amp;&amp; !(kfkw.getId().equals(newKfkw.getId()))) { KfkwEntity kfkwEntity2 = kfkwDao.findOne(kfkw.getId()); kfkwEntity2.setPx(kfkwEntity2.getPx() - 1); kfkwDao.save(kfkwEntity2); } } // 拖拽节点排序变为目标节点的排序 currentKfkw.setPx(newKfkw.getPx()); kfkwDao.save(currentKfkw); // 目标排序节点排序为其排序-1 newKfkw.setPx(newKfkw.getPx() - 1); kfkwDao.save(newKfkw); }else{ // 向上拖拽,movetpe=next // 目标节点wpflList.get(0),去除目标节点,将目标节点的下一个节点变为目标节点 List&lt;KfkwEntity&gt; kfkwList = findInfluenceData(pId, currentKfkw.getPx(), newKfkw.getPx()); kfkwList.remove(0); KfkwEntity kfkwNew=kfkwDao.findOne(kfkwList.get(0).getId()); int kfkwNewPx = kfkwNew.getPx(); for (int i = 0; i &lt; kfkwList.size(); i++) { KfkwEntity kfkw = kfkwList.get(i); if (!(kfkw.getId().equals(currentKfkw.getId())) ) { KfkwEntity kfkwEntity2 = kfkwDao.findOne(kfkw.getId()); kfkwEntity2.setPx(kfkwEntity2.getPx() + 1); kfkwDao.save(kfkwEntity2); } } // 拖拽的排序变为目标节点排序 currentKfkw.setPx(kfkwNewPx); kfkwDao.save(currentKfkw); } } else if (&quot;prev&quot;.equals(moveType)) { KfkwEntity currentKfkw = kfkwDao.findOne(currentNodeId); KfkwEntity newKfkw = kfkwDao.findOne(newNodeId); // 向上拖拽 if(currentKfkw.getPx()&gt;newKfkw.getPx()){ // 跟新受影响的记录 List&lt;KfkwEntity&gt; kfkwList = findInfluenceData(pId, currentKfkw.getPx(), newKfkw.getPx()); for (int i = 0; i &lt; kfkwList.size(); i++) { KfkwEntity kfkw = kfkwList.get(i); if (!(kfkw.getId().equals(currentKfkw.getId())) &amp;&amp; !(kfkw.getId().equals(newKfkw.getId()))) { KfkwEntity kfkwEntity2 = kfkwDao.findOne(kfkw.getId()); kfkwEntity2.setPx(kfkwEntity2.getPx() + 1); kfkwDao.save(kfkwEntity2); } } // 拖拽的排序变为目标节点排序 currentKfkw.setPx(newKfkw.getPx()); kfkwDao.save(currentKfkw); // 目标排序的排序为其排序至+1 newKfkw.setPx(newKfkw.getPx() + 1); kfkwDao.save(newKfkw); }else{ // 向下拖拽,movetype=prev // 跟新受影响的记录 // 目标节点wpflList.get(最大值),去除目标节点,将目标节点的上一个节点变为目标节点 List&lt;KfkwEntity&gt; kfkwList = findInfluenceData(pId, currentKfkw.getPx(), newKfkw.getPx()); kfkwList.remove(kfkwList.size()-1); KfkwEntity kfkwNew=kfkwDao.findOne(kfkwList.get(kfkwList.size()-1).getId()); //新的目标节点 int kfkwNewPx = kfkwNew.getPx(); for (int i = 0; i &lt; kfkwList.size(); i++) { KfkwEntity kfkw = kfkwList.get(i); if (!(kfkw.getId().equals(currentKfkw.getId())) ) { KfkwEntity kfkwEntity2 = kfkwDao.findOne(kfkw.getId()); kfkwEntity2.setPx(kfkwEntity2.getPx() - 1); kfkwDao.save(kfkwEntity2); } } // 拖拽节点排序变为目标节点的排序 currentKfkw.setPx(kfkwNewPx); kfkwDao.save(currentKfkw); } } } public List&lt;KfkwEntity&gt; findInfluenceData(Long sjfl, Integer currentNodePx, Integer newNodePx) { Specification&lt;KfkwEntity&gt; spec = new Specification&lt;KfkwEntity&gt;() { @Override public Predicate toPredicate(Root&lt;KfkwEntity&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; predicates = Lists.newArrayList(); if(sjfl != 0){ Predicate p1 = cb.equal(root.get(&quot;sjfl&quot;).as(Long.class), sjfl); predicates.add(p1); }else{ Predicate p1 = cb.isNull(root.get(&quot;sjfl&quot;).as(Long.class)); predicates.add(p1); } Predicate p2 = cb.equal(root.get(&quot;ssxx&quot;).as(Long.class), getSchoolId()); predicates.add(p2); if(currentNodePx&lt;newNodePx){ Predicate p3 = cb.between(root.get(&quot;px&quot;), currentNodePx, newNodePx); predicates.add(p3); }else if(currentNodePx&gt;newNodePx){ Predicate p3 = cb.between(root.get(&quot;px&quot;), newNodePx, currentNodePx); predicates.add(p3);; } query.orderBy(cb.asc(root.get(&quot;px&quot;).as(Long.class))); query.where(cb.and(predicates.toArray(new Predicate[predicates.size()]))); return query.getRestriction(); } }; List&lt;KfkwEntity&gt; wpflList = kfkwDao.findAll(spec); return wpflList; } //成为目标节点的子节点 /** * * @param currentNodeId 拖拽节点id * @param newParentNodeId 目标父节点id * @throws Exception */ @Transactional public void differentLevel(Long currentNodeId,Long newParentNodeId) throws Exception{ KfkwEntity kfkwEntity=kfkwDao.findOne(currentNodeId); // 拖拽节点 List&lt;KfkwEntity&gt; kfkwEntities = null; if(kfkwEntity.getSjfl() != null){ kfkwEntities= findInfluenceData1(kfkwEntity.getSjfl().getId(), kfkwEntity.getPx()); }else{ kfkwEntities= findInfluenceData1(null, kfkwEntity.getPx()); } if(CollectionUtils.isNotEmpty(kfkwEntities)){ // 当前节点为同级最后节点时wpflEntities=[] for (int i = 0; i &lt; kfkwEntities.size(); i++) { KfkwEntity kfkwEntity2= kfkwEntities.get(i); kfkwEntity2.setPx(kfkwEntity2.getPx()-1); kfkwDao.save(kfkwEntity2); } } //当前节点成为目标节点(父节点)的最后一个节点 KfkwDto kfkwDto = new KfkwDto(); List&lt;KfkwEntity&gt; kfkwEntities2= kfkwDao.findByMaxPx(newParentNodeId, getSchoolId()); // 得到目标节点子节点的集合 if(CollectionUtils.isEmpty(kfkwEntities2)){ kfkwDto.setPx(1); }else{ kfkwDto.setPx(kfkwEntities2.get(0).getPx()+1); } kfkwEntity.setSjfl(kfkwDao.findOne(newParentNodeId)); super.save(kfkwEntity, kfkwDto); } public List&lt;KfkwEntity&gt; findInfluenceData1(Long sjfl, Integer currentNodePx) { Specification&lt;KfkwEntity&gt; spec = new Specification&lt;KfkwEntity&gt;() { @Override public Predicate toPredicate(Root&lt;KfkwEntity&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; predicates = Lists.newArrayList(); if(sjfl != null){ Predicate p1 = cb.equal(root.get(&quot;sjfl&quot;).as(Long.class), sjfl); predicates.add(p1); }else{ Predicate p1 = cb.isNull(root.get(&quot;sjfl&quot;).as(Long.class)); predicates.add(p1); } Predicate p2 = cb.equal(root.get(&quot;ssxx&quot;).as(Long.class), getSchoolId()); predicates.add(p2); Predicate p3 = cb.greaterThan(root.get(&quot;px&quot;), currentNodePx); predicates.add(p3); query.orderBy(cb.asc(root.get(&quot;px&quot;).as(Long.class))); query.where(cb.and(predicates.toArray(new Predicate[predicates.size()]))); return query.getRestriction(); } }; List&lt;KfkwEntity&gt; wpflList = kfkwDao.findAll(spec); return wpflList; } /** * 不同级节点为位置调换,movetype != inner * * @param currentNodeId * @param newNodeId * @param moveType * @throws Exception */ @Transactional public void diffLevel(Long currentNodeId, Long newNodeId, String moveType) throws Exception { if(&quot;next&quot;.equals(moveType)){ KfkwEntity currentKfkw = kfkwDao.findOne(currentNodeId);// 拖拽节点 KfkwEntity newKfkw = kfkwDao.findOne(newNodeId);//目标节点 KfkwEntity newKfkwSjfl =null; // 移到第一节点 if(newKfkw.getSjfl() != null){ newKfkwSjfl = kfkwDao.findOne(newKfkw.getSjfl().getId()); //目标节点的父类 } List&lt;KfkwEntity&gt; ccKfkwEntities = null; if(newKfkw.getSjfl() != null){ // 目标节点后面的数据排序+1，如果是最后一位不要+1 ccKfkwEntities = this.findInfluenceData2(newKfkw.getSjfl().getId(), newKfkw.getPx()); }else{ ccKfkwEntities = this.findInfluenceData2(null, newKfkw.getPx()); } if(CollectionUtils.isNotEmpty(ccKfkwEntities)){ for (int i = 0; i &lt; ccKfkwEntities.size(); i++) { KfkwEntity ccKfkwEntity=ccKfkwEntities.get(i); ccKfkwEntity.setPx(ccKfkwEntity.getPx()+1); kfkwDao.save(ccKfkwEntity); } } List&lt;KfkwEntity&gt; cckfkwEntities2 = null; if(currentKfkw.getSjfl() != null){ // 当前节点之后的排序值减一，判断是不是最后一个节点，如果是最后一个节点，就不需要-1了 cckfkwEntities2 = this.findInfluenceData2(currentKfkw.getSjfl().getId(), currentKfkw.getPx()); }else{ cckfkwEntities2 = this.findInfluenceData2(null, currentKfkw.getPx()); } if(CollectionUtils.isNotEmpty(cckfkwEntities2)){ for (int i = 0; i &lt; cckfkwEntities2.size(); i++) { KfkwEntity ccKfkwEntity=cckfkwEntities2.get(i); ccKfkwEntity.setPx(ccKfkwEntity.getPx()-1); kfkwDao.save(ccKfkwEntity); } } currentKfkw.setPx(newKfkw.getPx()+1); currentKfkw.setSjfl(newKfkwSjfl); kfkwDao.save(currentKfkw); }else{ KfkwEntity currentKfkw = kfkwDao.findOne(currentNodeId);// 拖拽节点 KfkwEntity newKfkw = kfkwDao.findOne(newNodeId);//目标节点 KfkwEntity newKfkwSjfl =null; // 移到第一节点 if(newKfkw.getSjfl() != null){ newKfkwSjfl = kfkwDao.findOne(newKfkw.getSjfl().getId()); //目标节点的父类 } List&lt;KfkwEntity&gt; ccKfkwEntities2 = null; if(currentKfkw.getSjfl() !=null){ // 当前节点之后的排序值减一，判断是不是最后一个节点，如果是最后一个节点，就不需要-1了 ccKfkwEntities2 = this.findInfluenceData2(currentKfkw.getSjfl().getId(), currentKfkw.getPx()); }else{ ccKfkwEntities2 = this.findInfluenceData2(null, currentKfkw.getPx()); } if(CollectionUtils.isNotEmpty(ccKfkwEntities2)){ for (int i = 0; i &lt; ccKfkwEntities2.size(); i++) { KfkwEntity ccKfkwEntity=ccKfkwEntities2.get(i); ccKfkwEntity.setPx(ccKfkwEntity.getPx()-1); kfkwDao.save(ccKfkwEntity); } } List&lt;KfkwEntity&gt; ccKfkwEntities = null; if(newKfkw.getSjfl() !=null){ // 目标节点之后的排序值加一 ccKfkwEntities = this.findInfluenceData2(newKfkw.getSjfl().getId(), newKfkw.getPx()); }else{ ccKfkwEntities = this.findInfluenceData2(null, newKfkw.getPx()); } if(CollectionUtils.isNotEmpty(ccKfkwEntities)){ for (int i = 0; i &lt; ccKfkwEntities.size(); i++) { KfkwEntity ccKfkwEntity=ccKfkwEntities.get(i); ccKfkwEntity.setPx(ccKfkwEntity.getPx()+1); kfkwDao.save(ccKfkwEntity); } } currentKfkw.setPx(newKfkw.getPx()); currentKfkw.setSjfl(newKfkwSjfl); kfkwDao.save(currentKfkw); // 目标节点的排序值加一 newKfkw.setPx(newKfkw.getPx()+1); kfkwDao.save(newKfkw); } } public List&lt;KfkwEntity&gt; findInfluenceData2(Long sjfl, Integer currentNodePx) { Specification&lt;KfkwEntity&gt; spec = new Specification&lt;KfkwEntity&gt;() { @Override public Predicate toPredicate(Root&lt;KfkwEntity&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) { List&lt;Predicate&gt; predicates = Lists.newArrayList(); if(sjfl != null){ Predicate p1 = cb.equal(root.get(&quot;sjfl&quot;).as(Long.class), sjfl); predicates.add(p1); }else{ Predicate p1 = cb.isNull(root.get(&quot;sjfl&quot;).as(Long.class)); predicates.add(p1); } Predicate p2 = cb.equal(root.get(&quot;ssxx&quot;).as(Long.class), getSchoolId()); predicates.add(p2); Predicate p3 = cb.greaterThan(root.get(&quot;px&quot;), currentNodePx); predicates.add(p3); query.orderBy(cb.asc(root.get(&quot;px&quot;).as(Long.class))); query.where(cb.and(predicates.toArray(new Predicate[predicates.size()]))); return query.getRestriction(); } }; List&lt;KfkwEntity&gt; wpflList = kfkwDao.findAll(spec); return wpflList; } } dao代码/** * 仓库管理Dao * * @author WangYuanJun */ public interface KfkwDao extends JpaRepository&lt;KfkwEntity, Long&gt;, JpaSpecificationExecutor&lt;KfkwEntity&gt; { @Query(&quot;select o from KfkwEntity o where o.sjfl.id=?1 and o.ssxx.id=?2 order by o.px desc&quot;) public List&lt;KfkwEntity&gt; findByMaxPx(Long sjfl,Long ssxx); }","tags":[{"name":"jquery","slug":"jquery","permalink":"http://wangyuanjun.cn/tags/jquery/"},{"name":"ztree","slug":"ztree","permalink":"http://wangyuanjun.cn/tags/ztree/"}]},{"title":"Maven镜像更换为阿里云镜像","date":"2016-05-10T15:53:34.000Z","path":"2016/05/10/Maven镜像更换为阿里云镜像/","text":"每次update Maven Project 的时候，下载速度非常慢，因为maven仓库默认在国外。国内支持maven镜像的有阿里云，开源中国等，这里换为阿里云的，镜像地址: http://maven.aliyun.com/ 。 找到settings.xml文件的mirrors节点，接着在mirrors节点里面加上一个mirror子节点，内容如下: &lt;mirror&gt; &lt;id&gt;aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt; 修改完毕之后，就可以体验下飞一般的感觉了。","tags":[{"name":"maven","slug":"maven","permalink":"http://wangyuanjun.cn/tags/maven/"}]},{"title":"常用Git命令大全","date":"2016-05-06T13:04:33.000Z","path":"2016/05/06/常用Git命令大全/","text":"一、新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 二、配置 Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name &quot;[name]&quot; $ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] 四、代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 五、分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 六、标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] # 新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] # 提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 七、查看信息 # 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 八、远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 九、撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 十、其他 # 生成一个可供发布的压缩包 $ git archive","tags":[{"name":"git","slug":"git","permalink":"http://wangyuanjun.cn/tags/git/"}]},{"title":"test","date":"2016-04-19T15:53:34.000Z","path":"2016/04/19/test/","text":"this is hexo test page","tags":[]}]